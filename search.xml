<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一个简单的估计</title>
    <url>/2021/07/1-/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="问题">问题</h4>
<p>我们不妨思考这样的一个问题</p>
<p>对于有<span class="math inline">\(n\)</span>个点，<span class="math inline">\(m\)</span>条边的无向图<span class="math inline">\(G\)</span>（不妨认为它没有重边和自环），记<span class="math inline">\(V\)</span>为其点集，<span class="math inline">\(E\)</span>为其边集，给予每个点一个权值<span class="math inline">\(c_i\)</span>，定义函数<span class="math inline">\(f(G) = \sum_{uv \in E} [c_u &gt; c_v]\)</span></p>
<p>现在，不妨设初始状态为<span class="math inline">\(G_0\)</span>，并且我们有<span class="math inline">\(q\)</span>次修改，每次修改将提升一个点的权值，设前<span class="math inline">\(i\)</span>次修改后的图为<span class="math inline">\(G_i\)</span>，那么<span class="math inline">\(S = f(G_0) + \sum_{i=0}^{q-1} |f(G_{i+1}) - f(G_i)|\)</span>大概有多大呢？</p>
<p>这个式子相当于描述每个点维护比自己大的邻点集合时的一种复杂程度</p>
<h4 id="思考">思考</h4>
<p>我们可以先构造一类特殊的操作：<span class="math inline">\(\sqrt m\)</span>个点的完全图，初始时的权值为<span class="math inline">\(1, 2, 3, ..., \sqrt m\)</span>，之后从<span class="math inline">\(1\)</span>到<span class="math inline">\(\sqrt m\)</span>循环操作，每次将<span class="math inline">\(i\)</span>号节点的值增加<span class="math inline">\(\sqrt m\)</span>，这样，每次大小关系的平均变动数量将是一个<span class="math inline">\(\sqrt m\)</span>级的大小</p>
<p>上述构造可以揭示<span class="math inline">\(\sqrt m\)</span>是一个下限，下面我们证明它也是一个上限</p>
<p>我们不妨根据点度分类，称度数<span class="math inline">\(&gt; \sqrt m\)</span>的点为大点，而度数$ m$的点为小点</p>
<p>显然，我们对小点操作时，其带来的变动不可能超过<span class="math inline">\(\sqrt m\)</span>，而度数<span class="math inline">\(&gt; \sqrt m\)</span>的大点也只可能有<span class="math inline">\(\sqrt m\)</span>个，因此操作大点时，对大点之间的大小关系的变动也不可能超过<span class="math inline">\(\sqrt m\)</span>个，那么我们只需要估计大点和小点之间的关系变动情况了</p>
<p>对于这部分，我们设想有这样的一个势函数<span class="math inline">\(\phi(G)\)</span>，当操作小点时，每改变一次其与大点之间的关系，那么这个势函数增加<span class="math inline">\(1\)</span>，而当操作大点时，每改变一次其与小点之间的关系，则减小<span class="math inline">\(1\)</span></p>
<p>每次操作小点时，<span class="math inline">\(\phi(G)\)</span>不会增加超过<span class="math inline">\(\sqrt m\)</span>，而操作大点时，<span class="math inline">\(\phi(G)\)</span>总是减小的，并且<span class="math inline">\(\phi(G)\)</span>非负是显而易见的，用<span class="math inline">\(\phi(G)\)</span>来刻画大点和小点之间的关系变动情况</p>
<p>我们可以知道题述函数大概具有<span class="math inline">\(O(m + q \sqrt m)\)</span>的复杂程度...</p>
]]></content>
      <categories>
        <category>thoughts</category>
      </categories>
      <tags>
        <tag>complexity</tag>
      </tags>
  </entry>
  <entry>
    <title>2021暑期hdu多校3</title>
    <url>/2021/08/2021%E6%9A%91%E6%9C%9Fhdu%E5%A4%9A%E6%A0%A13/</url>
    <content><![CDATA[<span id="more"></span>
<p>老鸽子了</p>
<h4 id="a">A</h4>
<h5 id="吐槽">吐槽</h5>
<p>出题人的符号管理乱七八遭</p>
<h4 id="e-didnt-i-say-to-make-my-abilities-average-in-the-next-life">E Didn't I Say to Make My Abilities Average in the Next Life?!</h4>
<h5 id="吐槽-1">吐槽</h5>
<p>二次元题目</p>
<p>看完题解感觉自己是...</p>
<h5 id="题意">题意</h5>
<p>给定一个序列，<span class="math inline">\(q\)</span>组询问，每次询问一个区间的所有子区间的最大值的和</p>
<h5 id="题解">题解</h5>
<p>题解的两个做法感觉都有点复杂，看不太懂，自己写一个</p>
<p>离线从左到右扫描线，当我们扫到点<span class="math inline">\(r\)</span>时，我们对于每个点<span class="math inline">\(l\)</span>，维护<span class="math inline">\(max_r[l]\)</span>表示<span class="math inline">\([l,r]\)</span>中的最大值，那么<span class="math inline">\(\sum max_i[l]\)</span>将表示<span class="math inline">\([l,l], [l,l+1],...,[l,r]\)</span>的答案的和，从而<span class="math inline">\(\sum_{l \leq L \leq r} \sum max_i[L]\)</span>将是答案</p>
<p>我们可以用线段树来做到这一点，理清之后还挺好写的</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
    
#define gc getchar
inline int read() &#123;
    int p = 0, w = 1; char c = gc();
    while(c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &#123; if(c == &#39;-&#39;) w = -1; c = gc(); &#125;
    while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) &#123; p = p * 10 + c - &#39;0&#39;; c = gc(); &#125;
    return p * w;
&#125;

#define rep(io, st, ed) for(int io = st; io &lt;= ed; io ++)

const int mod = 1e9 + 7;
const int sid = 1e6 + 5;
const int inf = 1e9 + 5;

inline void inc(int &amp;a, int b) &#123; a += b; if(a &gt;= mod) a -= mod; &#125;
inline void dec(int &amp;a, int b) &#123; a -= b; if(a &lt; 0) a += mod; &#125;
inline int Inc(int a, int b) &#123; return (a + b &gt;= mod) ? a + b - mod : a + b; &#125;
inline int Dec(int a, int b) &#123; return (a - b &lt; 0) ? a - b + mod : a - b; &#125;
inline int mul(int a, int b) &#123; return 1ll * a * b % mod; &#125;
inline int fp(int a, int k) &#123; 
    int ret = 1; 
    while(k) &#123; 
        if(k &amp; 1) ret = mul(ret, a); 
        a = mul(a, a); k &gt;&gt;= 1; 
    &#125;
    return ret;
&#125;

struct query &#123;
    int l, id;
    query() &#123;&#125;
    query(int _l, int _id) : l(_l), id(_id) &#123;&#125;
&#125; ;
vector &lt;query&gt; Q[sid];

int n, m;
int a[sid],  ans[sid];
int lst_time[sid], sumtag[sid], sum[sid];
int nowv[sid], presum[sid], pret[sid], newt[sid];

#define ls (o &lt;&lt; 1)
#define rs (o &lt;&lt; 1 | 1)
void build(int o, int l, int r) &#123;
    lst_time[o] = sumtag[o] = sum[o] = 0;
    nowv[o] = presum[o] = pret[o] = newt[o] = 0;
    if(l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    build(ls, l, mid);
    build(rs, mid + 1, r);
&#125;

void down(int o, int l, int r, int nv, int ps, int pt, int nt) &#123;
    inc(sum[o], 1ll * sumtag[o] * (pt - lst_time[o]) % mod);
    inc(sum[o], 1ll * ps * (r - l + 1) % mod);
    if(!nowv[o])  // 先前没有标记
        nowv[o] = nv, presum[o] = ps, pret[o] = pt, newt[o] = nt; 
    else &#123;
        inc(presum[o], ps);
        inc(presum[o], 1ll * nowv[o] * (pt - newt[o]) % mod);
        newt[o] = nt; nowv[o] = nv;
    &#125;
    lst_time[o] = nt; sumtag[o] = mul(r - l + 1, nv);
&#125;

void pushdown(int o, int l, int r) &#123;
    if(!nowv[o]) return;
    int mid = (l + r) &gt;&gt; 1;
    down(ls, l, mid, nowv[o], presum[o], pret[o], newt[o]);
    down(rs, mid + 1, r, nowv[o], presum[o], pret[o], newt[o]);
    nowv[o] = 0; presum[o] = 0;
&#125;

void pushup(int o, int l, int r, int t) &#123;
    inc(sum[o], 1ll * (t - lst_time[o]) * sumtag[o] % mod);
    sumtag[o] = Inc(sumtag[ls], sumtag[rs]);
    lst_time[o] = t;
&#125;

void mdf(int o, int l, int r, int ml, int mr, int v, int t) &#123;
    if(ml &gt; r || mr &lt; l) return;
    if(ml &lt;= l &amp;&amp; mr &gt;= r) &#123; down(o, l, r, v, 0, t, t); return; &#125;
    int mid = (l + r) &gt;&gt; 1;
    pushdown(o, l, r);
    mdf(ls, l, mid, ml, mr, v, t);
    mdf(rs, mid + 1, r, ml, mr, v, t);
    pushup(o, l, r, t);
&#125;

int qry(int o, int l, int r, int ml, int mr, int t) &#123;
    if(ml &gt; r || mr &lt; l) return 0;
    if(ml &lt;= l &amp;&amp; mr &gt;= r) return Inc(sum[o], 1ll * sumtag[o] * (t-lst_time[o]) % mod);
    int mid = (l + r) &gt;&gt; 1;
    pushdown(o, l, r);
    return Inc(qry(ls, l, mid, ml, mr, t), qry(rs, mid + 1, r, ml, mr, t));
&#125;

int st[sid], top;
void segment_work(int opt = 0) &#123;
    a[0] = -inf; top = 0;
    build(1, 1, n);
    rep(r, 1, n) &#123;
        while(top &amp;&amp; a[r] &gt;= a[ st[top] ]) top --;
        mdf(1, 1, n, st[top] + 1, r, (a[r] + mod) % mod, r - 1);
        st[++ top] = r;
        for(auto x : Q[r]) &#123;
            int l = x.l, id = x.id;
            if(!opt) inc(ans[id], qry(1, 1, n, l, r, r));
            else dec(ans[id], qry(1, 1, n, l, r, r));
            if(opt) &#123;
                int len = r - l + 1;
                ans[id] = mul(ans[id], fp(1ll * len * (len + 1) % mod, mod - 2));
            &#125;
        &#125;
    &#125;
&#125;

void solve() &#123;
    n = read(); m = read();
    rep(i, 1, n) a[i] = read(), Q[i].clear();
    rep(i, 1, m) &#123;
        int l = read(), r = read();
        Q[r].push_back( query(l, i) );
        ans[i] = 0;
    &#125;
    segment_work();
    rep(i, 1, n) a[i] = -a[i];
    segment_work(1);
    rep(i, 1, m) printf(&quot;%d\n&quot;, ans[i]);
&#125;

int main() &#123;
    int T = read();
    while(T --) solve();
    return 0;
&#125;</code></pre>
<h4 id="g-increasing-subsequence">G Increasing Subsequence</h4>
<h5 id="题意-1">题意</h5>
<p>给定一个排列，求极大上升子序列的数量</p>
<h5 id="题解-1">题解</h5>
<p><span class="math inline">\(n^2\)</span>做法不难想到，设<span class="math inline">\(f[i]\)</span>表示<span class="math inline">\(a_1,...,a_i\)</span>中的极大上升子序列的数量，考虑转移，<span class="math inline">\(j\)</span>能转移到<span class="math inline">\(i\)</span>，当且仅当<span class="math inline">\(a_j &lt; a_i\)</span>，并且区间<span class="math inline">\([j+1, i-1]\)</span>中，没有在<span class="math inline">\([a_j,a_i]\)</span>中的数</p>
<p>抽象一下，也即能转移到<span class="math inline">\(f[i]\)</span>的<span class="math inline">\(j\)</span>将构成一个满足下标<span class="math inline">\(j&lt;i\)</span>，权值<span class="math inline">\(a_j &lt; a_i\)</span>的数构成的单调栈</p>
<p>我们可以考虑用分治解决下标这一维，对于<span class="math inline">\([l, r]\)</span>，考虑<span class="math inline">\([l, mid]\)</span>对<span class="math inline">\([mid + 1, r]\)</span>的贡献</p>
<p>由于分治，<span class="math inline">\([mid + 1, r]\)</span>中的元素不存在下标上的影响，对权值上的影响，只需要预处理出<span class="math inline">\([mid + 1, r]\)</span>中每个数左边比它小的最大数即可</p>
<p>对于<span class="math inline">\([l, mid]\)</span>而言，我们按权值大小来建立单调栈，右边相应的按照权值在单调栈上二分即可</p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>Btree</title>
    <url>/2021/07/Btree/</url>
    <content><![CDATA[<span id="more"></span>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> M <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// 几路的B树</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> INF <span class="op">=</span> <span class="fl">1e9</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> BTree <span class="op">&#123;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Bnode<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    Bnode <span class="op">*</span>root<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Bnode <span class="op">&#123;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> size<span class="op">,</span> val<span class="op">[</span>M <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        Bnode <span class="op">*</span>parent<span class="op">,</span> <span class="op">*</span>son<span class="op">[</span>M <span class="op">+</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        Bnode<span class="op">(</span>Bnode<span class="op">*</span> <span class="va">parent_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> parent <span class="op">=</span> <span class="va">parent_</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> M<span class="op">;</span> i <span class="op">++)</span> son<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">&amp;</span>begin_val<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> val<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">&#125;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        Bnode <span class="op">*&amp;</span>begin_son<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> son<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">&#125;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">&amp;</span>end_val<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> val<span class="op">[</span>size <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="op">&#125;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        Bnode <span class="op">*</span>end_son<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> son<span class="op">[</span>size<span class="op">];</span> <span class="op">&#125;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> empty<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> <span class="op">!</span>size<span class="op">;</span> <span class="op">&#125;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> is_full<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> size <span class="op">&gt;=</span> M<span class="op">;</span> <span class="op">&#125;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> is_enough<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> size <span class="op">&gt;=</span> ceil<span class="op">(</span>M <span class="op">/</span> <span class="fl">2.0</span><span class="op">);</span> <span class="op">&#125;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> not_enough<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> size <span class="op">&lt;</span> ceil<span class="op">(</span>M <span class="op">/</span> <span class="fl">2.0</span><span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="op">&#125;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> is_leaf<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> <span class="op">!</span>size <span class="op">||</span> <span class="op">(</span>son<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="kw">nullptr</span><span class="op">);</span> <span class="op">&#125;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> is_root<span class="op">()</span> <span class="op">&#123;</span> <span class="cf">return</span> parent <span class="op">==</span> <span class="kw">nullptr</span><span class="op">;</span> <span class="op">&#125;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_parent<span class="op">(</span>Bnode <span class="op">*</span>nson<span class="op">)</span> <span class="op">&#123;</span> <span class="cf">if</span><span class="op">(</span>nson<span class="op">)</span> nson <span class="op">-&gt;</span> parent <span class="op">=</span> <span class="kw">this</span><span class="op">;</span> <span class="op">&#125;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> print<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>size<span class="op">)</span> printf<span class="op">(</span><span class="st">&quot;empty!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i <span class="op">++)</span> printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span><span class="op">,</span> val<span class="op">[</span>i<span class="op">]);</span> </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> find<span class="op">(</span><span class="dt">int</span> <span class="va">val_</span><span class="op">)</span> <span class="op">&#123;</span> <span class="co">// if in (val[i], val[i + 1] ], then in son[i + 1]</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i <span class="op">++)</span> <span class="cf">if</span><span class="op">(</span><span class="va">val_</span> <span class="op">&lt;=</span> val<span class="op">[</span>i<span class="op">])</span> <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> size<span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get_val_id<span class="op">(</span><span class="dt">int</span> <span class="va">val_</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i <span class="op">++)</span> <span class="cf">if</span><span class="op">(</span>val<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="va">val_</span><span class="op">)</span> <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get_son_id<span class="op">(</span>Bnode <span class="op">*</span><span class="va">son_</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> size<span class="op">;</span> i <span class="op">++)</span> <span class="cf">if</span><span class="op">(</span>son<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="va">son_</span><span class="op">)</span> <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> rightshift<span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">&#123;</span> <span class="co">// move son[pos],val[pos],...son[size], thus son[pos], val[pos] are empty, noticing size ++</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> pos<span class="op">;</span> i <span class="op">--)</span> val<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> val<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">;</span> i <span class="op">&gt;=</span> pos<span class="op">;</span> i <span class="op">--)</span> son<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> son<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            size <span class="op">++;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> rightshift2<span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">&#123;</span> <span class="co">// move val[pos],...,son[size], thus val[pos],son[pos+1] are empty, noticing size ++</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            rightshift<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> val<span class="op">[</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> val<span class="op">[</span>pos<span class="op">];</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> leftshift<span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">&#123;</span> <span class="co">// move son[pos],val[pos],...,son[size], thus son[pos], val[pos] can be deleted, noticing size --</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>            size <span class="op">--;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> pos<span class="op">;</span> i <span class="op">&lt;=</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">++)</span> val<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> val<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> pos<span class="op">;</span> i <span class="op">&lt;=</span> size<span class="op">;</span> i <span class="op">++)</span> son<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> son<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> leftshift2<span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">&#123;</span> <span class="co">// empty val[pos], son[pos + 1], noticing size --</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>            val<span class="op">[</span>pos<span class="op">]</span> <span class="op">=</span> val<span class="op">[</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">];</span> leftshift<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> </span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> insert_begin<span class="op">(</span><span class="dt">int</span> <span class="va">val_</span><span class="op">,</span> Bnode <span class="op">*</span><span class="va">son_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span>  </span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            rightshift<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            val<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="va">val_</span><span class="op">;</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>            son<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="va">son_</span><span class="op">;</span> set_parent<span class="op">(</span><span class="va">son_</span><span class="op">);</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> insert_end<span class="op">(</span><span class="dt">int</span> <span class="va">val_</span><span class="op">,</span> Bnode <span class="op">*</span><span class="va">son_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>            val<span class="op">[</span>size <span class="op">++]</span> <span class="op">=</span> <span class="va">val_</span><span class="op">;</span> </span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>            son<span class="op">[</span>size<span class="op">]</span> <span class="op">=</span> <span class="va">son_</span><span class="op">;</span> set_parent<span class="op">(</span><span class="va">son_</span><span class="op">);</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> insert_mid_before<span class="op">(</span><span class="dt">int</span> <span class="va">pos_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">val_</span><span class="op">,</span> Bnode <span class="op">*</span><span class="va">son_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span> <span class="co">// insert son[pos], val[pos]</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>            rightshift<span class="op">(</span><span class="va">pos_</span><span class="op">);</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>            val<span class="op">[</span><span class="va">pos_</span><span class="op">]</span> <span class="op">=</span> <span class="va">val_</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>            son<span class="op">[</span><span class="va">pos_</span><span class="op">]</span> <span class="op">=</span> <span class="va">son_</span><span class="op">;</span> set_parent<span class="op">(</span><span class="va">son_</span><span class="op">);</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> insert_mid_after<span class="op">(</span><span class="dt">int</span> <span class="va">pos_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">val_</span><span class="op">,</span> Bnode <span class="op">*</span><span class="va">son_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span> <span class="co">// insert val[pos], son[pos + 1]</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            rightshift2<span class="op">(</span><span class="va">pos_</span><span class="op">);</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>            val<span class="op">[</span><span class="va">pos_</span><span class="op">]</span> <span class="op">=</span> <span class="va">val_</span><span class="op">;</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>            son<span class="op">[</span><span class="va">pos_</span> <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="va">son_</span><span class="op">;</span> set_parent<span class="op">(</span><span class="va">son_</span><span class="op">);</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> delete_begin<span class="op">()</span> <span class="op">&#123;</span> <span class="co">// delete son[0], val[0]</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>            leftshift<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> delete_end<span class="op">()</span> <span class="op">&#123;</span> <span class="co">// delete val[size - 1], son[size]</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>            size <span class="op">--;</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> delete_mid_before<span class="op">(</span><span class="dt">int</span> <span class="va">pos_</span><span class="op">)</span> <span class="op">&#123;</span> <span class="co">// delete son[pos], val[pos]</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            leftshift<span class="op">(</span><span class="va">pos_</span><span class="op">);</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> delete_mid_after<span class="op">(</span><span class="dt">int</span> <span class="va">pos_</span><span class="op">)</span> <span class="op">&#123;</span> <span class="co">//delete val[pos], son[pos + 1]</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>            leftshift2<span class="op">(</span><span class="va">pos_</span><span class="op">);</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> insert_leaf<span class="op">(</span><span class="dt">int</span> <span class="va">val_</span><span class="op">)</span> <span class="op">&#123;</span> <span class="co">// leaf case</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> <span class="va">pos_</span> <span class="op">=</span> find<span class="op">(</span><span class="va">val_</span><span class="op">);</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>            insert_mid_before<span class="op">(</span><span class="va">pos_</span><span class="op">,</span> <span class="va">val_</span><span class="op">);</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Move<span class="op">(</span><span class="dt">int</span> L_<span class="op">,</span> Bnode<span class="op">*</span> Rnode<span class="op">)</span> <span class="op">&#123;</span> <span class="co">//move val[L_],son[L+1]...,val[size-1],son[size] from (this) to Rnode</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> R_ <span class="op">=</span> <span class="kw">this</span> <span class="op">-&gt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> L_<span class="op">;</span> i <span class="op">&lt;=</span> R_<span class="op">;</span> i <span class="op">++)</span> Rnode <span class="op">-&gt;</span> insert_end<span class="op">(</span>val<span class="op">[</span>i<span class="op">],</span> son<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>             size <span class="op">-=</span> R_ <span class="op">-</span> L_ <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// equals to &quot;for(int i = L_; i &lt;= R_; i ++) delete_end();&quot;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> split<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>parent <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">=</span> <span class="kw">new</span> Bnode<span class="op">();</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">-&gt;</span> son<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>            Bnode<span class="op">*</span> brother <span class="op">=</span> <span class="kw">new</span> Bnode<span class="op">(</span>parent<span class="op">);</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> lr <span class="op">=</span> ceil<span class="op">(</span>M <span class="op">/</span> <span class="fl">2.0</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> rl <span class="op">=</span> lr <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> pos <span class="op">=</span> parent <span class="op">-&gt;</span> get_son_id<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">-&gt;</span> insert_mid_after<span class="op">(</span>pos<span class="op">,</span> val<span class="op">[</span>lr <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> brother<span class="op">);</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>            Move<span class="op">(</span>rl<span class="op">,</span> brother<span class="op">);</span> </span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>            brother <span class="op">-&gt;</span> son<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">this</span> <span class="op">-&gt;</span> end_son<span class="op">();</span> </span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>            brother <span class="op">-&gt;</span> set_parent<span class="op">(</span>brother <span class="op">-&gt;</span> son<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span> <span class="op">-&gt;</span> delete_end<span class="op">();</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;;</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Insert<span class="op">(</span><span class="dt">int</span> val<span class="op">)</span> <span class="op">&#123;</span> <span class="co">// use this function to insert v</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>root <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> root <span class="op">=</span> <span class="kw">new</span> Bnode<span class="op">();</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>        Bnode <span class="op">*</span>now <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_leaf<span class="op">())</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>            now <span class="op">=</span> now <span class="op">-&gt;</span> son<span class="op">[</span>now <span class="op">-&gt;</span> find<span class="op">(</span>val<span class="op">)];</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>        now <span class="op">-&gt;</span> insert_leaf<span class="op">(</span>val<span class="op">);</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_root<span class="op">())</span> <span class="op">&#123;</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_full<span class="op">())</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>            now <span class="op">-&gt;</span> split<span class="op">();</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>            now <span class="op">=</span> now <span class="op">-&gt;</span> parent<span class="op">;</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_full<span class="op">())</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>        now <span class="op">-&gt;</span> split<span class="op">();</span> root <span class="op">=</span> now <span class="op">-&gt;</span> parent<span class="op">;</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> val_locate<span class="op">(</span><span class="dt">int</span> val<span class="op">,</span> Bnode<span class="op">*</span> <span class="op">&amp;</span>now<span class="op">,</span> <span class="dt">int</span> <span class="op">&amp;</span>pos<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>now <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> now <span class="op">-&gt;</span> find<span class="op">(</span>val<span class="op">);</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>pos <span class="op">!=</span> now <span class="op">-&gt;</span> size <span class="op">&amp;&amp;</span> now <span class="op">-&gt;</span> val<span class="op">[</span>pos<span class="op">]</span> <span class="op">==</span> val<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>            now <span class="op">=</span> now <span class="op">-&gt;</span> son<span class="op">[</span>pos<span class="op">];</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;;</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> precursor<span class="op">(</span>Bnode<span class="op">*</span> <span class="op">&amp;</span>now<span class="op">,</span> <span class="dt">int</span> <span class="op">&amp;</span>pos<span class="op">,</span> <span class="dt">int</span> first_step<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>        now <span class="op">=</span> now <span class="op">-&gt;</span> son<span class="op">[</span>first_step<span class="op">];</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_leaf<span class="op">())</span> now <span class="op">=</span> now <span class="op">-&gt;</span> son<span class="op">[</span>now <span class="op">-&gt;</span> size<span class="op">];</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> now <span class="op">-&gt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> Adjust<span class="op">(</span>Bnode<span class="op">*</span> <span class="op">&amp;</span>now<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>        Bnode<span class="op">*</span> parent <span class="op">=</span> now <span class="op">-&gt;</span> parent<span class="op">;</span></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>now <span class="op">-&gt;</span> not_enough<span class="op">())</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pos <span class="op">=</span> parent <span class="op">-&gt;</span> get_son_id<span class="op">(</span>now<span class="op">);</span></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>pos<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>             <span class="co">// adjust with son[pos](now), val[pos], son[pos+1](bro)</span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>             Bnode <span class="op">*</span>bro <span class="op">=</span> parent <span class="op">-&gt;</span> son<span class="op">[</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>             <span class="cf">if</span><span class="op">(</span>bro <span class="op">-&gt;</span> is_enough<span class="op">())</span> <span class="op">&#123;</span> <span class="co">// the move case</span></span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>                now <span class="op">-&gt;</span> insert_end<span class="op">(</span>parent <span class="op">-&gt;</span> val<span class="op">[</span>pos<span class="op">],</span> bro <span class="op">-&gt;</span> begin_son<span class="op">());</span></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">-&gt;</span> val<span class="op">[</span>pos<span class="op">]</span> <span class="op">=</span> bro <span class="op">-&gt;</span> begin_val<span class="op">();</span></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>                bro <span class="op">-&gt;</span> delete_begin<span class="op">();</span></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>             <span class="op">&#125;</span></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>             <span class="cf">else</span> <span class="op">&#123;</span> <span class="co">// the merge case</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>                now <span class="op">-&gt;</span> insert_end<span class="op">(</span>parent <span class="op">-&gt;</span> val<span class="op">[</span>pos<span class="op">],</span> bro <span class="op">-&gt;</span> begin_son<span class="op">());</span></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>                bro <span class="op">-&gt;</span> Move<span class="op">(</span><span class="dv">0</span><span class="op">,</span> now<span class="op">);</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">-&gt;</span> delete_mid_after<span class="op">(</span>pos<span class="op">);</span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>                <span class="kw">delete</span> bro<span class="op">;</span></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>             <span class="op">&#125;</span></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">&#123;</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a>            <span class="co">// adjust with son[pos-1](bro), val[pos-1], son[pos](now)</span></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>             Bnode <span class="op">*</span>bro <span class="op">=</span> parent <span class="op">-&gt;</span> son<span class="op">[</span>pos <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>             <span class="cf">if</span><span class="op">(</span>bro <span class="op">-&gt;</span> is_enough<span class="op">())</span> <span class="op">&#123;</span></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>                now <span class="op">-&gt;</span> insert_begin<span class="op">(</span>parent <span class="op">-&gt;</span> val<span class="op">[</span>pos <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> bro <span class="op">-&gt;</span> end_son<span class="op">());</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">-&gt;</span> val<span class="op">[</span>pos <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> bro <span class="op">-&gt;</span> end_val<span class="op">();</span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>                bro <span class="op">-&gt;</span> delete_end<span class="op">();</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>             <span class="op">&#125;</span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>             <span class="cf">else</span> <span class="op">&#123;</span></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>                bro <span class="op">-&gt;</span> insert_end<span class="op">(</span>parent <span class="op">-&gt;</span> val<span class="op">[</span>pos <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> now <span class="op">-&gt;</span> begin_son<span class="op">());</span></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>                now <span class="op">-&gt;</span> Move<span class="op">(</span><span class="dv">0</span><span class="op">,</span> bro<span class="op">);</span></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>                parent <span class="op">-&gt;</span> delete_mid_after<span class="op">(</span>pos <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>                <span class="kw">delete</span> now<span class="op">;</span></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>                now <span class="op">=</span> bro<span class="op">;</span></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>             <span class="op">&#125;</span></span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>root <span class="op">-&gt;</span> empty<span class="op">())</span> <span class="op">&#123;</span></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> now<span class="op">;</span></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>            root <span class="op">-&gt;</span> parent <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>        now <span class="op">=</span> now <span class="op">-&gt;</span> parent<span class="op">;</span></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> Delete<span class="op">(</span><span class="dt">int</span> val<span class="op">)</span> <span class="op">&#123;</span> <span class="co">// use this function to delete v</span></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pos<span class="op">;</span> Bnode<span class="op">*</span> now <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>        val_locate<span class="op">(</span>val<span class="op">,</span> now<span class="op">,</span> pos<span class="op">);</span></span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>now <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_leaf<span class="op">())</span> <span class="op">&#123;</span></span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> ppos<span class="op">;</span> Bnode<span class="op">*</span> pre <span class="op">=</span> now<span class="op">;</span></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a>            precursor<span class="op">(</span>pre<span class="op">,</span> ppos<span class="op">,</span> pos<span class="op">);</span></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>pre <span class="op">-&gt;</span> val<span class="op">[</span>ppos<span class="op">],</span> now <span class="op">-&gt;</span> val<span class="op">[</span>pos<span class="op">]);</span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a>            now <span class="op">=</span> pre<span class="op">;</span> pos <span class="op">=</span> ppos<span class="op">;</span></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>        now <span class="op">-&gt;</span> delete_mid_before<span class="op">(</span>pos<span class="op">);</span> <span class="co">// leaf case, deleted</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>now <span class="op">-&gt;</span> is_root<span class="op">()</span> <span class="op">&amp;&amp;</span> now <span class="op">-&gt;</span> empty<span class="op">())</span> <span class="op">&#123;</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span> root<span class="op">;</span></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>now <span class="op">-&gt;</span> is_root<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>Adjust<span class="op">(</span>now<span class="op">));</span></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use for debugging</span></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len<span class="op">,</span> dep<span class="op">;</span></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> output<span class="op">[</span><span class="dv">123456</span><span class="op">];</span></span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ck<span class="op">[</span><span class="dv">123456</span><span class="op">],</span> tmp<span class="op">[</span><span class="dv">123</span><span class="op">];</span></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> write<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> tlen <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>x<span class="op">)</span> tmp<span class="op">[++</span> tlen<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>x<span class="op">)</span> tmp<span class="op">[++</span> tlen<span class="op">]</span> <span class="op">=</span> x <span class="op">%</span> <span class="dv">10</span><span class="op">,</span> x <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> tlen<span class="op">;</span> i<span class="op">;</span> i <span class="op">--)</span> output<span class="op">[++</span> len<span class="op">]</span> <span class="op">=</span> tmp<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dfs<span class="op">(</span>Bnode<span class="op">*</span> now<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>now <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a>        output<span class="op">[++</span> len<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39; &#39;</span><span class="op">;</span> ck<span class="op">[</span>len<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>now <span class="op">-&gt;</span> son<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>        output<span class="op">[++</span> len<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39; &#39;</span><span class="op">;</span> ck<span class="op">[</span>len<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> now <span class="op">-&gt;</span> size<span class="op">;</span> i <span class="op">++)</span> <span class="op">&#123;</span></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>            write<span class="op">(</span>now <span class="op">-&gt;</span> val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>            output<span class="op">[++</span> len<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39; &#39;</span><span class="op">;</span> ck<span class="op">[</span>len<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>            dfs<span class="op">(</span>now <span class="op">-&gt;</span> son<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]);</span> </span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>            output<span class="op">[++</span> len<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39; &#39;</span><span class="op">;</span> ck<span class="op">[</span>len<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a>        len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> dep <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">100000</span><span class="op">;</span> i <span class="op">++)</span> ck<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>root<span class="op">);</span></span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> len<span class="op">;</span> i <span class="op">++)</span> printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> output<span class="op">[</span>i<span class="op">]);</span> </span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the next part is using for special output</span></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>         </span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>        <span class="co">//int maxdep = 0;</span></span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>        <span class="co">//for(int i = 1; i &lt;= len; i ++) dep += ck[i], maxdep = max(maxdep, dep);</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a>        <span class="co">//for(int D = 0; D &lt;= maxdep; D ++) &#123;</span></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  for(int i = 1; i &lt;= len; i ++) dep += ck[i], printf(&quot;%c&quot;, (dep == D) ? output[i] : &#39; &#39;); </span></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  printf(&quot;\n&quot;);</span></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a>        <span class="co">//&#125;</span></span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span> T<span class="op">;</span></span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">++)</span> T<span class="op">.</span>Insert<span class="op">(</span>i <span class="op">^</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>    T<span class="op">.</span>print<span class="op">();</span></span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div>
]]></content>
      <categories>
        <category>codes</category>
      </categories>
      <tags>
        <tag>ds</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数2</title>
    <url>/2021/11/abstract-algebra-2/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="环">环</h2>
<h3 id="week9">week9</h3>
<h4 id="环-1">环</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为一个非空集，在其上定义了<span class="math inline">\(+, *\)</span>两种运算</p>
<p>如果<span class="math inline">\(R\)</span>按<span class="math inline">\(+\)</span>构成Abel群，按<span class="math inline">\(*\)</span>构成半群</p>
<p>并且<span class="math inline">\(*\)</span>对<span class="math inline">\(+\)</span>有分配律（<span class="math inline">\(a*(b+c)=a*b+a*c, \;(b+c)*a=b*a+c*a\)</span>）</p>
<p>则称<span class="math inline">\(R\)</span>按<span class="math inline">\(+, *\)</span>构成<strong>环</strong></p>
<p>而<span class="math inline">\(\langle R, +, *\rangle\)</span>称为环的结构</p>
</blockquote>
<p><span class="math inline">\(R\)</span>的加法单位元，记为<span class="math inline">\(0\)</span>，称为零元</p>
<h4 id="特殊的环">特殊的环</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，如果<span class="math inline">\(R\)</span>对乘法交换，则称<span class="math inline">\(R\)</span>为交换环</p>
</blockquote>
<blockquote>
<p>若环<span class="math inline">\(R\)</span>对乘法构成幺半群，则称<span class="math inline">\(R\)</span>为幺环</p>
</blockquote>
<p>为了引入整环，我们先定义零因子</p>
<blockquote>
<p>如果存在<span class="math inline">\(a, b \in R\)</span>，如果<span class="math inline">\(a\neq 0, b \neq 0\)</span>，但<span class="math inline">\(ab=0\)</span>，则称<span class="math inline">\(a\)</span>为（左）零因子，<span class="math inline">\(b\)</span>为（右）零因子</p>
</blockquote>
<blockquote>
<p>无零因子的交换幺环称为整环</p>
</blockquote>
<h4 id="例子">例子</h4>
<ul>
<li><p><span class="math inline">\(Z\)</span>按整数加法，整数乘法构成整环</p></li>
<li><p><span class="math inline">\(Z/mZ\)</span>按取模加法，取模乘法构成交换幺环</p></li>
<li><p>记<span class="math inline">\(R[x]=\{a_0 + a_1x + ...+a_nx^n : a_0,a_1, ..., a_n \in R, n \in N\}\)</span>，</p>
<p>在其上定义加法：<span class="math inline">\(\sum_i a_ix^i + \sum_i b_i x^i = \sum_i (a_i + b_i)x^i\)</span></p>
<p>在其上定义乘法：<span class="math inline">\((\sum_i a_ix^i)(\sum_j b_jx^j) = \sum_k (\sum_{i+j=k} a_ib_j) x^k\)</span></p>
<p>那么，<span class="math inline">\(R[x]\)</span>构成环（成为环<span class="math inline">\(R\)</span>上的一元多项式环），<span class="math inline">\(x\)</span>称为未定元</p>
<ul>
<li><span class="math inline">\(R\)</span>为交换环时，<span class="math inline">\(R[x]\)</span>也构成交换环</li>
<li><span class="math inline">\(R\)</span>无零因子时，<span class="math inline">\(R[x]\)</span>也没有零因子</li>
<li><span class="math inline">\(R\)</span>为幺环时，<span class="math inline">\(R[x]\)</span>也为幺环</li>
</ul></li>
<li><p>记<span class="math inline">\(M_n(R) = \{(a_{ij})_{n \times n} : a_{ij} \in R\}\)</span>，称为<span class="math inline">\(R\)</span>上的<span class="math inline">\(n \times n\)</span>的矩阵环</p>
<ul>
<li><span class="math inline">\(R\)</span>为交换环时，<span class="math inline">\(M_n(R)\)</span>不一定为交换环</li>
<li><span class="math inline">\(R\)</span>没有零因子时，<span class="math inline">\(M_n(R)\)</span>也不一定没有零因子</li>
</ul></li>
</ul>
<h3 id="week10">week10</h3>
<h4 id="环的性质">环的性质</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(a_1, a_2,..., a_n \in R, b_1, ..., b_n \in R\)</span>，那么<span class="math inline">\((\sum_{i=1}^n a_i)(\sum_{j=1}^m b_j) = \sum_{i=1}^n \sum_{j=1}^m a_ib_j\)</span></p>
</blockquote>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，那么<span class="math inline">\(\forall a \in R, a * 0 = 0*a = 0\)</span></p>
</blockquote>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(R\)</span>中有零因子当且仅当<span class="math inline">\(R\)</span>中有消去律（即<span class="math inline">\(a \neq 0\)</span>时，<span class="math inline">\(ab=ac \Leftrightarrow b=c\)</span>, <span class="math inline">\(ba=ca \Leftrightarrow b=c\)</span>）</p>
</blockquote>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，对<span class="math inline">\(a \in R, n \in Z^+\)</span>，定义<span class="math inline">\(na = \overbrace{a + a +... +a}^{n个}\)</span></p>
<p>对<span class="math inline">\(n=0\)</span>，定义<span class="math inline">\(na = 0\)</span></p>
<p>对<span class="math inline">\(n &lt; 0\)</span>，定义<span class="math inline">\(na = (-n)(-a) = \overbrace{-a + (-a) +... +(-a)}^{-n个}\)</span></p>
<p>那么，对<span class="math inline">\(m \in Z, a, b\in R\)</span>，有<span class="math inline">\((ma)b=m(ab)=a(mb)\)</span></p>
</blockquote>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换环，那么<span class="math inline">\((a+b)^n = \sum_{k=0}^n \binom{n}{k} a^k b^{n-k}\)</span></p>
</blockquote>
<h4 id="子环">子环</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(S \subseteq R\)</span>且<span class="math inline">\(S \neq \emptyset\)</span>，如果<span class="math inline">\(S\)</span>按<span class="math inline">\(R\)</span>中的加法和乘法构成环，那么称<span class="math inline">\(S\)</span>为<span class="math inline">\(R\)</span>的子环，记为<span class="math inline">\(S \leq R\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(S \leq R\)</span>等价于<span class="math inline">\(S\)</span>对加法，减法，乘法封闭</li>
<li><span class="math inline">\(O = \{0\}\)</span>是最小子环，称为零环</li>
<li>对<span class="math inline">\(O \neq S \subseteq R\)</span>，有<span class="math inline">\(S\)</span>中的单位元<span class="math inline">\(1 \neq 0\)</span></li>
</ul>
<h4 id="理想">理想</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(\emptyset \neq I \subseteq R\)</span>，如果</p>
<ul>
<li>若<span class="math inline">\(a, b\in I\)</span>，那么<span class="math inline">\(a \pm b \in I\)</span></li>
<li>若<span class="math inline">\(a \in I, r \in R\)</span>，那么<span class="math inline">\(a*r, r*a \in I\)</span></li>
</ul>
<p>则称<span class="math inline">\(I\)</span>为环<span class="math inline">\(R\)</span>的理想</p>
</blockquote>
<p>理想相当于正规子环</p>
<h4 id="剩余类">剩余类</h4>
<blockquote>
<p>设<span class="math inline">\(I\)</span>为<span class="math inline">\(R\)</span>的理想，对<span class="math inline">\(a, b \in R\)</span>，如果<span class="math inline">\(a - b \in I\)</span>，则称<span class="math inline">\(a \equiv b(mod\;I)\)</span>，称为<span class="math inline">\(a, b\)</span>模<span class="math inline">\(I\)</span>同余</p>
</blockquote>
<ul>
<li>这是一个等价关系</li>
</ul>
<blockquote>
<p>按模<span class="math inline">\(I\)</span>同余关系形成的等价类，即<span class="math inline">\(\bar{a} = a + I\)</span>，称为<span class="math inline">\(a\)</span>在模<span class="math inline">\(I\)</span>下的<strong>剩余类</strong></p>
<p>对剩余类，我们定义加法和乘法</p>
<ul>
<li><p><span class="math inline">\(\bar{a} + \bar{b} = \overline{a+b}\)</span></p></li>
<li><p><span class="math inline">\(\bar{a} * \bar{b} = \overline{a*b}\)</span></p>
<p>（注意这个定义和群是有所区别的，因为<span class="math inline">\((a+I)(b+I) \neq ab + I\)</span>不一定成立，但我们可以保证<span class="math inline">\((a+I)(b+I) \subseteq ab+ I\)</span>，故而该定义是合法的）</p></li>
</ul>
</blockquote>
<h4 id="商环">商环</h4>
<blockquote>
<p>设<span class="math inline">\(I\)</span>为环<span class="math inline">\(R\)</span>的理想，那么<span class="math inline">\(I\)</span>的剩余类按照剩余类的加法和乘法构成环，称为商环</p>
</blockquote>
<ul>
<li><span class="math inline">\(mZ\)</span>为<span class="math inline">\(Z\)</span>的理想，<span class="math inline">\(a \equiv b (mod\;mZ)\)</span>相当于<span class="math inline">\(a \equiv b(mod\;m)\)</span></li>
</ul>
<h4 id="同构">同构</h4>
<blockquote>
<p>设<span class="math inline">\(\sigma\)</span>为环<span class="math inline">\(R\)</span>到环<span class="math inline">\(R&#39;\)</span>的映射，若<span class="math inline">\(\forall a, b, \in R\)</span>，有</p>
<ul>
<li><span class="math inline">\(\sigma(a+b)=\sigma(a)+\sigma(b)\)</span></li>
<li><span class="math inline">\(\sigma(ab)=\sigma(a)\sigma(b)\)</span></li>
</ul>
<p>则称<span class="math inline">\(\sigma\)</span>为<span class="math inline">\(R\)</span>到<span class="math inline">\(R&#39;\)</span>的同态</p>
</blockquote>
<ul>
<li>类似于群，我们定义满同态，单同态和同构，特别的，同构记为<span class="math inline">\(R \cong R&#39;\)</span></li>
</ul>
<h4 id="环同态基本定理">环同态基本定理</h4>
<blockquote>
<p>设<span class="math inline">\(\sigma\)</span>为<span class="math inline">\(R \to \bar{R}\)</span>的同态，则<span class="math inline">\(\ker(\sigma) := \{a \in R : \sigma(a) = \bar{0}\}\)</span>称为同态核，则</p>
<ul>
<li><span class="math inline">\(\ker(\sigma) \lhd R\)</span></li>
<li><span class="math inline">\(\text{Im}(\sigma) = \sigma(R) = \{\sigma(r):r\in R\} \leq \bar{R}\)</span></li>
<li><span class="math inline">\(R/\ker(\sigma) \cong \text{Im}(\sigma)\)</span></li>
</ul>
</blockquote>
<h4 id="环同态第一定理">环同态第一定理</h4>
<blockquote>
<p>设<span class="math inline">\(I \lhd R\)</span>，那么</p>
<ul>
<li><span class="math inline">\(R\)</span>中包含<span class="math inline">\(I\)</span>的子环和<span class="math inline">\(R/I\)</span>的子环之间存在一一对应关系<span class="math inline">\(S \to S/I\)</span></li>
<li>如果<span class="math inline">\(I\subseteq S\)</span>，<span class="math inline">\(S \leq R \Rightarrow S/I \leq R/I\)</span></li>
<li>如果<span class="math inline">\(I \subseteq S, S \leq R\)</span>，那么<span class="math inline">\(S \lhd R \Leftrightarrow S/I \lhd R/I\)</span></li>
<li>如果<span class="math inline">\(I\subseteq S\)</span>，<span class="math inline">\(S \lhd R\)</span>，那么<span class="math inline">\(R/S \cong (R/I)/(S/I)\)</span></li>
</ul>
</blockquote>
<h4 id="环同态第二定理">环同态第二定理</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(I \lhd R\)</span>且<span class="math inline">\(S \leq R\)</span>，那么<span class="math inline">\(I\cap S \lhd S\)</span>，并且<span class="math inline">\(S/(I \cap S) \cong (I+S)/I\)</span></p>
</blockquote>
<h4 id="环的外直和">环的外直和</h4>
<blockquote>
<p>设<span class="math inline">\(R_1, R_2,...,R_n\)</span>为环，令<span class="math inline">\(R = R_1 \oplus ... \oplus R_n\)</span></p>
<p>在其上定义加法：<span class="math inline">\((r_1,...,r_n)+(r_1&#39;,...r_n&#39;) = (r_1+r_1&#39;,...,r_n+r_n&#39;)\)</span></p>
<p>定义乘法<span class="math inline">\((r_1,...,r_n)*(r_1&#39;,...r_n&#39;)=(r_1r_1&#39;,...,r_nr_n&#39;)\)</span></p>
<p>那么<span class="math inline">\(R\)</span>按上述运算构成环，称为环<span class="math inline">\(R_1, ..., R_n\)</span>的（外）直和</p>
</blockquote>
<hr />
<h3 id="week-11">week 11</h3>
<h4 id="理想的交">理想的交</h4>
<blockquote>
<p>设<span class="math inline">\(I_1, I_2, ..., I_n\)</span>为理想，那么<span class="math inline">\(I = \bigcap_{j=1}^i I_j\)</span>也是理想</p>
</blockquote>
<h4 id="生成的理想">生成的理想</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(X \subseteq R\)</span>，那么称由<span class="math inline">\(X\)</span>生成的理想为<span class="math inline">\(\langle X \rangle = \bigcap_{X \subseteq I \lhd R} I\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(\langle X \rangle\)</span>是包含<span class="math inline">\(X\)</span>的最小的理想</li>
<li><span class="math inline">\(\langle X \rangle = \{\sum_{i=1}^n r_i x_is_i:x_i\in X, r_i, s_i \in R, n \in Z^+\}\)</span>（考虑包含<span class="math inline">\(X\)</span>的理想应该含有什么数字，以及这个集合确实构成理想）</li>
<li>当<span class="math inline">\(R\)</span>为交换幺环时，<span class="math inline">\(\langle X \rangle = \{\sum_{i=1}^n r_i x_i:x_i\in X, r_i\in R, n \in Z^+\}\)</span>，此时，如果<span class="math inline">\(X=\{x_1,...,x_k\}\)</span>，那么我们也记<span class="math inline">\(\langle X\rangle = (x_1,...,x_k)\)</span></li>
<li>当<span class="math inline">\(R\)</span>为交换幺环时，称<span class="math inline">\((a) = \{ra:r\in R\}\)</span>为<span class="math inline">\(a\)</span>生成的<strong>主理想</strong></li>
</ul>
<h4 id="理想的和">理想的和</h4>
<blockquote>
<p>设<span class="math inline">\(I_1,I_2,...,I_n\)</span>为理想，那么<span class="math inline">\(\sum_{i=1}^n I_i\)</span>也为理想，称为理想的和</p>
</blockquote>
<h4 id="理想的积">理想的积</h4>
<blockquote>
<p>设<span class="math inline">\(I_1,I_2,...,I_n\)</span>为理想，那么称<span class="math inline">\(I_1 \cdot I_2 ... \cdot I_n = \langle I_1I_2...I_n \rangle = \{\sum_{j=1}^m \prod_{k=1}^n i_k : i_k \in I_k, m \in Z^+\}\)</span>为理想的积</p>
</blockquote>
<p>一般用<span class="math inline">\(I_1I_2...I_n\)</span>直接来代指<span class="math inline">\(I_1 \cdot I_2 ... \cdot I_n\)</span></p>
<p>理想的积对理想的和有分配率</p>
<ul>
<li><span class="math inline">\(I_1 \cdot (I_2 + I_3) = I_1 \cdot I_2 + I_1 \cdot I_3\)</span></li>
<li><span class="math inline">\((I_2 + I_3) \cdot I_1= I_2 \cdot I_1 + I_3 \cdot I_1\)</span></li>
</ul>
<h4 id="环的外直和-1">环的外直和</h4>
<p>设<span class="math inline">\(R = R_1 \oplus R_2 ... \oplus R_n\)</span>，设<span class="math inline">\(R_i^* = \{(0,0,...0,r_i,0,...,0):r_i \in R_i\}\)</span></p>
<p>那么和群一致的有：</p>
<ul>
<li><span class="math inline">\(R_1^* \oplus ... \oplus R_n^* = R\)</span></li>
<li><span class="math inline">\(R_i^* \lhd R\)</span></li>
<li><span class="math inline">\(R_i^* \cap \sum_{j \neq i} R_j^* = (0) = O\)</span></li>
</ul>
<h4 id="环的内直和">环的内直和</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环，<span class="math inline">\(R_1,R_2,...,R_n\)</span>为理想，如果</p>
<ul>
<li><span class="math inline">\(R_1 \oplus ... \oplus R_n = R\)</span></li>
<li><span class="math inline">\(R_i \cap \sum_{j \neq i} R_j = O\)</span></li>
</ul>
<p>则称<span class="math inline">\(R\)</span>为<span class="math inline">\(R_1,R_2,...,R_n\)</span>的内直和</p>
</blockquote>
<p>第二个条件和群一样，可以等价为<span class="math inline">\(R\)</span>中的元素可以唯一的表为<span class="math inline">\(r_1+...+r_n\)</span>的形式</p>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为环<span class="math inline">\(R_1,...,R_n\)</span>的内直和，那么<span class="math inline">\(R \cong R_1 \oplus ... \oplus R_n\)</span></p>
</blockquote>
<h4 id="互素">互素</h4>
<blockquote>
<p>如果幺环<span class="math inline">\(R\)</span>的理想<span class="math inline">\(I,J\)</span>满足<span class="math inline">\(I+J=R\)</span>，则称<span class="math inline">\(I,J\)</span>互素</p>
</blockquote>
<ul>
<li>互素的充要条件为<span class="math inline">\(\exists i \in I, j \in J\)</span>使<span class="math inline">\(i+j=1\)</span></li>
</ul>
<h3 id="week12">week12</h3>
<h4 id="中国剩余定理">中国剩余定理</h4>
<blockquote>
<p>设幺环<span class="math inline">\(R\)</span>上的理想<span class="math inline">\(A_1, A_2, ..., A_n\)</span>两两互素，那么</p>
<p><span class="math display">\[R/\bigcap_{i=1}^n A_i \cong R/A_1 \oplus R/A_2 ... \oplus R/A_n\]</span></p>
<p>特别的，当<span class="math inline">\(R\)</span>为交换幺环时，<span class="math inline">\(\bigcap_{i=1}^n A_i = A_1A_2...A_n\)</span>，从而</p>
<p><span class="math display">\[R/ A_1A_2...A_n \cong R/A_1 \oplus R/A_2 ... \oplus R/A_n\]</span></p>
</blockquote>
<p>要证明这个定理，我们先证明一个引理</p>
<blockquote>
<p>设<span class="math inline">\(I, J, K\)</span>为幺环<span class="math inline">\(R\)</span>的理想，那么</p>
<ol type="i">
<li><p>当<span class="math inline">\(I\)</span>与<span class="math inline">\(J, K\)</span>都互素时，<span class="math inline">\(I\)</span>与<span class="math inline">\(JK\)</span>互素</p></li>
<li><p><span class="math inline">\(I, J\)</span>互素时，<span class="math inline">\(I \cap J = IJ+JI\)</span>，特别的，如果<span class="math inline">\(R\)</span>为交换幺环，那么<span class="math inline">\(I\cap J = IJ+JI=IJ\)</span></p></li>
</ol>
</blockquote>
<p>(i)的证明，由于<span class="math inline">\(I\)</span>与<span class="math inline">\(J, K\)</span>互素，因此存在<span class="math inline">\(i_1, i_2 \in I, j \in J, k \in K\)</span>，使得<span class="math inline">\(i_1 + j = 1, i_2+k = 1\)</span>，因此<span class="math inline">\(1 = (i_1+j)(i_2+k)=(i_1i_2+ji_2+i_1k)+jk \in I+JK\)</span>，从而<span class="math inline">\(I\)</span>与<span class="math inline">\(JK\)</span>互素</p>
<p>(ii)的证明类似，由于<span class="math inline">\(I, J\)</span>为理想，因此<span class="math inline">\(IJ \subseteq I, J\)</span>，类似<span class="math inline">\(JI \subseteq I \cap J\)</span>，从而<span class="math inline">\(IJ+JI \subseteq I \cap J\)</span></p>
<p>由于<span class="math inline">\(I, J\)</span>互素，取<span class="math inline">\(i+j=1\)</span>，那么<span class="math inline">\(\forall x \in I \cap J, x=1x=ix+jx\in IJ+JI\)</span>，<span class="math inline">\(\square\)</span></p>
<hr />
<p>下面我们正式开始证明中国剩余定理</p>
<p>构造<span class="math inline">\(R\)</span>到<span class="math inline">\(R/A_1 \oplus R/A_2 \oplus ... \oplus R/A_n\)</span>的映射<span class="math inline">\(\sigma\)</span>：<span class="math inline">\(\sigma(x) = (x+A_1, x+A_2, ..., x+A_n)\)</span></p>
<p>不难证明这是一个同态，考虑同态核：将有<span class="math inline">\(x+A_1 = A_1, ..., x+A_n=A_n\)</span>，也即<span class="math inline">\(x\in \bigcap_{i=1}^n A_i\)</span></p>
<p>再考虑同态像，我们依赖于下面的定理，事实上，下面的定理和数论形式的中国剩余定理更为接近</p>
<blockquote>
<p>任给<span class="math inline">\(a_1, a_2, ..., a_n \in R\)</span>，那么方程组</p>
<p><span class="math display">\[\begin{cases} x \equiv a_1(mod\;A_1) \\ x \equiv a_2(mod\;A_2) \\ ... \\x \equiv a_n(mod\;A_n)\end{cases}\]</span>在<span class="math inline">\(R\)</span>中有解，并且在模<span class="math inline">\(\bigcap_{i=1}^n A_i\)</span>的意义下唯一确定</p>
</blockquote>
<p>令<span class="math inline">\(B_i = \prod_{j \neq i} A_j\)</span>，根据引理(i)，<span class="math inline">\(B_i\)</span>与<span class="math inline">\(A_i\)</span>互素，因此存在<span class="math inline">\(a_i&#39; \in A_i, b_i \in B_i\)</span>使得<span class="math inline">\(a_i&#39; + b_i = 1\)</span></p>
<p>此时，对<span class="math inline">\(j \neq i\)</span>，根据<span class="math inline">\(A_j\)</span>是一个理想，将有<span class="math inline">\(b_i \in A_j\)</span>，即<span class="math inline">\(b_i \equiv 0(mod\;A_j)\)</span>，而<span class="math inline">\(b_i \equiv 1(mod\;A_i)\)</span></p>
<p>那么，令<span class="math inline">\(x_0 = \sum_{i=1}^n a_ib_i\)</span>，这就是原方程组的一个解</p>
<p>不妨设方程还有另一个<span class="math inline">\(x\)</span>，那么由<span class="math inline">\((x-x_0) \in A_1, ..., (x-x_0)\in A_n\)</span>，得到<span class="math inline">\(x-x_0 \in \bigcap_{i=1}^n A_i\)</span>，也即<span class="math inline">\(x \equiv x_0(mod\;\bigcap_{i=1}^n A_i)\)</span></p>
<p>根据上面的定理，我们可以知道<span class="math inline">\(\sigma\)</span>实际上是一个满同态，因此由环的同态基本定理</p>
<p><span class="math display">\[R/\bigcap_{i=1}^n A_i \cong R/A_1 \oplus R/A_2 ... \oplus R/A_n\]</span></p>
<p>当<span class="math inline">\(R\)</span>是交换幺环时，运用引理(ii)即可归纳证明其形式</p>
<h4 id="单位群">单位群</h4>
<blockquote>
<p>对幺环<span class="math inline">\(R\)</span>，称<span class="math inline">\(u\)</span>为单位，当且仅当<span class="math inline">\(u\)</span>为乘法可逆元，也即存在<span class="math inline">\(u&#39; \in R\)</span>使得<span class="math inline">\(uu&#39; = 1\)</span></p>
</blockquote>
<p>注意到，如果<span class="math inline">\(u, v\)</span>为单位，那么<span class="math inline">\(u^{-1}, uv\)</span>也为单位，这告诉我们<span class="math inline">\(U(R) = \{u:u\in R, u\text{是单位}\}\)</span>按乘法构成一个群</p>
<ul>
<li><span class="math inline">\(U(Z) = \{\pm 1\}\)</span></li>
<li>称<span class="math inline">\(Z[i] = \{a+bi:a, b \in Z\}\)</span>为Gauss复整数环，则<span class="math inline">\(U(Z[i]) = \{\pm1, \pm i\}\)</span></li>
<li>称<span class="math inline">\(Z[w] = \{a+bw : a, b\in Z\}\)</span>为Eisenstein环，其中<span class="math inline">\(w\)</span>为非<span class="math inline">\(1\)</span>的三次单位根，并且<span class="math inline">\(U(Z[w]) = \{\pm 1, \pm w, \pm w^2 \}\)</span></li>
<li>设<span class="math inline">\(R_1, R_2, ..., R_n\)</span>为幺环，那么<span class="math inline">\(U(R_1 \oplus R_2 \oplus ...\oplus R_n) = U(R_1) \times U(R_2) ... \times U(R_n)\)</span></li>
</ul>
<h4 id="素理想">素理想</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，<span class="math inline">\(I \neq R\)</span>为<span class="math inline">\(R\)</span>的理想，如果<span class="math inline">\(\forall a, b \in R, ab \in I\)</span>可以推出<span class="math inline">\(a \in I\)</span>或者<span class="math inline">\(b \in I\)</span>，那么称<span class="math inline">\(I\)</span>为<span class="math inline">\(R\)</span>的素理想</p>
</blockquote>
<h4 id="极大理想">极大理想</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，<span class="math inline">\(I \neq R\)</span>为<span class="math inline">\(R\)</span>的理想，如果<span class="math inline">\(J \lhd R, I \subseteq J \subseteq R\)</span>可以推出<span class="math inline">\(J = I\)</span>或者<span class="math inline">\(J=R\)</span>，那么称<span class="math inline">\(I\)</span>为<span class="math inline">\(R\)</span>的极大理想</p>
</blockquote>
<ul>
<li><p><span class="math inline">\((0)\)</span>是<span class="math inline">\(Z\)</span>的素理想，但不是极大理想</p>
<p>对于素数<span class="math inline">\(p\)</span>，<span class="math inline">\((p)\)</span>是<span class="math inline">\(Z\)</span>的素理想，也是极大理想</p>
<p>其余的<span class="math inline">\((n)\)</span>既不是<span class="math inline">\(Z\)</span>的素理想，也不是极大理想</p></li>
</ul>
<h4 id="域">域</h4>
<blockquote>
<p>若<span class="math inline">\(F\)</span>为环，<span class="math inline">\(F/\{0\}\)</span>构成Abel群，那么，称<span class="math inline">\(F\)</span>构成域</p>
</blockquote>
<ul>
<li><p>域一定是整环</p>
<p><span class="math inline">\(a \neq 0\)</span>时，<span class="math inline">\(ab=0\Rightarrow a^{-1}ab = 0 \Rightarrow b=0\)</span></p></li>
</ul>
<h4 id="素理想与整环极大理想与域">素理想与整环，极大理想与域</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，则</p>
<ol type="i">
<li><p><span class="math inline">\(R\)</span>为整环，当且仅当<span class="math inline">\(O\)</span>为<span class="math inline">\(R\)</span>的素理想</p></li>
<li><p><span class="math inline">\(R\)</span>为域，当且仅当<span class="math inline">\(O\)</span>为<span class="math inline">\(R\)</span>的极大理想</p></li>
</ol>
</blockquote>
<p>(i)是平凡的，考虑(ii)，<span class="math inline">\(R\)</span>为域等价于对任意<span class="math inline">\(a \neq 0\)</span>存在逆元，</p>
<p>如果存在<span class="math inline">\(I \lhd R\)</span>，使得<span class="math inline">\(O \subseteq I \subseteq R\)</span>，当<span class="math inline">\(I \neq O\)</span>，任取<span class="math inline">\(i \in I - O\)</span>，那么<span class="math inline">\(1 \in i^{-1}I=I\)</span>，从而<span class="math inline">\(I=R\)</span></p>
<p>反之，考虑<span class="math inline">\(O \subseteq \langle a\rangle \subseteq R\)</span>，当<span class="math inline">\(a \neq 0\)</span>时，有<span class="math inline">\(\langle a \rangle =R\)</span>，于是<span class="math inline">\(a\)</span>存在逆元</p>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，<span class="math inline">\(P \neq R\)</span>为<span class="math inline">\(R\)</span>的理想，则</p>
<ol type="i">
<li><p><span class="math inline">\(P\)</span>为素理想当且仅当<span class="math inline">\(R/P\)</span>为整环</p></li>
<li><p><span class="math inline">\(P\)</span>为极大理想当且仅当<span class="math inline">\(R/P\)</span>为域</p></li>
</ol>
</blockquote>
<p>运用上面的引理和定义证明即可</p>
<ul>
<li>极大理想一定是素理想</li>
</ul>
<blockquote>
<p>设<span class="math inline">\(\sigma\)</span>是环<span class="math inline">\(R\)</span>到<span class="math inline">\(R&#39;\)</span>的同态，那么</p>
<ul>
<li>对<span class="math inline">\(\ker \sigma \subseteq M\)</span>，<span class="math inline">\(M\)</span>为素理想当且仅当<span class="math inline">\(\sigma(M)\)</span>为素理想</li>
<li>对<span class="math inline">\(\ker \sigma \subseteq M\)</span>，<span class="math inline">\(M\)</span>为极大理想当且仅当<span class="math inline">\(\sigma(M)\)</span>为极大理想</li>
</ul>
</blockquote>
<p>上述定理实际上可以表明，包括核的素/极大理想和像的素/极大理想存在一一对应</p>
<p>证明：<span class="math inline">\(M\)</span>为<span class="math inline">\(R\)</span>的素理想，当且仅当<span class="math inline">\(R/M\)</span>为整环，当且仅当<span class="math inline">\(\sigma(R)/\sigma(M)\)</span>为整环（第一同构定理），当且仅当<span class="math inline">\(\sigma(M)\)</span>为素理想，极大理想类似</p>
<h4 id="素理想的存在性">素理想的存在性</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，<span class="math inline">\(I \lhd R\)</span>且存在<span class="math inline">\(a \in R\)</span>，使得<span class="math inline">\(I \cap \{a^n:n\in Z\} = \emptyset\)</span>，那么必然存在包含<span class="math inline">\(I\)</span>的素理想<span class="math inline">\(P\)</span>，使得<span class="math inline">\(P \cap \{a^n:n\in Z\} = \emptyset\)</span></p>
</blockquote>
<p>证明较为复杂，略过</p>
<ul>
<li>设<span class="math inline">\(R\)</span>为交换幺环，<span class="math inline">\(I \neq R\)</span>为<span class="math inline">\(R\)</span>的理想，那么存在包含<span class="math inline">\(I\)</span>的极大理想</li>
</ul>
<p>注意到<span class="math inline">\(I \cap \{1\} = \emptyset\)</span>，说明极大的满足<span class="math inline">\(P \cap \{1\} = \emptyset\)</span>的理想为极大理想即可</p>
<h4 id="诣零根">诣零根</h4>
<blockquote>
<p>设环<span class="math inline">\(R\)</span>为非零元，则称<span class="math inline">\(r(R)=\bigcap_{P\text{为$R$的素理想}} P\)</span>为<span class="math inline">\(R\)</span>的诣零根</p>
</blockquote>
<p>这个结构的名字可能比较奇怪，需要从另一个角度来理解</p>
<blockquote>
<p><span class="math inline">\(r(R)\)</span>恰为<span class="math inline">\(A\)</span>中所有的幂零元构成</p>
</blockquote>
<p>如果<span class="math inline">\(a^n = 0\in P\)</span>，那么由素理想的性质，不难推出<span class="math inline">\(a \in P\)</span></p>
<p>如果<span class="math inline">\(a^n \neq 0\)</span>，那么<span class="math inline">\(\{a^n\} \cap O = \emptyset\)</span>，根据上一个定理，存在<span class="math inline">\(P\)</span>，使得<span class="math inline">\(a \notin P\)</span></p>
<ul>
<li><span class="math inline">\(r(Z)=O\)</span></li>
</ul>
<h3 id="week13">week13</h3>
<h4 id="形式幂级数环">形式幂级数环</h4>
<blockquote>
<p>令<span class="math inline">\(R[[X]] = \{(a_n)_{n \geq 0}, a_n \in R\}\)</span>，其中<span class="math inline">\((a_n) = (a_0,a_1,...)\)</span>为无穷序列，在其上定义加，乘法：</p>
<ul>
<li><span class="math inline">\((a_n) + (b_n) = (a_n+b_n)\)</span></li>
<li><span class="math inline">\((a_n) * (b_n) = (\sum_{i+j=n} a_ib_j)\)</span></li>
</ul>
<p>那么<span class="math inline">\(R[[x]]\)</span>按上述加法和乘法构成环，称为<strong>形式幂级数环</strong></p>
</blockquote>
<p>这个定义和形式幂级数看起来没什么关系，实则不然</p>
<ul>
<li>我们考虑将<span class="math inline">\((0,1,0,...)\)</span>看作<span class="math inline">\(x\)</span>，那么<span class="math inline">\(x^n = (0,0,...,0,1,0,0,...)\)</span>，其中第<span class="math inline">\(n\)</span>位为<span class="math inline">\(1\)</span>，那么<span class="math inline">\((a_n) = a_0 + a_1x + a_2x^2 + ...\)</span>，这样就与平时认知的幂级数有了联系</li>
<li><span class="math inline">\(R\)</span>可以“看作”是<span class="math inline">\(R[[x]]\)</span>的一个子环（考虑无穷序列到常数项的映射）</li>
<li><span class="math inline">\(x\)</span>在<span class="math inline">\(R[[x]]\)</span>上生成的子环为<span class="math inline">\(R[x]\)</span>（<span class="math inline">\(R\)</span>上的一元多项式环）</li>
</ul>
<h4 id="多元多项式环">多元多项式环</h4>
<blockquote>
<p>定义二元多项式环<span class="math inline">\(R[x,y] = R[x][y]\)</span>，即系数在<span class="math inline">\(R[x]\)</span>中的<span class="math inline">\(y\)</span>的一元多项式环，多元可以类推</p>
</blockquote>
<ul>
<li>对于多元多项式：<span class="math inline">\(\sum_{i=0}^n a_{i_1, ...,i_n} x_1^{i_1}x_2^{i_2}...x_n^{i_n}\)</span>，定义次数为<span class="math inline">\(\max\{i_1+i_2+...+i_n:a_{i_1,i_2,...,i_n} \neq 0\}\)</span></li>
<li>零多项式的次数为<span class="math inline">\(-\infty\)</span></li>
<li><span class="math inline">\(\deg(f+g) \leq \deg(f) + \deg(g)\)</span></li>
<li><span class="math inline">\(\deg(fg) \leq \deg(f) + \deg(g)\)</span>，在<span class="math inline">\(f, g\)</span>的首项不是零因子时，这里应该取等，小于号是因为零因子的存在性</li>
</ul>
<h4 id="多项式环的单位群">多项式环的单位群</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为整环，则<span class="math inline">\(R[x_1,...,x_n]\)</span>也为整环，并且<span class="math inline">\(U(R[x_1,...,x_n])=U(R)\)</span></p>
</blockquote>
<ul>
<li><p>我们之前已经提到过，如果<span class="math inline">\(R\)</span>为整环，那么<span class="math inline">\(R[x]\)</span>为整环，归纳即可证明<span class="math inline">\(R[x_1,...,x_n]\)</span>为整环</p></li>
<li><p>对于第二点，在整环中<span class="math inline">\(f(x)g(x) = 1\)</span>，只有<span class="math inline">\(\deg f(x) = 0, \deg g(x) = 0\)</span></p></li>
</ul>
<h4 id="带余除法">带余除法</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，<span class="math inline">\(f(x), g(x) \in R[x]\)</span>，<span class="math inline">\(g(x) \neq 0\)</span>且<span class="math inline">\(g(x)\)</span>的首项为单位，那么有唯一的<span class="math inline">\(q(x), r(x) \in R[x]\)</span>，使得<span class="math inline">\(f(x) = q(x)g(x)+r(x)\)</span>，且<span class="math inline">\(\deg r(x) &lt; \deg g(x)\)</span></p>
</blockquote>
<ul>
<li>取<span class="math inline">\(r(x)\)</span>使得其在<span class="math inline">\(S=\{f(x)-g(x)h(x):h(x)\in R\}\)</span>次数最低，对应的<span class="math inline">\(h(x)\)</span>记为<span class="math inline">\(q(x)\)</span>，从而有<span class="math inline">\(f(x)=q(x)g(x)+r(x)\)</span></li>
<li>利用<span class="math inline">\(g(x)\)</span>的首项为单位，可以证明有<span class="math inline">\(\deg r(x) &lt; \deg g(x)\)</span></li>
<li>唯一性：设<span class="math inline">\(f(x)=q(x)g(x)+r(x)=q&#39;(x)g(x)+r&#39;(x)\)</span>，从而<span class="math inline">\(g(x)(q(x)-q&#39;(x))=r&#39;(x)-r(x)\)</span>，右边小于<span class="math inline">\(\deg g(x)\)</span>，如果<span class="math inline">\(q(x)\neq q&#39;(x)\)</span>，左边的度数将<span class="math inline">\(\geq \deg g(x)\)</span>，从而矛盾（注意到在<span class="math inline">\(R\neq O\)</span>中，单位一定不是零因子，单位有<span class="math inline">\(aa^{-1} = 1\)</span>，如果有零因子<span class="math inline">\(b\)</span>，那么<span class="math inline">\(b=1*b=a^{-1}ab=a^{-1}0=0\)</span>，矛盾）</li>
</ul>
<p>带余除法有一个经常用的推论：因式定理</p>
<blockquote>
<p>设<span class="math inline">\(c \in R\)</span>，<span class="math inline">\(f(x)\in R[x]\)</span>，则<span class="math inline">\((x-c)\mid f(x)\)</span>的充要条件是<span class="math inline">\(c\)</span>为<span class="math inline">\(f(x)\)</span>的一个根</p>
</blockquote>
<h4 id="整环中根的数量">整环中根的数量</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为一个整环，<span class="math inline">\(f(x) \in R[x]\)</span>，<span class="math inline">\(\deg f(x) = n \geq 0\)</span>，则<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(R\)</span>中至多有<span class="math inline">\(n\)</span>个根</p>
</blockquote>
<ul>
<li>归纳证明</li>
</ul>
<h4 id="整环的单位群">整环的单位群</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为整环，则<span class="math inline">\(U(R)\)</span>的有限子群为循环群</p>
</blockquote>
<ul>
<li>设<span class="math inline">\(m=exp(G)\)</span>，由<span class="math inline">\(x^m = 1\)</span>有<span class="math inline">\(|G|\)</span>个解知道<span class="math inline">\(|G| \leq m\)</span>，又由幂指数的性质<span class="math inline">\(m \leq |G|\)</span>，从而<span class="math inline">\(m=|G|\)</span>，在有限Abel群中，存在元素<span class="math inline">\(a\)</span>，使得<span class="math inline">\(o(a)=m=|G|\)</span></li>
</ul>
<p>将其运用到域上，得到</p>
<ul>
<li>有限域中<span class="math inline">\(F^* = F-\{0\}\)</span>是有限循环群</li>
</ul>
<h4 id="euclid整环">Euclid整环</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为整环，如果存在<span class="math inline">\(L:R-\{0\} \to N\)</span>，使得<span class="math inline">\(a, b \in R\)</span>且<span class="math inline">\(b \neq 0\)</span>时，存在<span class="math inline">\(q, r \in R\)</span>适合<span class="math inline">\(a=bq+r\)</span>并且<span class="math inline">\(r=0\)</span>或<span class="math inline">\(L(r)&lt;L(b)\)</span></p>
<p>则称<span class="math inline">\(R\)</span>为Euclid整环，<span class="math inline">\(L\)</span>称为Euclid数</p>
</blockquote>
<ul>
<li><p>根据前面的讨论，我们知道：如果<span class="math inline">\(F\)</span>为域，则<span class="math inline">\(F[x]\)</span>为Euclid整环</p></li>
<li><p><span class="math inline">\(Z[i] = \{a+bi:a, b \in Z\}\)</span>，<span class="math inline">\(Z[w] = \{a+bw:a, b \in Z\}\)</span>按照<span class="math inline">\(L(\xi) = \xi \bar{\xi} = |\xi|^2\)</span>构成Euclid整环</p>
<ul>
<li><p>任给<span class="math inline">\(a \in R, b \neq 0 \in R\)</span>（<span class="math inline">\(R=Z[i]\)</span>或<span class="math inline">\(Z[w]\)</span>），要寻找满足条件的<span class="math inline">\(a=bq+r\)</span>，等价于寻找<span class="math inline">\(q\)</span>，使得<span class="math inline">\(|\frac{a}{b}-q|&lt;1\)</span></p>
<p>根据下面的事实：如果<span class="math inline">\(x \in R\)</span>，那么<span class="math inline">\(\bar{x} \in R\)</span>，且<span class="math inline">\(L(x) \in N\)</span></p>
<p>那么<span class="math inline">\(\frac{a}{b}\)</span>形如<span class="math inline">\(c+di\)</span>（或者<span class="math inline">\(c+dw\)</span>），其中<span class="math inline">\(c, d \in Q\)</span></p>
<p>取<span class="math inline">\(m + ni\)</span>为最接近<span class="math inline">\(c+di\)</span>的<span class="math inline">\(R\)</span>中数，简单放缩可以证明该数满足<span class="math inline">\(|\frac{a}{b}-q|&lt;1\)</span></p></li>
</ul></li>
</ul>
<p>下面是关于上述环的一个更一般性的定理</p>
<blockquote>
<p>设<span class="math inline">\(d\)</span>为无平方因子数（<span class="math inline">\(d \neq 0, d \neq 1\)</span>），定义</p>
<p><span class="math inline">\(R_d = \begin{cases} Z[\sqrt{d}]:Z+Z\sqrt {d}, &amp; d \not \equiv 1(mod\;4) \\ Z+Z\frac{-1+\sqrt{d}}{2}, &amp;d \equiv 1(mod\;4)\end{cases}\)</span></p>
<p>那么，<span class="math inline">\(d&lt;0\)</span>时，按<span class="math inline">\(L(\xi) = |xi|^2\)</span>，当且仅当<span class="math inline">\(d=-1,-2,-3,-7,-11\)</span>时，<span class="math inline">\(R_d\)</span>为整环</p>
<p><span class="math inline">\(d&gt;0\)</span>时，按<span class="math inline">\(L(a+bd) = |a^2-db^2|\)</span>，当且仅当<span class="math inline">\(d=2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73\)</span>时，<span class="math inline">\(R_d\)</span>为整环</p>
</blockquote>
<h4 id="主理想整环">主理想整环</h4>
<blockquote>
<p>如果整环<span class="math inline">\(R\)</span>中的理想都是主理想，则称<span class="math inline">\(R\)</span>为主理想整环（PID）</p>
</blockquote>
<ul>
<li><p>Euclid整环一定是主理想整环</p>
<p>不妨设<span class="math inline">\(I\)</span>为Euclid整环中的非零理想，那么在<span class="math inline">\(I/\{0\}\)</span>中存在一个<span class="math inline">\(N(\cdot)\)</span>最小的元素<span class="math inline">\(a\)</span></p>
<p>现在对任意的元素<span class="math inline">\(b\)</span>，根据Euclid整环的定义，存在<span class="math inline">\(I\)</span>中的元素<span class="math inline">\(c, d\)</span>，使得<span class="math inline">\(a=bc+d\)</span>，并且<span class="math inline">\(d=0\)</span>或<span class="math inline">\(N(d)&lt;N(a)\)</span></p>
<p>由于<span class="math inline">\(a\)</span>是<span class="math inline">\(N(\cdot)\)</span>最小的元素，因此只有<span class="math inline">\(d=0\)</span>，从而<span class="math inline">\(a=bc\)</span>，这也就是说<span class="math inline">\(I=(a)\)</span></p></li>
<li><p>在整环中，一般有下面的定理成立：</p>
<ul>
<li><span class="math inline">\(b \mid a \Leftrightarrow (a) \subseteq (b)\)</span></li>
<li><span class="math inline">\(u\)</span>为单位<span class="math inline">\(\Leftrightarrow (u) = R\)</span></li>
<li><span class="math inline">\(a \sim b\)</span>（<span class="math inline">\(a\)</span>与<span class="math inline">\(b\)</span>相伴，<span class="math inline">\(a \mid b, b \mid a\)</span>）<span class="math inline">\(\Leftrightarrow (a)=(b) \Leftrightarrow a, b\)</span>之间相差一个单位</li>
</ul></li>
</ul>
<h4 id="不可约元素元">不可约元，素元</h4>
<blockquote>
<p>设<span class="math inline">\(p\)</span>位整环<span class="math inline">\(R\)</span>中非零元，非单位元，如果<span class="math inline">\(a \mid p \Rightarrow a \sim p\)</span>或<span class="math inline">\(a\)</span>为单位，则称<span class="math inline">\(p\)</span>为不可约元</p>
</blockquote>
<ul>
<li><span class="math inline">\(p\)</span>可约即存在两个非单位元<span class="math inline">\(a, b\)</span>，使得<span class="math inline">\(p=ab\)</span></li>
<li><span class="math inline">\((p)\)</span>是极大理想，可以推出<span class="math inline">\(p\)</span>是不可约元，在PID中，反之也是成立的</li>
</ul>
<blockquote>
<p>如果<span class="math inline">\(p \mid ab \Rightarrow p \mid a\)</span>或<span class="math inline">\(p \mid b\)</span>，则称<span class="math inline">\(p\)</span>为素元</p>
</blockquote>
<ul>
<li><span class="math inline">\(p\)</span>为素元，当且仅当<span class="math inline">\((p)\)</span>为素理想</li>
</ul>
<h4 id="不可约元与素元">不可约元与素元</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为整环，那么</p>
<ul>
<li><span class="math inline">\(R\)</span>中素元必为不可约元</li>
<li><span class="math inline">\(R\)</span>为PID时，不可约元为素元</li>
</ul>
</blockquote>
<p>对于第一条，进行反证，设<span class="math inline">\(p=ab\)</span>，由于<span class="math inline">\(p \mid ab\)</span>及<span class="math inline">\(p\)</span>为素元，不妨设<span class="math inline">\(p \mid a\)</span></p>
<p>又由于<span class="math inline">\(a \mid p\)</span>，因此<span class="math inline">\(a \sim p\)</span>，从而<span class="math inline">\(b\)</span>为单位，矛盾</p>
<p>对于第二条，证明素理想为极大理想</p>
<ul>
<li>在PID中，非零理想<span class="math inline">\(I\)</span>为素理想，当且仅当其为极大理想</li>
</ul>
<h4 id="唯一分解定理">唯一分解定理</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为PID，<span class="math inline">\(P\)</span>为<span class="math inline">\(R\)</span>中素元（按照相伴构成的等价类）的代表元，那么<span class="math inline">\(\forall x \in R\)</span>，其可以唯一地表为<span class="math inline">\(u \prod_{p_i \in P} p_i^{a_i}\)</span>的形式，其中<span class="math inline">\(u\)</span>为单位，<span class="math inline">\(a_i \in N\)</span>并且只有有限个非零的<span class="math inline">\(a_i\)</span></p>
</blockquote>
<h3 id="week14">week14</h3>
<h4 id="noether环">Noether环</h4>
<blockquote>
<p>称交换幺环<span class="math inline">\(R\)</span>为Noether环，当且仅当其每个理想都是有限生成的</p>
</blockquote>
<p>关于Noether环，有下面几条非常重要的等价条件</p>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为交换幺环，那么下面三者等价</p>
<ol type="a">
<li><p><span class="math inline">\(R\)</span>为Noether环</p></li>
<li><p>（理想升链条件）：称<span class="math inline">\(I_1 \subseteq I_2 ...\)</span>为<span class="math inline">\(R\)</span>的理想升链，那么存在<span class="math inline">\(N\)</span>，当<span class="math inline">\(n&gt;N\)</span>时，有<span class="math inline">\(I_{n}=I_{n+1}\)</span></p></li>
<li><p><span class="math inline">\(R\)</span>种的每个非空理想集按照包含关系具有极大元</p></li>
</ol>
</blockquote>
<p><span class="math inline">\((a) \Rightarrow (b)\)</span>：假如有理想升链<span class="math inline">\(I_1 \subseteq I_2...\)</span>，设<span class="math inline">\(I= \bigcup_{i=1}^{\infty} I_i\)</span>，不难证明，<span class="math inline">\(I\)</span>为理想。根据Noether环的定义，<span class="math inline">\(I\)</span>为有限生成，不妨设<span class="math inline">\(I=(a_1,...,a_k)\)</span>，对于每一个<span class="math inline">\(a_i\)</span>，存在<span class="math inline">\(n_i\)</span>使得<span class="math inline">\(a_i \in I_{n_i}\)</span>，那么，取<span class="math inline">\(N=\max(n_1,...,n_k)\)</span>，将有<span class="math inline">\(I_N\)</span>之后都相等的性质</p>
<p><span class="math inline">\((b) \Rightarrow (c)\)</span>：假设有一个集合没有极大元，我们可以构造出互不相同的理想升链，这与(b)矛盾</p>
<p><span class="math inline">\((c) \Rightarrow (a)\)</span>：假设<span class="math inline">\(I\)</span>不是有限生成，那么我们总可以构造<span class="math inline">\(I_k = I_{k-1}+(a_k)\)</span>，其中<span class="math inline">\(a_k \in R-I_{k-1}\)</span>，但其中没有极大元，与(c)矛盾</p>
<h4 id="hilbert基定理">Hilbert基定理</h4>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为Noether环，那么<span class="math inline">\(R[x]\)</span>为Noether环</p>
</blockquote>
<p>对于<span class="math inline">\(R[x]\)</span>种的理想<span class="math inline">\(I\)</span>，对<span class="math inline">\(n \in N\)</span>，定义<span class="math inline">\(I_n = \{[x^n]P(x):P(x)\in I \wedge \deg P \leq n\}\)</span>（即所有小于等于<span class="math inline">\(n\)</span>的多项式的<span class="math inline">\(n\)</span>次项系数）</p>
<p>可以证明，<span class="math inline">\(I_n \lhd R\)</span>，由于<span class="math inline">\(I\)</span>为理想，因此<span class="math inline">\(P(x) \in I \Rightarrow xP(x) \in I\)</span>，这说明<span class="math inline">\(I_n \subseteq I_{n+1}\)</span>，根据理想升链条件，存在<span class="math inline">\(N\)</span>，使得<span class="math inline">\(n&gt;N\)</span>时，<span class="math inline">\(I_n = I_{n+1}\)</span></p>
<p>此时，由于<span class="math inline">\(R\)</span>中的理想有限生成，不妨设<span class="math inline">\(I_n = (a_{n,1}, a_{n,2},...,a_{n,l(n)})\)</span></p>
<p>对<span class="math inline">\(0 \leq i \leq N, 1 \leq j \leq l(n)\)</span>，我们定义<span class="math inline">\(P_{ij}\)</span>为首项元素为<span class="math inline">\(a_{ij}\)</span>的多项式，定义<span class="math inline">\(J\)</span>为这些<span class="math inline">\(P_{ij}\)</span>生成的理想</p>
<p>不妨设<span class="math inline">\(P(x)\)</span>的次数为<span class="math inline">\(q\)</span>，设<span class="math inline">\(q&#39; = \min(N,q)\)</span>，那么<span class="math inline">\(P(x)\)</span>的首项可以由<span class="math inline">\((a_{q&#39;, 1}, ..., a_{q&#39;, l(q&#39;)})\)</span>生成，注意到<span class="math inline">\(P(x)=Q(x) + \sum_{i=1}^{l(q&#39;)} r_i P_{q&#39;, i} x^{q-q&#39;}\)</span>，其中<span class="math inline">\(r_i\)</span>是生成<span class="math inline">\(P(x)\)</span>首项的系数，那么<span class="math inline">\(\deg Q(x) &lt; \deg P(x)\)</span>，运用归纳法就可以证明</p>
<ul>
<li><span class="math inline">\(Z[x_1,...,x_n]\)</span>为Noether环</li>
<li>设<span class="math inline">\(F\)</span>为域，那么<span class="math inline">\(F[x_1,...,x_n]\)</span>为Noether环</li>
</ul>
<blockquote>
<p>设<span class="math inline">\(R\)</span>为Noether环，则<span class="math inline">\(R\)</span>种的每个理想都包含若干素理想的乘积</p>
</blockquote>
<p>这条定理就不证明了</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>abstract algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数3</title>
    <url>/2022/01/abstract-algebra-3/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="域">域</h2>
<h3 id="week14">week14</h3>
<h4 id="特征">特征</h4>
<blockquote>
<p>记<span class="math inline">\(1\)</span>为域<span class="math inline">\(F\)</span>中的乘法单位元，考虑其在<span class="math inline">\(F\)</span>作为加法群的阶<span class="math inline">\(n\)</span></p>
<p>如果<span class="math inline">\(n\)</span>有限，那么记<span class="math inline">\(ch(F) = n\)</span>，称为域<span class="math inline">\(F\)</span>的特征</p>
<p>如果<span class="math inline">\(n = \infty\)</span>，那么记<span class="math inline">\(ch(F)=0\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(ch(Q)=ch(C)=0\)</span></li>
<li>对于素数<span class="math inline">\(p\)</span>，有<span class="math inline">\(ch(Z/pZ)=p\)</span></li>
</ul>
<p>对于域中的非零元<span class="math inline">\(a\)</span>，当且仅当<span class="math inline">\(n1 = 0\)</span>时，有<span class="math inline">\(na = 0\)</span>（这里都是数乘，不是乘法），因此<span class="math inline">\(a\)</span>和<span class="math inline">\(1\)</span>在加法群中的阶数相同</p>
<p>根据上面这一条中，再注意到<span class="math inline">\(1 \neq 0\)</span>，因此<span class="math inline">\(ch(F)&gt;1\)</span>，我们可以知道</p>
<ul>
<li>当<span class="math inline">\(ch(F) \neq 0\)</span>时，<span class="math inline">\(ch(F)\)</span>将是一个素数</li>
</ul>
<h4 id="子域">子域</h4>
<blockquote>
<p>如果<span class="math inline">\(E \subseteq F\)</span>按<span class="math inline">\(F\)</span>中的<span class="math inline">\(+\)</span>，<span class="math inline">\(*\)</span>构成域，那么，</p>
<p>称<span class="math inline">\(E\)</span>为<span class="math inline">\(F\)</span>的<strong>子域</strong>，<span class="math inline">\(F\)</span>为<span class="math inline">\(E\)</span>的<strong>扩域</strong>，用<span class="math inline">\(F/E\)</span>表示这样的域扩张</p>
</blockquote>
<p>根据群的性质，我们不难知道<span class="math inline">\(ch(E)=ch(F)\)</span></p>
<h4 id="最小子域">最小子域</h4>
<blockquote>
<p>设<span class="math inline">\(F\)</span>为域，<span class="math inline">\(ch(F)\)</span>为素数</p>
<p>则<span class="math inline">\(E=\{me:m\in Z\} = \{0,e,2e,...,(p-1)e\}\)</span>为最小子域，且<span class="math inline">\(E \cong Z/pZ\)</span></p>
</blockquote>
<ul>
<li>提醒：域<span class="math inline">\(F\)</span>的乘法群<span class="math inline">\(F/\{0\}\)</span>的有限子群为循环群</li>
</ul>
<h4 id="域中的恒等式">域中的恒等式</h4>
<p>如果域<span class="math inline">\(F\)</span>中恰好有<span class="math inline">\(q\)</span>个元，则称<span class="math inline">\(F\)</span>为<span class="math inline">\(q\)</span>元域</p>
<blockquote>
<p>设<span class="math inline">\(F\)</span>为<span class="math inline">\(q\)</span>元域，那么</p>
<p><span class="math display">\[\prod_{a \in F^* = F/\{0\}} (x-a) = x^{q-1}-1\]</span></p>
</blockquote>
<p>两边作差后为至多<span class="math inline">\(q-2\)</span>次多项式，但是有<span class="math inline">\(q-1\)</span>个根（域中的非零元），因此作差后应该为0</p>
<blockquote>
<p>设<span class="math inline">\(ch(F)=p\)</span>，那么对<span class="math inline">\(a_1,...,a_n \in F, m \in N\)</span>，有</p>
<p><span class="math display">\[(a_1+...+a_n)^{p^m} = a_1^{p^m} + ... + a_n^{p^m}\]</span></p>
</blockquote>
<p>先证明<span class="math inline">\((a+b)^p = a^p+b^p\)</span>，这一点利用二项式定理以及<span class="math inline">\(px=0, \forall x \in F\)</span>，然后对<span class="math inline">\(n,m\)</span>依次归纳</p>
<h4 id="线性空间">线性空间</h4>
<blockquote>
<p>称<span class="math inline">\(V\)</span>为域<span class="math inline">\(F\)</span>上的线性空间，如果</p>
<ol type="1">
<li><p><span class="math inline">\(V\)</span>按照加法构成Abel群</p></li>
<li><p>有数乘运算，即<span class="math inline">\(\forall a \in F, x \in V\)</span>，定义<span class="math inline">\(ax\)</span>为数乘，要求</p></li>
</ol>
<ul>
<li><span class="math inline">\(ax\in V\)</span>，<span class="math inline">\(1x = x\)</span>，<span class="math inline">\(abx=(ab)x\)</span>，<span class="math inline">\(a(x+y)=ax+ay\)</span>，<span class="math inline">\((a+b)x=ax+bx\)</span></li>
</ul>
</blockquote>
<h4 id="域扩张">域扩张</h4>
<p>当<span class="math inline">\(F/E\)</span>为域扩张时，定义数乘为<span class="math inline">\(F\)</span>中的乘法，那么<span class="math inline">\(F\)</span>形成<span class="math inline">\(E\)</span>上的线性空间（验证线性空间的那几条定义即可）</p>
<p>该线性空间的维数，称为域扩张的次数，记为<span class="math inline">\([F:E]\)</span></p>
<ul>
<li><p>设<span class="math inline">\(L/M\)</span>,<span class="math inline">\(M/K\)</span>为域扩张，并且<span class="math inline">\([L:M], [M:K]\)</span>有限，那么<span class="math inline">\([L:K]=[L:M][M:K]\)</span></p>
<ul>
<li>要证明这一点，取<span class="math inline">\(L/M, M/K\)</span>的一组基<span class="math inline">\(\{\alpha\}, \{\beta\}\)</span>，证明<span class="math inline">\(\{\alpha \beta\}\)</span>为<span class="math inline">\(L/K\)</span>的一组基</li>
</ul></li>
<li><p>一些例子：<span class="math inline">\([C:Q]=2\)</span></p>
<p>设<span class="math inline">\(F=\{a+b\sqrt{d}:a, b\in Q\}\)</span>，则<span class="math inline">\([F:Q]=2\)</span>，称为二次域</p></li>
</ul>
<h4 id="最小生成的子环子域">最小生成的子环/子域</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，<span class="math inline">\(\emptyset \neq X \subseteq L\)</span>，那么</p>
<p><span class="math inline">\(K[X] = \bigcap_{R \leq L, R \subseteq K\cup X} R\)</span>为包含<span class="math inline">\(K\cup X\)</span>的最小子环，称为<span class="math inline">\(K\)</span>添加<span class="math inline">\(X\)</span>生成的子环，也说由<span class="math inline">\(X\)</span>生成的<span class="math inline">\(K\)</span>的扩环</p>
<p><span class="math inline">\(K(X)=\bigcap_{K \leq F \leq L, F \subseteq X}F\)</span>为包含<span class="math inline">\(K\cup X\)</span>的最小子域，称为<span class="math inline">\(K\)</span>添加<span class="math inline">\(X\)</span>生成的子域，也说由<span class="math inline">\(X\)</span>生成的<span class="math inline">\(K\)</span>的扩域</p>
</blockquote>
<p>当<span class="math inline">\(X=\{a_1,...,a_n\}\)</span>时，也写<span class="math inline">\(K[X]=K[a_1,...,a_n]\)</span>，<span class="math inline">\(K(X)=K(a_1,...,a_n)\)</span></p>
<p>特别的，<span class="math inline">\(K[a_1,...,a_n]\)</span>就是<span class="math inline">\(K\)</span>上的多元多项式，<span class="math inline">\(K(a_1,...,a_n)\)</span>就是<span class="math inline">\(K\)</span>上的多元多项式的分式，称为有理函数</p>
<h4 id="单扩张">单扩张</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，如果存在<span class="math inline">\(a \in L\)</span>，使得<span class="math inline">\(K(a) = L\)</span>，则称<span class="math inline">\(L\)</span>为<span class="math inline">\(K\)</span>的单扩张</p>
</blockquote>
<h3 id="week15">week15</h3>
<h4 id="代数元">代数元</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，<span class="math inline">\(\alpha \in L\)</span>，如果有非零多项式<span class="math inline">\(f(x) \in K[x]\)</span>，使得<span class="math inline">\(f(\alpha) = 0\)</span>，则称<span class="math inline">\(\alpha\)</span>为<span class="math inline">\(K\)</span>上的代数元，否则称<span class="math inline">\(\alpha\)</span>为超越元</p>
</blockquote>
<ul>
<li>如果<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(Q\)</span>上的代数元，则称其为代数数，否则，称其为超越数</li>
<li>如果<span class="math inline">\(\alpha\)</span>是首一的<span class="math inline">\(f(x) \in Z[x]\)</span>的根，则称<span class="math inline">\(\alpha\)</span>为代数整数（比如<span class="math inline">\(x^2 = 3\)</span>的根）</li>
<li>有理数一定是代数数</li>
</ul>
<p>当把代数整数限制在有理数上时，我们有</p>
<blockquote>
<p>有理数中的代数整数只有整数</p>
</blockquote>
<p>“<span class="math inline">\(\Leftarrow\)</span>”：显然</p>
<p>"<span class="math inline">\(\Rightarrow\)</span>"：如果<span class="math inline">\(r = \frac{a}{b}, (a, b) = 1\)</span>，满足<span class="math inline">\(f(r) = \frac{a^n}{b^n} + a_1 \frac{a^{n-1}}{b^{n-1}} + ... + a_n = 0\)</span></p>
<p>那么<span class="math inline">\(a^n + a_1ba^{n-1} + ... + b^n a_b = 0\)</span>，因此<span class="math inline">\(b \mid a^n\)</span>，但是<span class="math inline">\((a, b) = 1\)</span>，于是<span class="math inline">\(b = 1\)</span></p>
<h4 id="极小多项式">极小多项式</h4>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，<span class="math inline">\(\alpha \in L\)</span>为<span class="math inline">\(K\)</span>上的代数元，那么<span class="math inline">\(I = \{g(x) \in K[x] \mid g(\alpha) = 0\}\)</span>是<span class="math inline">\(K[x]\)</span>的理想</p>
<p>注意到<span class="math inline">\(K\)</span>是一个域，因此<span class="math inline">\(K[x]\)</span>是一个Euclid整环，这也就是说存在<span class="math inline">\(f(x)\)</span>使得<span class="math inline">\(I = (f(x))\)</span></p>
<p>我们称<span class="math inline">\(f(x)\)</span>为<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(K\)</span>上的极小多项式</p>
<ul>
<li><span class="math inline">\(f(x)\)</span>是<span class="math inline">\(K[x]\)</span>的不可约元</li>
</ul>
<h4 id="域扩张的次数">域扩张的次数</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，<span class="math inline">\(\alpha \in L\)</span>为<span class="math inline">\(K\)</span>上的<span class="math inline">\(n\)</span>次代数元（这个次数是指极小多项式的次数），那么</p>
<ol type="1">
<li><p><span class="math inline">\(K(\alpha) = K[\alpha]\)</span>，并且<span class="math inline">\([K(\alpha) : K] = n\)</span>，对应的线性空间的一组基为<span class="math inline">\(\alpha^0, \alpha^1, ..., \alpha^{n-1}\)</span></p></li>
<li><p>设<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(K\)</span>上的极小多项式为<span class="math inline">\(f(x)\)</span>，那么<span class="math inline">\(K(\alpha) \cong K[x] / (f(x))\)</span></p></li>
</ol>
</blockquote>
<ol type="1">
<li>设<span class="math inline">\(g(x) \in K[x]\)</span>，且<span class="math inline">\(g(\alpha) \neq 0\)</span>，我们证明<span class="math inline">\(g(\alpha)\)</span>存在逆元</li>
</ol>
<p>由于<span class="math inline">\(f(\alpha)\)</span>是极小多项式（为不可约元），因此<span class="math inline">\((f(x), g(x))=1\)</span>，那么存在<span class="math inline">\(u, v\)</span>使得<span class="math inline">\(uf + gv=1\)</span>，代入<span class="math inline">\(\alpha\)</span>，得到<span class="math inline">\(g(\alpha) v(\alpha) = 1\)</span>，这可以说明<span class="math inline">\(K(\alpha) = K[\alpha]\)</span></p>
<p>下面，我们考虑证明<span class="math inline">\(\alpha^0, ..., \alpha^{n-1}\)</span>是一组基，通过取模的方式，其足够表出<span class="math inline">\(K(\alpha)\)</span>中的所有元素，线性无关则可以根据极小多项式的性质来证明</p>
<ol start="2" type="1">
<li>设<span class="math inline">\(\sigma : K[x] \to K(\alpha)\)</span>，<span class="math inline">\(\sigma(f(x)) = f(\alpha)\)</span>，这是一个满同态，同态核为<span class="math inline">\((f(x))\)</span></li>
</ol>
<ul>
<li><span class="math inline">\(R[i] = C \cong R[x]/(x^2 + 1)\)</span>，此时<span class="math inline">\(i\)</span>可以看作是取模之后的<span class="math inline">\(x\)</span></li>
</ul>
<p>考虑上述定理的“反面”</p>
<blockquote>
<p>设<span class="math inline">\(K\)</span>为域，<span class="math inline">\(f(x) \in K[x]\)</span>不可约，那么存在<span class="math inline">\(K\)</span>的扩域<span class="math inline">\(L\)</span>，使得存在<span class="math inline">\(\alpha \in L\)</span>有<span class="math inline">\(K(\alpha) = L\)</span>，并且<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(K\)</span>上的极小多项式为<span class="math inline">\(f(x)\)</span></p>
</blockquote>
<ul>
<li><p><span class="math inline">\(F = K[x] / (f(x))\)</span>构成一个域（不可约元的理想为极大理想），在这个域中，把<span class="math inline">\(\bar{x}=x + r(x)f(x), r(x) \in K[x]\)</span>“看作”<span class="math inline">\(\alpha\)</span>，那么<span class="math inline">\(\alpha\)</span>对应的极小多项式自然为<span class="math inline">\(f(x)\)</span></p>
<p>这里的“看作”实际上就是一堆代换，不难感性理解</p></li>
</ul>
<h4 id="有限扩张">有限扩张</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，那么<span class="math inline">\([L:K]\)</span>有穷当且仅当存在有限个<span class="math inline">\(K\)</span>上的代数元<span class="math inline">\(\alpha_1, ..., \alpha_n \in L\)</span>，使得<span class="math inline">\(K(\alpha_1, ..., \alpha_n) = L\)</span></p>
</blockquote>
<p>必要性：取<span class="math inline">\(L/K\)</span>的一组基<span class="math inline">\(\alpha_1, ..., \alpha_n\)</span>，那么<span class="math inline">\(L \subseteq K(\alpha_1, ..., \alpha_n) \subseteq L\)</span>，于是<span class="math inline">\(L=K(\alpha_1,...,\alpha_n)\)</span>，因为<span class="math inline">\([L:K]\)</span>有限，因此每个<span class="math inline">\(\alpha_i\)</span>都存在一个极小多项式</p>
<p>充分性：设<span class="math inline">\(K_0 = K, K_i = K_{i-1}(\alpha_i)\)</span>，所有的<span class="math inline">\(\alpha_i\)</span>作为<span class="math inline">\(K\)</span>上的代数元，一定也是<span class="math inline">\(K_{i-1}\)</span>上的代数元，从而<span class="math inline">\([L:K] = \prod_{i=1}^n [K_i : K_{i-1}] &lt; \infty\)</span></p>
<h4 id="代数扩张">代数扩张</h4>
<blockquote>
<p>设<span class="math inline">\(L/M, M/K\)</span>为域的代数扩张，那么<span class="math inline">\(L/K\)</span>为域的代数扩张</p>
</blockquote>
<p>证明任给<span class="math inline">\(\alpha \in L\)</span>，证明<span class="math inline">\(\alpha\)</span>为<span class="math inline">\(K\)</span>上的代数元</p>
<p>设<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(M\)</span>中的极小多项式为<span class="math inline">\(f(x)=x^n + a_1x^{n-1} + ... + a_n\)</span>，注意到<span class="math inline">\(a_1,...,a_n\)</span>为<span class="math inline">\(K\)</span>上的代数元</p>
<p>那么<span class="math inline">\([K(a_1, ..., a_n, \alpha) : K] = [K(a_1,...,\alpha):K(a_1,...,a_n)]*[K(a_1,...,a_n):K] &lt; \infty\)</span></p>
<p>注意到<span class="math inline">\(\alpha\)</span>为<span class="math inline">\(K(a_1, ..., a_n)\)</span>上的代数元，上式成立，由于<span class="math inline">\(\alpha\)</span>在扩张后的域中，因此<span class="math inline">\(\alpha\)</span>为代数元</p>
<h4 id="代数闭包">代数闭包</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为域扩张，那么<span class="math inline">\(\overline{K} = \{a \in L : \alpha \text{为K的代数元}\}\)</span>为<span class="math inline">\(L\)</span>的子域，并且<span class="math inline">\(\overline{\overline{K}}=\overline{K}\)</span></p>
</blockquote>
<ul>
<li><p>我们给出一个引理：设<span class="math inline">\(L/K\)</span>为域扩张，<span class="math inline">\(\alpha \in L\)</span>，则<span class="math inline">\(\alpha\)</span>为<span class="math inline">\(K\)</span>上的代数元的充要条件为存在不全为<span class="math inline">\(0\)</span>的<span class="math inline">\(\alpha_1, ..., \alpha_n \in L\)</span>，使得令<span class="math inline">\(V = \sum K\alpha_i\)</span>时，有<span class="math inline">\(\alpha V \subseteq V\)</span></p>
<p>充分性：取<span class="math inline">\(\alpha^0, ..., \alpha^{n-1}\)</span>为系数即可</p>
<p>必要性：不妨设<span class="math inline">\(\alpha \alpha_i = \sum_{j=1}^n a_{ij} \alpha_j\)</span>，那么<span class="math inline">\(\alpha\)</span>时特征多项式<span class="math inline">\(|\lambda I - A| = 0\)</span>的根，其中<span class="math inline">\(A = (a_{ij})\)</span></p></li>
</ul>
<p>利用引理，证明对加法和乘法封闭时，取<span class="math inline">\(\alpha, \beta\)</span>的极小多项式<span class="math inline">\(f, g\)</span>的次数为<span class="math inline">\(n, m\)</span>，令<span class="math inline">\(V=\sum k_{ij}\alpha^i \beta^j\)</span></p>
<p>证明<span class="math inline">\((\alpha \pm \beta) V \subseteq V\)</span>，<span class="math inline">\(\alpha \beta V \subseteq V\)</span>即可，逆元的证明是平凡的</p>
<p>下面考虑证明<span class="math inline">\(\overline{\overline{K}}=\overline{K}\)</span>，设<span class="math inline">\(\alpha\)</span>为<span class="math inline">\(\overline{K}\)</span>上的代数元，设其极小多项式为<span class="math inline">\(f(x)=x^n+a_1x^{n-1}+...+a_n\)</span></p>
<p>由于系数都在<span class="math inline">\(K(a_1,...,a_n)\)</span>中，因此<span class="math inline">\(\alpha\)</span>是<span class="math inline">\(K(a_1,...,a_n)\)</span>上的代数元，那么类似前面的分析，有<span class="math inline">\([K(a_1,...,a_n, \alpha):K]&lt;\infty\)</span>，从而<span class="math inline">\(\alpha \in \overline{K}\)</span></p>
<h4 id="代数闭域">代数闭域</h4>
<blockquote>
<p>如果<span class="math inline">\(F = \overline{F}\)</span>，那么称<span class="math inline">\(F\)</span>为代数闭域</p>
</blockquote>
<p>代数闭域中任何非常数多项式可以分解为一次多项式的乘积</p>
<ul>
<li>复数域<span class="math inline">\(C\)</span>，全体代数数构成的域<span class="math inline">\(\overline{Q}\)</span>都是代数闭域</li>
</ul>
<h4 id="有限域">有限域</h4>
<blockquote>
<p>设<span class="math inline">\(F\)</span>为有限域，则<span class="math inline">\(|F|\)</span>为素数幂次</p>
</blockquote>
<p>设<span class="math inline">\(F\)</span>为有限域，不难知道<span class="math inline">\(ch(F)\)</span>为素数，设<span class="math inline">\(E = \{0, e, ..., (p-1)e\}\)</span>为<span class="math inline">\(p\)</span>元域，而<span class="math inline">\([F:E]\)</span>为有限扩张，设其为<span class="math inline">\(n\)</span>，那么有<span class="math inline">\(|F|=|E|^n = p^n\)</span></p>
<h4 id="形式导数">形式导数</h4>
<blockquote>
<p>设<span class="math inline">\(F\)</span>为域，对于<span class="math inline">\(P(x) = \sum_{i=0}^k a_i x^i \in F[x]\)</span>，定义其形式导数为$P'(x) = _{i=1}^k ia_ix^{i-1} $</p>
</blockquote>
<ul>
<li><span class="math inline">\((P(x)Q(x))&#39;=P(x)Q&#39;(x)+P&#39;(x)Q(x)\)</span></li>
</ul>
<p>我们将通过这个玩意来寻找有限域</p>
<ul>
<li><p>引理：设<span class="math inline">\(F\)</span>为<span class="math inline">\(q\)</span>元域，<span class="math inline">\(n\)</span>为正整数，则没有非常数多项式<span class="math inline">\(f(x) \in F[x]\)</span>，使得<span class="math inline">\(f(x)^2 \mid x^{nq}-x\)</span></p>
<p>如果<span class="math inline">\(x^{nq}-x=f(x)^2g(x)\)</span>，求导之后有<span class="math inline">\((nqe)x^{nq-1}-e=f(x)^2g&#39;(x)+2f(x)f&#39;(x)g(x)\)</span></p>
<p>注意到特征为<span class="math inline">\(q\)</span>的因子，因此<span class="math inline">\((nqe)x^{nq-1} = 0\)</span>，那么<span class="math inline">\(f(x)\)</span>整除右边，自然整除左边，得到<span class="math inline">\(f(x) \mid e\)</span></p></li>
</ul>
<h3 id="week16">week16</h3>
<h4 id="有限域的构造">有限域的构造</h4>
<blockquote>
<p>设<span class="math inline">\(F\)</span>为<span class="math inline">\(q\)</span>元域，<span class="math inline">\(n\)</span>为正整数，则<span class="math inline">\(x^{q^n} - x\)</span>是<span class="math inline">\(F[x]\)</span>中次数整除<span class="math inline">\(n\)</span>的所有首一不可约多项式的乘积</p>
</blockquote>
<p>要证明这个引理，我们证明下面三个性质，不过每个证明都比较繁琐...</p>
<ul>
<li><span class="math inline">\(x^{q^n} - x\)</span>可以分解为首一不可约多项式</li>
<li>首一不可约多项式不可能在<span class="math inline">\(x^{q^n} - x\)</span>中出现两次（使用上周用形式导数相关的引理）</li>
<li>所有的不可约多项式是其因子</li>
</ul>
<p>让我们举一些例子：<span class="math inline">\(x^{2^2} - x = x(x-1)(x^2 + x + 1)\)</span></p>
<p><span class="math inline">\(x^{3^2} - x = x(x-1)(x+1)(x^2 - 1)(x^2 + x + 2)(x^2 + x - 2)\)</span></p>
<p>通过上述引理，我们可以证明</p>
<blockquote>
<p>设<span class="math inline">\(E\)</span>为有限域，则<span class="math inline">\(E[x]\)</span>中一定存在首一<span class="math inline">\(n\)</span>次不可约多项式</p>
</blockquote>
<p>对比上一个定理中的系数，设<span class="math inline">\(N_d\)</span>为首一<span class="math inline">\(d\)</span>次不可约多项式，那么有<span class="math inline">\(q^n = \sum_{d | n} dN_d\)</span></p>
<p>一个方法是先证明<span class="math inline">\(d N_d \leq q^n - 1\)</span>，再进行放缩<span class="math inline">\(\sum_{d | n} d Nd &lt; \sum_{d=1}^n d N_d\)</span>后证明<span class="math inline">\(N_n \neq 0\)</span></p>
<h4 id="有限域的存在性">有限域的存在性</h4>
<blockquote>
<p>存在有限<span class="math inline">\(q\)</span>元域的充要条件为存在素数<span class="math inline">\(p\)</span>和正整数<span class="math inline">\(n\)</span>，使得<span class="math inline">\(q = p^n\)</span></p>
</blockquote>
<p>我们已经证明过充分性，对于必要性，我们在<span class="math inline">\(E = Z / pZ\)</span>中取首一<span class="math inline">\(n\)</span>次不可约多项式<span class="math inline">\(f(x)\)</span>，</p>
<p>那么<span class="math inline">\(E[x] / (f(x))\)</span>就是一个<span class="math inline">\(p^n\)</span>元域</p>
<blockquote>
<p>任何两个有限<span class="math inline">\(q\)</span>元域同构，我们不妨记其为<span class="math inline">\(\mathbf{F}_q\)</span></p>
</blockquote>
<h4 id="分裂域">分裂域</h4>
<blockquote>
<p>设<span class="math inline">\(K\)</span>为域，<span class="math inline">\(f(x) \in K[x]\)</span>，如果对<span class="math inline">\(K\)</span>的扩域<span class="math inline">\(L\)</span>，<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(L[x]\)</span>可分解为一次式的乘积，但对于<span class="math inline">\(L\)</span>上的子域都没有这个性质，则称<span class="math inline">\(L\)</span>为<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(K\)</span>上的分裂域</p>
</blockquote>
<p>我们可以想象，我们把<span class="math inline">\(f(x)\)</span>的所有根添入<span class="math inline">\(K\)</span>之后，新的域应该可以分解为一次式的乘积</p>
<p>实际上，如果<span class="math inline">\(f(x) = (x-a_1)^{r_1}(x-a_2)^{r_2}...(x-a_n)^{r_n}\)</span>（所有的<span class="math inline">\(a_i\)</span>两两不同），那么<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(K\)</span>上的分裂域为<span class="math inline">\(K(a_1, ..., a_n)\)</span></p>
<blockquote>
<p>设<span class="math inline">\(K\)</span>为域，<span class="math inline">\(f(x) \in K[x]\)</span>非常数多项式，那么<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(K\)</span>上的分裂域存在</p>
</blockquote>
<ul>
<li>我们把<span class="math inline">\(f(x)\)</span>写作不可约多项式的乘积，比如<span class="math inline">\(f(x) = \prod p_i(x)\)</span>，我们考虑对<span class="math inline">\(p_1(x)\)</span>进行讨论，存在扩域<span class="math inline">\(K_1 = K(\alpha_1)\)</span>，并且<span class="math inline">\(\alpha_1\)</span>在<span class="math inline">\(K\)</span>上的极小多项式为<span class="math inline">\(p_1(x)\)</span>，那么<span class="math inline">\(f(x) = (x - \alpha_1)f_1(x)\)</span>，此时<span class="math inline">\(f_1(x) \in K_1[x]\)</span>，继续对<span class="math inline">\(f_1(x)\)</span>进行分解，我们就能得到结论</li>
</ul>
<h4 id="可分元">可分元</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为代数扩张，如果<span class="math inline">\(\alpha \in L\)</span>在<span class="math inline">\(K\)</span>上的极小多项式（在其分裂域中）没有重根，则称<span class="math inline">\(\alpha\)</span>为<span class="math inline">\(K\)</span>上的可分元</p>
</blockquote>
<p>这个定义细想会有点奇怪，这是因为我们没有证明一个性质：对于确定的<span class="math inline">\(f(x)\)</span>的任何的分裂域，<span class="math inline">\(f(x)\)</span>在这些分裂域上根的重数在同构的意义下是相等的</p>
<p>对于可分元，其有一个性质</p>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为代数扩张，那么<span class="math inline">\(\alpha \in L\)</span>为可分元，当且仅当<span class="math inline">\(\alpha\)</span>在<span class="math inline">\(K\)</span>上的极小多项式<span class="math inline">\(f(x)\)</span>的导数<span class="math inline">\(f&#39;(x)\)</span>非零</p>
</blockquote>
<ul>
<li><p>如果<span class="math inline">\(\alpha\)</span>为可分元，设<span class="math inline">\(f(x) = \prod(x - a_i)\)</span>，那么<span class="math inline">\(f&#39;(x) = \sum_i \prod_{j \neq i} (x-a_j)\)</span>，于是<span class="math inline">\(f&#39;(a_1) = \prod_{j\neq 1} (a_1-a_j) \neq 0\)</span></p>
<p>反之，如果<span class="math inline">\(f&#39;(x)\)</span>非零，那么<span class="math inline">\((f&#39;(x), f(x)) = 1\)</span>（<span class="math inline">\(f(x)\)</span>不可约），那么存在<span class="math inline">\(u(x)f(x)+v(x)f&#39;(x)=1\)</span>成立，但对于重根<span class="math inline">\(\beta\)</span>而言，有<span class="math inline">\(u(\beta)f(\beta)+v(\beta)f&#39;(\beta)=0\)</span>，矛盾</p></li>
<li><p>然后我们介绍一下书上的证明，感觉涉及到了不同的角度：</p>
<ul>
<li><p>设<span class="math inline">\(a\)</span>是<span class="math inline">\(f(x) \in K[x]\)</span>在其分裂域<span class="math inline">\(L\)</span>上的<span class="math inline">\(k\)</span>重根，那么<span class="math inline">\(f(x) = (x-a)^k g(x), g(a) \neq 0\)</span></p>
<p>此时<span class="math inline">\(f&#39;(x) = (x-a)^{k-1}(kg(x)+(x-a)g&#39;(x))\)</span></p>
<p>如果<span class="math inline">\(ch(K) \not \mid k\)</span>，则<span class="math inline">\(a\)</span>是<span class="math inline">\(f&#39;(x)\)</span>的<span class="math inline">\(k-1\)</span>重根</p>
<p>而如果<span class="math inline">\(ch(K) \mid k\)</span>，则有<span class="math inline">\(f&#39;(x)=(x-a)^kg(x)\)</span>，<span class="math inline">\(a\)</span>是<span class="math inline">\(f&#39;(x)\)</span>的至少<span class="math inline">\(k\)</span>重根</p></li>
</ul>
<p>从上面的讨论，我们知道，（1）<span class="math inline">\(a\)</span>是<span class="math inline">\(f(x)\)</span>的单根的一个充要条件是<span class="math inline">\(a\)</span>是<span class="math inline">\(f&#39;(x)\)</span>的零根（2）<span class="math inline">\(a\)</span>是<span class="math inline">\(f(x)\)</span>的重根的充要条件是<span class="math inline">\(a\)</span>是<span class="math inline">\(f&#39;(x)\)</span>的根</p>
<p>因此，<span class="math inline">\(f(x)\)</span>要有重根，必然地需要有<span class="math inline">\(\deg (\gcd(f(x), f&#39;(x))) &gt; 1\)</span>，再利用<span class="math inline">\(f(x)\)</span>不可约就不难证明了</p></li>
</ul>
<p>有了可分元之后，我们定义可分扩张</p>
<blockquote>
<p>如果<span class="math inline">\(\forall \alpha \in L\)</span>，<span class="math inline">\(\alpha\)</span>都是<span class="math inline">\(K\)</span>上的可分元，则称<span class="math inline">\(L/K\)</span>为可分扩张</p>
</blockquote>
<p>对于可分扩张，我们也有一个性质</p>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为代数扩张，若<span class="math inline">\(ch(K)=0\)</span>或者<span class="math inline">\(|K|&lt;\infty\)</span>，则<span class="math inline">\(L/K\)</span>为可分扩张</p>
</blockquote>
<p><span class="math inline">\(ch(K)=0\)</span>时，极小多项式的首项非0</p>
<p><span class="math inline">\(|K|&lt;\infty\)</span>时，极小多项式<span class="math inline">\(f(x) \mid x^{q^n} - x\)</span>，由于<span class="math inline">\((x^{q^n} - x)&#39; = -1\)</span>（注意到特征的性质），但有重根<span class="math inline">\(\beta\)</span>时，导数的取值为<span class="math inline">\(0\)</span>，矛盾</p>
<h4 id="不可分的多项式">不可分的多项式</h4>
<p>设不可约多项式<span class="math inline">\(f(x) \in K[x]\)</span>不可分，根据上面的讨论，必然有<span class="math inline">\(ch(K)\)</span>是一个素数<span class="math inline">\(p\)</span></p>
<p>由于<span class="math inline">\(f(x)\)</span>不可分，那么有<span class="math inline">\(f&#39;(x)=0\)</span>，设<span class="math inline">\(f(x) = \sum a_ix^i\)</span>，则<span class="math inline">\(f&#39;(x) = \sum ia_i x^{i-1}\)</span>，于是<span class="math inline">\(ia_i = 0\)</span></p>
<p>对<span class="math inline">\(ch(K) \not \mid i\)</span>的<span class="math inline">\(i\)</span>，必然有<span class="math inline">\(a_i = 0\)</span>，于是<span class="math inline">\(f(x) = g(x^p)\)</span>，<span class="math inline">\(g\)</span>不可约但是不能确定是否可分</p>
<p>如果<span class="math inline">\(g\)</span>不可分，我们继续上述讨论，最终可以得到<span class="math inline">\(f(x) = h(x^{p^e})\)</span>，其中<span class="math inline">\(h\)</span>是一个可分多项式</p>
<p>写<span class="math inline">\(h(x) = (x-a_1)...(x-a_n)\)</span>，那么<span class="math inline">\(f(x) = (x^{p^e} - a_1)...(x^{p^e}-a_n)\)</span>，对<span class="math inline">\(x^{p^e} - a_1 = 0\)</span>，设其根为<span class="math inline">\(b_1\)</span>，那么<span class="math inline">\((x^{p^e} - a_1) = (x^{p^e} - b_1^{p^e}) = (x-b_1)^{p^e}\)</span>，因此<span class="math inline">\(f(x) = \prod(x-b_i)^{p^e}\)</span>，每个根都将有相同的重数，并且重数形如素数的幂次</p>
<h4 id="单扩张定理">单扩张定理</h4>
<blockquote>
<p>有限可分扩张为单扩张</p>
</blockquote>
<p>因为是有限扩张，故存在代数元<span class="math inline">\(a_1, ..., a_n\)</span>，使得<span class="math inline">\(L=K(a_1, ..., a_n)\)</span></p>
<p>尝试利用可分扩张的性质证明，<span class="math inline">\(\forall a, b \in L, \exist c \in L, K(a, b) = K(c)\)</span></p>
<h4 id="正规扩张">正规扩张</h4>
<blockquote>
<p>如果每个<span class="math inline">\(\alpha \in L\)</span>在<span class="math inline">\(K\)</span>上的极小多项式<span class="math inline">\(f(x)\)</span>都可以在<span class="math inline">\(L[x]\)</span>中分解为一次式的乘积，且不可约多项式<span class="math inline">\(f(x)\)</span>有一个零点在<span class="math inline">\(L\)</span>中时，其剩余的所有零点都在<span class="math inline">\(L\)</span>中时，称<span class="math inline">\(L/K\)</span>为正规扩张</p>
</blockquote>
<p>对于正规扩张，我们有</p>
<blockquote>
<p><span class="math inline">\(L/K\)</span>为有限正规扩张，当且仅当<span class="math inline">\(L\)</span>为某个<span class="math inline">\(f(x) \in K[x]\)</span>的分裂域</p>
</blockquote>
<h4 id="商域">商域</h4>
<p>对整环<span class="math inline">\(R\)</span>，我们在<span class="math inline">\(R \times R^*\)</span>上定义关系<span class="math inline">\(\sim\)</span>：<span class="math inline">\((a, b) \sim (c, d) \Leftrightarrow ad = bc\)</span></p>
<p>不难验证，这是一个等价关系，记<span class="math inline">\((a, b)\)</span>按照上述关系形成的等价类为分数<span class="math inline">\(a/b\)</span></p>
<blockquote>
<p>令<span class="math inline">\(F = \{a/b:a \in R, b \in R^*\}\)</span>，定义<span class="math inline">\(\frac{a}{b} + \frac{c}{d} = \frac{ad+bc}{bd}\)</span>以及<span class="math inline">\(\frac{a}{b} * \frac{c}{d} = \frac{ac}{bd}\)</span>，不难验证，这种加法和乘法的定义是良定义的</p>
<p>并且<span class="math inline">\(F\)</span>按照上述加法和乘法构成域，我们称其为整环<span class="math inline">\(R\)</span>的商域</p>
</blockquote>
<h2 id="galois理论">Galois理论</h2>
<h3 id="last-week">last week</h3>
<h4 id="galois群">Galois群</h4>
<blockquote>
<p>如果域扩张<span class="math inline">\(L/K\)</span>是有限可分正规扩张，则称其为<span class="math inline">\(K\)</span>的Galois扩张</p>
<p>在其上定义Galois群：<span class="math inline">\(Gal(L/K) = \{\sigma \in Aut(L): \sigma|_K = I_K\}\)</span></p>
</blockquote>
<p>也就是说，在<span class="math inline">\(L\)</span>的自同构中，保持<span class="math inline">\(K\)</span>不变的群</p>
<h4 id="不变域">不变域</h4>
<blockquote>
<p>对<span class="math inline">\(G \leq Aut(L)\)</span>，定义其不变域为<span class="math inline">\(Inv(G) = \{a \in L | \forall g \in G, g(a) = a\}\)</span></p>
</blockquote>
<p>不变域确实是一个域</p>
<h4 id="galois群论基本定理">Galois群论基本定理</h4>
<blockquote>
<p>设<span class="math inline">\(L/K\)</span>为Galois扩张</p>
<ul>
<li><p>设<span class="math inline">\(K \leq M \leq L\)</span>，则<span class="math inline">\(L/M\)</span>为Galois扩张</p>
<p>并且<span class="math inline">\(Gal(L/M) \leq Gal(L/K)\)</span>，<span class="math inline">\(|Gal(L/M)| = [L:M]\)</span>，<span class="math inline">\(Inv(Gal(L/M)) = M\)</span></p></li>
<li><p>设<span class="math inline">\(H \leq Gal(L/K)\)</span>，那么设<span class="math inline">\(M = Inv(H)\)</span>，则<span class="math inline">\(K \leq M \leq L, Gal(L/M)=H\)</span></p>
<p>也就是说，<span class="math inline">\(Gal(L/K)\)</span>的子群和<span class="math inline">\(L, K\)</span>的中间域之间存在一个一一对应的关系</p></li>
<li><p>设<span class="math inline">\(K \leq M \leq L\)</span>，那么<span class="math inline">\(M/K\)</span>是正规扩张，当且仅当<span class="math inline">\(Gal(L/M) \lhd Gal(L/K)\)</span></p>
<p>并且当<span class="math inline">\(M/K\)</span>是正规扩张时，<span class="math inline">\(Gal(L/K)/Gal(L/M) \cong Gal(M/K)\)</span></p></li>
</ul>
<p>上面这一条建立了正规扩张和正规子群之间的关系</p>
</blockquote>
<h4 id="根式可解">根式可解</h4>
<blockquote>
<p>设<span class="math inline">\(K\)</span>为域，<span class="math inline">\(f(x) \in K[x]\)</span>，如果存在域的扩张链，<span class="math inline">\(K_0 = K \leq K_1 \leq K_2 ... \leq K_n\)</span>，使得<span class="math inline">\(K_n\)</span>包含<span class="math inline">\(f(x)\)</span>的分裂域，并且这些扩张都是根式扩张，则称<span class="math inline">\(f(x)=0\)</span>在<span class="math inline">\(K\)</span>上根式可解</p>
<p>根式扩张指的是，对于扩张<span class="math inline">\(L/K\)</span>，存在<span class="math inline">\(\alpha \in L\)</span>，使得<span class="math inline">\(L = K(\alpha)\)</span>且<span class="math inline">\(\alpha^n = K\)</span>（也就是说，每次添加一个元素的开根）</p>
</blockquote>
<p>对于根式扩张，我们由</p>
<blockquote>
<p>如果<span class="math inline">\(L/K\)</span>为根式扩张，那么<span class="math inline">\(Gal(L/K)\)</span>为Abel群</p>
</blockquote>
<p>有了上述定理之后，我们对根式可解进行进一步的考虑，将得到</p>
<p>对<span class="math inline">\(K_0 = K \leq K_1 \leq K_2 ... \leq K_n\)</span>，其等价于<span class="math inline">\(Gal(L/K) \rhd Gal(L/K_1) ... \rhd Gal(L/K_n) = \{e\}\)</span></p>
<p>根据<span class="math inline">\(Gal(L/K_{i+1})/Gal(L/K_i) \cong Gal(K_{i+1}/K_i)\)</span>是Abel群，于是</p>
<blockquote>
<p><span class="math inline">\(f(x)=0\)</span>根式可解，当且仅当<span class="math inline">\(Gal(L/K)\)</span>为可解群</p>
</blockquote>
<h4 id="galois定理">Galois定理</h4>
<p>对上面的讨论取一个特殊情况，我们将得到Galois定理，不妨就用这个定理作为这门课的结束吧</p>
<blockquote>
<p>设<span class="math inline">\(K\)</span>为域，<span class="math inline">\(f(x) \in K[x]\)</span>的分裂域为<span class="math inline">\(L\)</span>，那么<span class="math inline">\(f(x) = 0\)</span>在<span class="math inline">\(L\)</span>上根式可解，当且仅当<span class="math inline">\(Gal(L/K)\)</span>为可解群</p>
</blockquote>
<ul>
<li><p>对于一般的<span class="math inline">\(n\)</span>次方程，<span class="math inline">\(f(x) = x^n + t_1x^{n-1} + ... + t_n = 0\)</span></p>
<p>此时，将<span class="math inline">\(t_1, ..., t_n\)</span>看作字母变量，那么<span class="math inline">\(f(x) \in K=F[t_1, ..., t_n][x]\)</span>，设其在<span class="math inline">\(K\)</span>上的分裂域为<span class="math inline">\(L\)</span>，那么<span class="math inline">\(Gal(L/K) \cong S_n\)</span></p>
<p>由于<span class="math inline">\(n \geq 5\)</span>时，<span class="math inline">\(S_n\)</span>不是可解群，因此，五次以上的方程没有通解</p></li>
</ul>
<p>Galois无愧于天才之名！</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>abstract algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化</title>
    <url>/2021/12/convex-optimization/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="基础定义">基础定义</h3>
<ul>
<li><p>affine set ：包含所有元素的线性组合（<span class="math inline">\(\theta x_1 + (1-\theta)x_2 \in C, \forall \theta \in R\)</span>）</p>
<ul>
<li>对于任意集合<span class="math inline">\(S\)</span>，其所有元素的线性组合为包含<span class="math inline">\(S\)</span>的最小仿射集，记为<span class="math inline">\(\text{aff} S\)</span></li>
</ul></li>
<li><p>convex set ：包含所有元素的凸组合（<span class="math inline">\(\theta x_1 + (1-\theta)x_2 \in C, \forall \theta \in [0,1]\)</span>）</p>
<ul>
<li>对于任意集合<span class="math inline">\(S\)</span>，其所有元素的线性组合为包含<span class="math inline">\(S\)</span>的最小仿射集，记为<span class="math inline">\(\text{conv} S\)</span></li>
</ul></li>
<li><p>cone：包含所有元素的非负组合（<span class="math inline">\(\theta_1 x_1 + \theta_2 x_2 \in C, \forall \theta_1, \theta_2 \geq 0\)</span>）</p></li>
<li><p>hyperplane：<span class="math inline">\(\{x | a^Tx = b\}\)</span>，halfspaces：<span class="math inline">\(\{x|a^Tx \leq b\}\)</span></p></li>
<li><p>球体（包括范数球），椭球体，锥（含范数锥）都是凸集</p></li>
</ul>
<h3 id="保凸集凸性">保凸集凸性</h3>
<ul>
<li><p>相交：如果<span class="math inline">\(C_1, C_2\)</span>为凸集，那么<span class="math inline">\(C_1 \cap C_2\)</span>为凸集</p></li>
<li><p>仿射变换及其逆变换：如果<span class="math inline">\(C\)</span>为凸集，<span class="math inline">\(f(x)=Ax+b\)</span>为仿射变换</p>
<p>那么<span class="math inline">\(f(C) = \{f(x) | x \in C\}\)</span>和<span class="math inline">\(f^{-1}(C) = \{x|f(x) \in C\}\)</span>构成凸集</p>
<ul>
<li>注意到<span class="math inline">\(\theta f( x_1) + (1-\theta) f(x_2) = f(\theta x_1 + (1-\theta)x_2)\)</span>，因此<span class="math inline">\(f(C)\)</span>构成凸集</li>
<li>对于<span class="math inline">\(f^{-1}\)</span>，等价于证明<span class="math inline">\(f(x_1) \in C, f(x_2) \in C \Rightarrow f(\theta x_1 + (1-\theta)x_2) \in C\)</span>，由上面的式子是显然的</li>
</ul></li>
<li><p>透视变换：记<span class="math inline">\(P : R^n \times R_{++} \to R^n\)</span>为<span class="math inline">\(P(x, t) = x/t\)</span></p>
<p>那么，当<span class="math inline">\(C\)</span>为凸集时，<span class="math inline">\(P(C)\)</span>和<span class="math inline">\(P^{-1}(C)\)</span>为凸集</p>
<ul>
<li>按照定义去配凑即可，由于这并不是一个线性函数，因此在理解时可能由大问题</li>
</ul></li>
<li><p>线性分式函数：对于<span class="math inline">\(x\)</span>，定义<span class="math inline">\(f(x) = \frac{Ax + b}{c^T x + d}\)</span>，则对于凸集<span class="math inline">\(C\)</span>，<span class="math inline">\(f(C)\)</span>和<span class="math inline">\(f^{-1}(C)\)</span>都是凸集</p>
<ul>
<li>线性分式函数可以视为仿射变换和透视变换的复合</li>
</ul></li>
</ul>
<h3 id="分离超平面定理">分离超平面定理</h3>
<ul>
<li>对于凸集<span class="math inline">\(C\)</span>和<span class="math inline">\(D\)</span>，如果<span class="math inline">\(C \cap D = \emptyset\)</span>，那么存在超平面<span class="math inline">\(\{x|a^Tx = b\}\)</span>，使得<span class="math inline">\(\forall x \in C, a^Tx \leq b\)</span>并且<span class="math inline">\(\forall x \in D, a^Tx \geq b\)</span>
<ul>
<li>证明的思路是构造性的，取<span class="math inline">\(C, D\)</span>上距离最小的两点<span class="math inline">\(c, d\)</span>，作垂直于直线<span class="math inline">\(cd\)</span>，过<span class="math inline">\(c, d\)</span>中点的平面</li>
</ul></li>
<li>对于凸集<span class="math inline">\(C\)</span>边界上的每一点<span class="math inline">\(x_0\)</span>，存在超平面，使得<span class="math inline">\(\forall x \in C, a^Tx \leq b\)</span>并且<span class="math inline">\(a^Tx_0 = b\)</span>成立
<ul>
<li>这个称为支撑超平面定理</li>
<li>取凸集的内部<span class="math inline">\(\text{int} C\)</span>和<span class="math inline">\(\{x_0\}\)</span>，对他们运用分离超平面定理</li>
</ul></li>
</ul>
<h3 id="凸函数">凸函数</h3>
<ul>
<li><p>设<span class="math inline">\(f : R^n \to R\)</span>为凸，当且仅当<span class="math inline">\(\text{dom} f\)</span>为凸，并且<span class="math inline">\(\forall x, y \in dom\;f, 0 \leq \theta \leq 1\)</span>，有<span class="math inline">\(f(\theta x + (1-\theta) y) \leq \theta f(x) + (1-\theta) f(y)\)</span></p></li>
<li><p>第二定义：对于任意<span class="math inline">\(x \in dom\;f, v \in R^n\)</span>，<span class="math inline">\(g(t) = f(x + tv)\)</span>为凸函数</p>
<p>（注意<span class="math inline">\(g\)</span>是一维的函数）</p></li>
</ul>
<p>根据上述两个定义，在研究高维时，先对一维情况入手，再使用第二定义将是不错的方法</p>
<ul>
<li><p>一阶条件：<span class="math inline">\(f\)</span>可微时，<span class="math inline">\(f\)</span>为凸函数当且仅当<span class="math inline">\(\forall x, y \in dom\;f\)</span>，有<span class="math inline">\(f(y) \geq f(x) + \nabla f(x)^T(y-x)\)</span></p>
<p>一维情况下，左边推右边的证明是构造性的，右边推左边则是进行逼近</p>
<p>多维证明一维就使用第二定义</p>
<ul>
<li>如果<span class="math inline">\(\nabla f(x_0) = 0\)</span>，那么根据一阶条件，有<span class="math inline">\(\forall y \in dom\;f, f(y) \geq f(x_0)\)</span></li>
</ul></li>
<li><p>二阶条件：<span class="math inline">\(f\)</span>二阶可微时，<span class="math inline">\(f\)</span>为凸函数当且仅当<span class="math inline">\(\nabla^2f(x) \geq 0\)</span></p></li>
</ul>
<h3 id="kkt条件">KKT条件</h3>
<p>...前面的所有的知识都是为了推导这个条件，我先在这里给咕咕咕了</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>convex_optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数</title>
    <url>/2021/09/abstract-algebra/</url>
    <content><![CDATA[<span id="more"></span>
<p>虽然在过去的博客中，对于这一门课的内容也记了很多东西，但还是新开一个博客，方便自己查阅一些定理吧</p>
<h1 id="近世代数">近世代数</h1>
<h2 id="群">群</h2>
<h3 id="week1">week1</h3>
<h4 id="半群">半群</h4>
<blockquote>
<p>如果<span class="math inline">\(X\)</span>非空，并且有运算<span class="math inline">\(*\)</span>满足</p>
<ul>
<li>封闭性：<span class="math inline">\(\forall x, y \in X, x *y \in X\)</span></li>
<li>结合律：<span class="math inline">\((x * y) * z = x*(y*z)\)</span></li>
</ul>
<p>则称<span class="math inline">\(\langle X, *\rangle\)</span>为半群结构</p>
</blockquote>
<h4 id="幺半群">幺半群</h4>
<blockquote>
<p>如果<span class="math inline">\(X\)</span>以<span class="math inline">\(*\)</span>构成半群，并且还满足</p>
<ul>
<li><span class="math inline">\(\exist e \in X, \forall x \in X, x = ex=xe\)</span></li>
</ul>
<p>则称<span class="math inline">\(e\)</span>为单位元，<span class="math inline">\(X\)</span>为幺半群</p>
</blockquote>
<ul>
<li>单位元是唯一的</li>
</ul>
<h4 id="逆元">逆元</h4>
<blockquote>
<p>如果<span class="math inline">\(ab = ba = e\)</span>，则称<span class="math inline">\(a\)</span>为<span class="math inline">\(b\)</span>的逆元</p>
</blockquote>
<ul>
<li>每个元素的逆元是唯一的</li>
<li><span class="math inline">\((a^{-1})^{-1} = a\)</span></li>
<li>如果<span class="math inline">\(a, b\)</span>可逆，那么<span class="math inline">\(ab\)</span>也可逆，并且<span class="math inline">\((ab)^{-1}=b^{-1}a^{-1}\)</span></li>
</ul>
<h4 id="群-1">群</h4>
<blockquote>
<p>如果<span class="math inline">\(X\)</span>非空，并且有运算<span class="math inline">\(*\)</span>满足</p>
<ul>
<li>封闭性：<span class="math inline">\(\forall x, y \in X, x *y \in X\)</span></li>
<li>结合律：<span class="math inline">\((x * y) * z = x*(y*z)\)</span></li>
<li>单位元：<span class="math inline">\(\exist e \in X, \forall x \in X, x=x*e=e*x\)</span></li>
<li>可逆：<span class="math inline">\(\forall x \in X, \exists y \in X, x * y = y*x=e\)</span></li>
</ul>
<p>则称<span class="math inline">\(X\)</span>按<span class="math inline">\(*\)</span>构成群</p>
</blockquote>
<h4 id="群的阶">群的阶</h4>
<blockquote>
<p>如果群<span class="math inline">\(G\)</span>里面只有有限个元素，那么称<span class="math inline">\(G\)</span>为有限群，并且称<span class="math inline">\(G\)</span>内元素的个数为群<span class="math inline">\(G\)</span>的阶，记做<span class="math inline">\(|G|\)</span></p>
</blockquote>
<h4 id="交换群">交换群</h4>
<blockquote>
<p>如果<span class="math inline">\(\forall a, b \in G\)</span>，有<span class="math inline">\(ab = ba\)</span>，那么称群<span class="math inline">\(G\)</span>为阿贝尔群或交换群</p>
</blockquote>
<ul>
<li><p>半群<span class="math inline">\(G\)</span>是群，当且仅当：<span class="math inline">\(\forall a, b \in G\)</span>, 方程<span class="math inline">\(ax = b\)</span>和<span class="math inline">\(ya = b\)</span>在<span class="math inline">\(G\)</span>中有解（可除性条件）</p></li>
<li><p>有限半群<span class="math inline">\(G\)</span>是群，当且仅当：<span class="math inline">\(\forall a, x, y \in G\)</span>，有<span class="math inline">\(ax = ay \Rightarrow x=y\)</span>且<span class="math inline">\(xa=ya \Rightarrow x=y\)</span>（消去律）</p></li>
</ul>
<h4 id="常见的群">常见的群</h4>
<blockquote>
<p>集合<span class="math inline">\(X\)</span>上的所有置换构成群，称为<strong>对称群</strong>，记为<span class="math inline">\(S(X)\)</span>，特别的，<span class="math inline">\(S([n])\)</span>简记为<span class="math inline">\(S_n\)</span></p>
<p>所有大小为<span class="math inline">\(n*n\)</span>的可逆实矩阵构成群，称为<strong>一般线性群</strong>，记为<span class="math inline">\(GL_n(R)\)</span></p>
<p>所有大小为<span class="math inline">\(n*n\)</span>的可逆实对角矩阵构成群，称为<strong>特殊线性群</strong>，记为<span class="math inline">\(SL_n(R)\)</span></p>
</blockquote>
<h3 id="week2">week2</h3>
<h4 id="子群">子群</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>按照<span class="math inline">\(*\)</span>构成群，<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的一个非空子集，并且<span class="math inline">\(H\)</span>按照<span class="math inline">\(*\)</span>也构成群，则称<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的子群，并记为<span class="math inline">\(H \leqslant G\)</span></p>
</blockquote>
<ul>
<li><p><span class="math inline">\(H\)</span>的单位元<span class="math inline">\(e_H\)</span>就是<span class="math inline">\(G\)</span>的单位元<span class="math inline">\(e\)</span></p></li>
<li><p><span class="math inline">\(a\)</span>在<span class="math inline">\(H\)</span>中的逆元<span class="math inline">\(a_H^{-1}\)</span>就是<span class="math inline">\(a\)</span>在<span class="math inline">\(G\)</span>中的逆元<span class="math inline">\(a^{-1}\)</span></p></li>
<li><p>子群的判定</p>
<ul>
<li>如果<span class="math inline">\(H\)</span>对乘法，求逆封闭，那么<span class="math inline">\(H\)</span>为子群</li>
<li>如果<span class="math inline">\(H\)</span>对右除法封闭，即<span class="math inline">\(\forall a, b \in H\)</span>时，有<span class="math inline">\(ab^{-1} \in H\)</span></li>
</ul></li>
<li><p>群<span class="math inline">\(G\)</span>的若干个子群的交也是<span class="math inline">\(G\)</span>的子群</p></li>
</ul>
<h4 id="群的子集的乘积">群的子集的乘积</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，对于<span class="math inline">\(X, Y \subseteq G\)</span>，定义</p>
<ul>
<li><span class="math inline">\(X^{-1} = \{x^{-1}:x\in X\}\)</span></li>
<li><span class="math inline">\(XY = \{xy : x \in X \cap y \in Y\}\)</span></li>
</ul>
</blockquote>
<p>在上述条件下，我们有</p>
<ul>
<li><span class="math inline">\((X^{-1})^{-1} = X\)</span></li>
<li><span class="math inline">\((XY)Z = X(YZ)\)</span></li>
<li><span class="math inline">\((X_1X_2...X_n)^{-1} = X_n^{-1}...X_2^{-1}X_1^{-1}\)</span></li>
</ul>
<p>特别的，如果<span class="math inline">\(H\)</span>是一个子群，那么</p>
<ul>
<li><span class="math inline">\(H^{-1} = H\)</span></li>
<li><span class="math inline">\(HH = HH^{-1} = H^{-1}H = H\)</span></li>
</ul>
<p>接着我们考虑单个元素和子集进行运算的情况，可以认为是集合运算的特例</p>
<ul>
<li><span class="math inline">\(Hab = (Ha)b = H(ab)\)</span></li>
<li><span class="math inline">\((Ha)^{-1} = a^{-1}H^{-1}\)</span></li>
</ul>
<h4 id="子群的乘积">子群的乘积</h4>
<blockquote>
<p>设<span class="math inline">\(H, K \leq G\)</span>，则<span class="math inline">\(HK \leq G \Leftrightarrow HK=KH\)</span></p>
</blockquote>
<h4 id="子群的陪集">子群的陪集</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，<span class="math inline">\(H \leq G\)</span>，对于<span class="math inline">\(a \in G\)</span>，称<span class="math inline">\(aH = \{ah : h \in H\}\)</span>为<span class="math inline">\(a\)</span>所在的<span class="math inline">\(H\)</span>的左陪集</p>
<p>称<span class="math inline">\(Ha = \{ha:h \in H\}\)</span>为<span class="math inline">\(a\)</span>所在的<span class="math inline">\(H\)</span>的右陪集</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(|Ha|=|aH|=|H|\)</span></p></li>
<li><p><span class="math inline">\(aH = bH \Leftrightarrow b^{-1}a \in H\)</span>，可以考虑一般情况，<span class="math inline">\(hH = H \Leftrightarrow Hh = H \Leftrightarrow h\in H\)</span></p></li>
</ul>
<h4 id="子群的指标">子群的指标</h4>
<ul>
<li>设<span class="math inline">\(H\)</span>为群<span class="math inline">\(G\)</span>的子群，则<span class="math inline">\(|\{aH:a\in G\}| = |\{Ha : a \in G\}|\)</span>（即左陪集的个数等于右陪集的个数）</li>
</ul>
<blockquote>
<p>如果<span class="math inline">\(H \leq G\)</span>，我们称<span class="math inline">\(|\{aH : a \in G\}|\)</span>为<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中的指标，记为<span class="math inline">\([G:H]\)</span></p>
</blockquote>
<h4 id="lagrange-定理z">Lagrange 定理z</h4>
<blockquote>
<p>设<span class="math inline">\(H\)</span>为有限群<span class="math inline">\(G\)</span>的子群，则<span class="math inline">\([G:H]=|G|/|H|\)</span></p>
</blockquote>
<ul>
<li><p>设<span class="math inline">\(K \leq H \leq G\)</span>，并且<span class="math inline">\([G:H]\)</span>与<span class="math inline">\([H:K]\)</span>有限，那么<span class="math inline">\([G:H][H:K]=[G:K]\)</span></p>
<p>! 注意，这条定理在证明时一定要通过映射来证明，不要通过Lagrange定理简单证明</p></li>
<li><p>设<span class="math inline">\(H, K \leq G\)</span>，则<span class="math inline">\(|\{Hg:g\in G \cap Hg \subseteq HK\}| = [K:H \cap K]\)</span></p>
<p>也即<span class="math inline">\(K\)</span>中，<span class="math inline">\(H \cap K\)</span>的分布和<span class="math inline">\(HK\)</span>中，<span class="math inline">\(H\)</span>的右陪集的分布是相似的</p></li>
<li><p>Poincare定理：如果<span class="math inline">\(H_1, ..., H_n\)</span>都是群<span class="math inline">\(G\)</span>的指标有限的子群，那么<span class="math inline">\(\bigcap_{i=1}^n H_i\)</span>的指标也有限，并且<span class="math inline">\([G:\bigcap_{i=1}^n H_i] \leq \prod_{i=1}^n [G:H_i]\)</span></p></li>
<li><p>设<span class="math inline">\(G\)</span>为<span class="math inline">\(n\)</span>阶群，那么<span class="math inline">\(\forall a \in G\)</span>有<span class="math inline">\(a^n = e\)</span></p></li>
</ul>
<h4 id="群中元素的阶">群中元素的阶</h4>
<blockquote>
<p>设<span class="math inline">\(a\)</span>为群<span class="math inline">\(G\)</span>的元素，如果有正整数<span class="math inline">\(n\)</span>使得<span class="math inline">\(a^n = e\)</span>，那么，我们称最小的这样的正整数为<span class="math inline">\(a\)</span>的阶，记为<span class="math inline">\(o(a)\)</span>，特别的，如果<span class="math inline">\(\forall n \in Z, a^n \neq e\)</span>，那么我们说<span class="math inline">\(a\)</span>的阶为无穷，记为<span class="math inline">\(o(a) = \infty\)</span></p>
</blockquote>
<ul>
<li>设<span class="math inline">\(o(a) = n\)</span>，则<span class="math inline">\(o(a^m) = \frac{n}{(m, n)}\)</span></li>
</ul>
<h4 id="有限生成群">有限生成群</h4>
<blockquote>
<p>对群<span class="math inline">\(G\)</span>的非空子集<span class="math inline">\(X\)</span>，由<span class="math inline">\(X\)</span>生成的<span class="math inline">\(G\)</span>的子群指</p>
<p><span class="math inline">\(\langle X \rangle = \bigcap_{x \subseteq H \leq G} H = \{x_1^{m_1}x_2^{m_2}...x_k^{m_k} : k \in Z^{+}, x_i \in X, m_i \in \{1,-1\}\}\)</span></p>
</blockquote>
<h4 id="循环群">循环群</h4>
<blockquote>
<p>称<span class="math inline">\(\langle a \rangle\)</span>为<span class="math inline">\(a\)</span>生成的循环群，<span class="math inline">\(a\)</span>称为这个群的一个生成元</p>
</blockquote>
<ul>
<li><p>如果<span class="math inline">\(o(a) = n\)</span>，那么<span class="math inline">\(\langle a \rangle = \{e, a, a^2, ..., a^{n-1}\}\)</span></p></li>
<li><p>循环群的子群仍然是循环群</p></li>
<li><p>有限循环群的子群为<span class="math inline">\(\langle a^m \rangle, 0 \leq m \leq n\)</span>，一共有<span class="math inline">\(\varphi(n)\)</span>个</p>
<p>具体的，对于<span class="math inline">\(d | n\)</span>，有维一的<span class="math inline">\(d\)</span>阶子群<span class="math inline">\(\langle a^{n/d} \rangle\)</span></p></li>
<li><p>无限循环群的子群为<span class="math inline">\(\langle a^n \rangle\)</span>，当<span class="math inline">\(n\)</span>不同时，这些子群也两两不同</p></li>
<li><p>设<span class="math inline">\(G\)</span>为<span class="math inline">\(p^n\)</span>阶群，则<span class="math inline">\(G\)</span>中一定含有<span class="math inline">\(p\)</span>阶元</p></li>
<li><p>素数阶群一定是循环群</p></li>
</ul>
<h4 id="共轭子群">共轭子群</h4>
<blockquote>
<p>设<span class="math inline">\(H \leq G\)</span>，那么，<span class="math inline">\(\forall g \in G\)</span>，<span class="math inline">\(gHg^{-1} \leq G\)</span>，此时，我们称<span class="math inline">\(gHg^{-1}\)</span>为与<span class="math inline">\(H\)</span>共轭的子群</p>
</blockquote>
<p>利用子群的判别条件：<span class="math inline">\(\forall x, y \in gHg^{-1}, \exists h_1, h_2, \;s.t.\; gh_1g^{-1} = x, gh_2g^{-1} = y\)</span>，因此，<span class="math inline">\(xy^{-1} = gh_1g^{-1} * gh_2^{-1}g^{-1} = g(h_1h_2^{-1})g^{-1} \in gHg^{-1}\)</span></p>
<h4 id="正规子群">正规子群</h4>
<blockquote>
<p>设<span class="math inline">\(H \leq G\)</span>，如果<span class="math inline">\(\forall g \in G\)</span>，有<span class="math inline">\(gHg^{-1} = H\)</span>，或者<span class="math inline">\(gH=Hg\)</span>，那么，我们称<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的正规子群，记为<span class="math inline">\(H \lhd G\)</span></p>
</blockquote>
<ul>
<li>正规子群的判定条件
<ul>
<li>对任何的<span class="math inline">\(g \in G, h \in H\)</span>，有<span class="math inline">\(ghg^{-1} \in H\)</span>，或者说<span class="math inline">\(\forall g \in G, gHg^{-1} \subseteq H\)</span></li>
<li>当<span class="math inline">\(a, b \in G\)</span>时，<span class="math inline">\(\exists c, s.t. (aH)(bH) = cH\)</span></li>
</ul></li>
</ul>
<h4 id="正规核">正规核</h4>
<blockquote>
<p>设<span class="math inline">\(H \leq G\)</span>，则<span class="math inline">\(H_G = \bigcap_{g \in G} gHg^{-1}\)</span>是被包含在<span class="math inline">\(H\)</span>中的<span class="math inline">\(G\)</span>的最大正规子群，称为<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中的正规核</p>
</blockquote>
<h4 id="正规子群的交">正规子群的交</h4>
<blockquote>
<p>对集合<span class="math inline">\(I \neq \emptyset\)</span>，如果<span class="math inline">\(H_i \lhd G (i \in I)\)</span>，那么<span class="math inline">\(H = \bigcap_{i \in I} H_i \lhd G\)</span></p>
</blockquote>
<ul>
<li><p><span class="math inline">\(H \leq K \leq G\)</span>时，<span class="math inline">\(H \lhd G \Rightarrow H \lhd K\)</span></p>
<p>在更小的范围内，正规子群仍然是正规子群</p></li>
<li><p><span class="math inline">\(H \lhd G\)</span>且<span class="math inline">\(K \leq G\)</span>时，<span class="math inline">\(HK=KH \leq G\)</span></p>
<p><span class="math inline">\(HK=KH\)</span>可以利用<span class="math inline">\(H\)</span>的正规性得到，而是子群则因为子群的乘积成子群的判定条件</p></li>
</ul>
<h4 id="商群">商群</h4>
<blockquote>
<p>设<span class="math inline">\(H\)</span>为群<span class="math inline">\(G\)</span>的正规子群，那么</p>
<p><span class="math display">\[G/H = \{gH:g\in G\}\]</span></p>
<p>按照陪集的乘法形成群，称为按正规子群<span class="math inline">\(H\)</span>形成的商群</p>
</blockquote>
<h4 id="同态">同态</h4>
<blockquote>
<p>设<span class="math inline">\(\sigma : G \to \bar{G}\)</span>，并且<span class="math inline">\(\forall a, b \in G\)</span>，有</p>
<p><span class="math display">\[\sigma(ab) = \sigma(a)\sigma(b)\]</span></p>
<p>称<span class="math inline">\(\sigma\)</span>是群<span class="math inline">\(G\)</span>到<span class="math inline">\(\bar{G}\)</span>的同态</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(\text{Im} \sigma = \sigma(G) = \{\sigma(a) : a\in G\}\)</span>，称为同态像</p></li>
<li><p><span class="math inline">\(\text{Ker} \sigma = \sigma^{-1}(\bar{e}) = \{a \in G: \sigma(a) = \bar{e}\}\)</span>，称为同态核</p></li>
<li><p><span class="math inline">\(\sigma(e) = \bar{e}\)</span></p></li>
<li><p><span class="math inline">\(\sigma(a^{-1}) = \sigma(a)^{-1}\)</span></p></li>
</ul>
<h4 id="自然同态">自然同态</h4>
<blockquote>
<p>设<span class="math inline">\(H \lhd G\)</span>，令<span class="math inline">\(\sigma(a) = aH\)</span>，那么<span class="math inline">\(\sigma\)</span>是群<span class="math inline">\(G\)</span>到商群<span class="math inline">\(G/H\)</span>的同态，称为<span class="math inline">\(G\)</span>到<span class="math inline">\(G/H\)</span>的自然同态</p>
</blockquote>
<p>自然同态满足</p>
<ul>
<li><span class="math inline">\(\text{Im} \sigma = G/H\)</span>，<span class="math inline">\(\text{Ker} \sigma = H\)</span></li>
</ul>
<h4 id="同构">同构</h4>
<blockquote>
<p>如果同态<span class="math inline">\(\sigma\)</span>是一个满射，那么称为满同态</p>
<p>如果同态<span class="math inline">\(\sigma\)</span>是一个单射，那么称为单同态</p>
<p>如果同态<span class="math inline">\(\sigma\)</span>是一个双射，那么我们称为同构，记为<span class="math inline">\(G \cong \bar{G}\)</span></p>
</blockquote>
<h3 id="week3">week3</h3>
<h4 id="同态基本定理">同态基本定理</h4>
<blockquote>
<p>设<span class="math inline">\(\sigma\)</span>是<span class="math inline">\(G\)</span>到<span class="math inline">\(\bar{G}\)</span>的同态，那么</p>
<ul>
<li><span class="math inline">\(\text{Ker} \sigma \lhd G\)</span></li>
<li><span class="math inline">\(\text{Im} \sigma \leq \bar{G}\)</span></li>
<li><span class="math inline">\(G/\text{Ker} \sigma \cong \text{Im} \sigma\)</span></li>
</ul>
</blockquote>
<h4 id="自同构">自同构</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，<span class="math inline">\(G\)</span>到<span class="math inline">\(G\)</span>的同构称为<span class="math inline">\(G\)</span>的自同构</p>
<p><span class="math inline">\(G\)</span>的所有自同构的集合构成对称群<span class="math inline">\(S(G)\)</span>的一个子群，称为自同构群<span class="math inline">\(\text{Aut} (G)\)</span></p>
</blockquote>
<ul>
<li><p>自同构群中的单位元是恒等变换<span class="math inline">\(I_G\)</span></p></li>
<li><p><span class="math inline">\(\sigma_g(x) = gxg^{-1} \in \text{Aut}(G)\)</span>，因此共轭变换一定是一种自同构</p></li>
</ul>
<h4 id="内自同构">内自同构</h4>
<blockquote>
<p>所有的共轭变换构成群称为内自同构群，记为<span class="math inline">\(\text{Inn}(G)\)</span></p>
<ul>
<li><span class="math inline">\(\text{Inn}(G) \lhd \text{Aut}(G)\)</span></li>
</ul>
</blockquote>
<p>自同构群内所有不是自同构的同构，称为外同构</p>
<h4 id="中心">中心</h4>
<blockquote>
<p>称<span class="math inline">\(Z(G) = \{a\in G:\forall x \in G, ax = xa\}\)</span>为群的中心，<span class="math inline">\(Z(G) \lhd G\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(G/Z(G) \cong \text{Inn}(G)\)</span>
<ul>
<li>定义映射为<span class="math inline">\(f(a) = \sigma_a\)</span>，这是一个同态，同态核为<span class="math inline">\(Z(G)\)</span>，同态像为<span class="math inline">\(\text{Inn}(G)\)</span></li>
</ul></li>
</ul>
<h4 id="群在集合上的作用">群在集合上的作用</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，<span class="math inline">\(X\)</span>为非空集，如果<span class="math inline">\(\forall g \in G, x \in X\)</span>，存在唯一的<span class="math inline">\(X\)</span>中元与之对应（记为<span class="math inline">\(g * x\)</span>），并且</p>
<ul>
<li><span class="math inline">\(\forall x \in X, e*x=x\)</span></li>
<li><span class="math inline">\(\forall a, b \in G,x\in X, ab * x=a*(b*x)\)</span></li>
</ul>
<p>那么说群<span class="math inline">\(G\)</span>（左）作用在集合<span class="math inline">\(X\)</span>上，<span class="math inline">\(*\)</span>为群<span class="math inline">\(G\)</span>在<span class="math inline">\(X\)</span>上的作用</p>
<p><span class="math inline">\(g*x\)</span>有时可以简写为<span class="math inline">\(gx\)</span></p>
</blockquote>
<ul>
<li>也可以定义右作用，但通过定义左作用<span class="math inline">\(g*x\)</span>为给定右作用运算<span class="math inline">\(x*g^{-1}\)</span>的结果，可以将右作用转化为左作用</li>
</ul>
<h4 id="轨道">轨道</h4>
<blockquote>
<p>定义关系<span class="math inline">\(x \sim y\)</span>，<span class="math inline">\(\exists g \in G, gx = y\)</span></p>
<ul>
<li>关系<span class="math inline">\(x \sim y\)</span>是一个等价关系</li>
</ul>
<p>定义<span class="math inline">\(O_x = \{y \in X : x \sim y\} = \{gx:g\in G\}\)</span>，称为<span class="math inline">\(x\)</span>所在的轨道</p>
<ul>
<li><span class="math inline">\(O_x\)</span>就是<span class="math inline">\(x\)</span>所在的按照<span class="math inline">\(\sim\)</span>划分的等价类</li>
</ul>
</blockquote>
<h4 id="稳定化子">稳定化子</h4>
<blockquote>
<p><span class="math inline">\(\text{Stab}(x) = \{g\in G:gx=x\}\)</span>称为<span class="math inline">\(x\)</span>的稳定化子</p>
</blockquote>
<h4 id="作用核">作用核</h4>
<blockquote>
<p><span class="math inline">\(\text{Ker}(X) = \{g \in G :\forall x \in X, gx = x\}\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(\text{Ker(X)} = \bigcap_{x \in X} \text{Stab}(x)\)</span></li>
</ul>
<h4 id="轨道-稳定化子定理">轨道-稳定化子定理</h4>
<p>一个被名词堆起来的定理</p>
<blockquote>
<p>设<span class="math inline">\(G\)</span>作用在非空集<span class="math inline">\(X\)</span>上，那么</p>
<ul>
<li><span class="math inline">\(\text{Stab}(x) \leq G\)</span></li>
<li><span class="math inline">\([G:\text{Stab}(x)] = |O_x|\)</span></li>
</ul>
</blockquote>
<p>证明时，考虑映射<span class="math inline">\(f(gx) = g *\text{Stab}(x)\)</span></p>
<h4 id="嵌入">嵌入</h4>
<blockquote>
<p>如果<span class="math inline">\(G\)</span>和<span class="math inline">\(\bar{G}\)</span>的一个子群同构，那么我们称<span class="math inline">\(G\)</span>可嵌入到<span class="math inline">\(\bar{G}\)</span>中</p>
</blockquote>
<ul>
<li>设群<span class="math inline">\(G\)</span>作用在集合<span class="math inline">\(X\)</span>上，那么<span class="math inline">\(\text{Ker}(X) \lhd G\)</span>，并且<span class="math inline">\(G/\text{Ker}(X)\)</span>可嵌入到对称群<span class="math inline">\(S(X)\)</span>中
<ul>
<li>考虑映射<span class="math inline">\(\sigma_g(x) = gx\)</span>，可以证明<span class="math inline">\(\sigma_g(x) \in S(X)\)</span>，考虑映射<span class="math inline">\(f(g) = \sigma_g\)</span>，这就是一个从<span class="math inline">\(G\)</span>到<span class="math inline">\(S(X)\)</span>的同态</li>
</ul></li>
</ul>
<h4 id="cayley定理">Cayley定理</h4>
<blockquote>
<p>群<span class="math inline">\(G\)</span>可嵌入到对称群<span class="math inline">\(S(G)\)</span>中</p>
</blockquote>
<h3 id="week4">week4</h3>
<h4 id="共轭">共轭</h4>
<blockquote>
<p>所有的共轭变换可以看成是一种<span class="math inline">\(G\)</span>到<span class="math inline">\(G\)</span>的作用，称为<strong>共轭作用</strong></p>
<p>在共轭作用下，<span class="math inline">\(x\)</span>所在的轨道，称为<span class="math inline">\(x\)</span>所在的共轭类<span class="math inline">\(C(x) = \{gxg^{-1}:g\in G\}\)</span></p>
</blockquote>
<h4 id="中心化子">中心化子</h4>
<blockquote>
<p>称<span class="math inline">\(C_G(x) = \{g \in G : gx = xg\}\)</span>为<span class="math inline">\(x\)</span>的中心化子</p>
</blockquote>
<ul>
<li><span class="math inline">\(C_G(x) \leq G\)</span>（共轭作用下<span class="math inline">\(x\)</span>的稳定化子）</li>
<li><span class="math inline">\([G:C_G(x)] = |C(x)|\)</span>（<span class="math inline">\(C(x)\)</span>即轨道的大小）</li>
</ul>
<h4 id="陪集的群作用">陪集的群作用</h4>
<blockquote>
<p>对<span class="math inline">\(H \leqslant G\)</span>，记<span class="math inline">\(X = \{xH:x\in G\}\)</span>，定义<span class="math inline">\(G\)</span>在<span class="math inline">\(X\)</span>上的作用<span class="math inline">\(g * xH = gxH\)</span></p>
</blockquote>
<ul>
<li>此时，<span class="math inline">\(Ker(X) = H_G = \bigcap xHx^{-1}\)</span></li>
<li>因此<span class="math inline">\(G / H_G\)</span>可嵌入到<span class="math inline">\(S(X)\)</span>中</li>
</ul>
<h4 id="p相关的定理">p相关的定理</h4>
<blockquote>
<p>设<span class="math inline">\(H \leqslant G\)</span>，且<span class="math inline">\([G:H]\)</span>是<span class="math inline">\(|G|\)</span>的最小素因子<span class="math inline">\(p\)</span>，那么<span class="math inline">\(H \lhd G\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(G/H_G\)</span>可嵌入到<span class="math inline">\(S(X)\)</span>中，而<span class="math inline">\(|S(X)| = [G:H]!\)</span>，因此<span class="math inline">\(|G/H_G| \mid [G:H]!\)</span>，又<span class="math inline">\([G/H_G] = [G/H] * [H/H_G]\)</span>，因此<span class="math inline">\([H/H_G] \mid ([G:H]-1)! = (p-1)!\)</span>，又<span class="math inline">\(|H/H_G| \mid |H|\)</span>，从而<span class="math inline">\(|H/H_G| \mid |G|\)</span>，从而证明<span class="math inline">\(|H/H_G| = 1\)</span></li>
<li>证明正规，可以尝试证明<span class="math inline">\(|H/H_G| = 1\)</span></li>
</ul>
<h4 id="不动点">不动点</h4>
<blockquote>
<p>记<span class="math inline">\(Fix(g) = \{x\in X:gx=x\}\)</span>，称为<span class="math inline">\(g-\)</span>不动点</p>
<p>再记<span class="math inline">\(Fix(G) = \bigcap_{g \in G} Fix(g)\)</span>，称为其中的元素为不动点</p>
</blockquote>
<h4 id="burnside引理">Burnside引理</h4>
<blockquote>
<p>设有限群<span class="math inline">\(G\)</span>作用在有限非空集<span class="math inline">\(X\)</span>上有<span class="math inline">\(N\)</span>个不同的轨道，那么</p>
<p><span class="math display">\[N = \frac{1}{|G|} \sum_{g\in G} |Fix(g)|\]</span></p>
</blockquote>
<ul>
<li>双计数，计算<span class="math inline">\(\{(g, x):g\in G, x \in X, gx = x\}\)</span>的个数</li>
</ul>
<h4 id="不动点定理">不动点定理</h4>
<blockquote>
<p>设有限群<span class="math inline">\(G\)</span>作用在有限非空集<span class="math inline">\(X\)</span>上，则<span class="math inline">\(X\)</span>中非不动点个数可以表示为<span class="math inline">\(|G|\)</span>的一些大于<span class="math inline">\(1\)</span>的因子之和</p>
</blockquote>
<ul>
<li>考虑类方程<span class="math inline">\(|X| = \sum |O_x|\)</span>，而<span class="math inline">\(|O_x| = [G:\text{Stab}(x)]\)</span></li>
</ul>
<h4 id="p-群">p-群</h4>
<blockquote>
<p>对于素数<span class="math inline">\(p\)</span>及自然数<span class="math inline">\(n\)</span>，阶为<span class="math inline">\(p^n\)</span>的群称为<span class="math inline">\(p-\)</span>群</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(p-\)</span>群<span class="math inline">\(G\)</span>作用在<span class="math inline">\(X\)</span>上时，那么<span class="math inline">\(|X| \equiv |Fix(G)|(mod\;p)\)</span>，特别的，当<span class="math inline">\(p \nmid |X|\)</span>时，<span class="math inline">\(X\)</span>中一定存在不动点</p></li>
<li><p><span class="math inline">\(p-\)</span>群<span class="math inline">\(G\)</span>一定有非平凡的中心，也即<span class="math inline">\(Z(G)\)</span>中一定有非单位元</p></li>
<li><p><span class="math inline">\(p^2\)</span>阶群<span class="math inline">\(G\)</span>一定是Abel群</p>
<ul>
<li>尝试证明<span class="math inline">\(Z(G) = G\)</span>，由上，只需证明<span class="math inline">\(Z(G) \neq p\)</span>即可，而<span class="math inline">\(Z(G)=p\)</span>时，<span class="math inline">\(G/Z(G)\)</span>中将有生成元<span class="math inline">\(aZ(G)\)</span>，用<span class="math inline">\(aZ(G)\)</span>表示<span class="math inline">\(G\)</span>中的元素，来证明他们可交换吧!</li>
</ul></li>
</ul>
<h4 id="正规化子">正规化子</h4>
<blockquote>
<p>设<span class="math inline">\(H \leqslant G\)</span>，那么<span class="math inline">\(N_G(H) = \{g \in G : gH = Hg\}\)</span>称为<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中的正规化子</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(N_G(H)\)</span>是使得<span class="math inline">\(H\)</span>在其中正规的<span class="math inline">\(G\)</span>的最大子群（若<span class="math inline">\(H \lhd K\)</span>，那么<span class="math inline">\(K \leqslant N_G(H)\)</span>）</p></li>
<li><p><span class="math inline">\([G:N_G(H)] = |\{gHg^{-1} : g\in G\}|\)</span></p>
<ul>
<li>定义群作用<span class="math inline">\(G\)</span>作用在<span class="math inline">\(\{aHa^{-1}:a\in G\}\)</span>上，<span class="math inline">\(g*aHa^{-1} = (ga)H(ga)^{-1}\)</span>，右边是<span class="math inline">\(O_H\)</span>，<span class="math inline">\(N_G(H)\)</span>是<span class="math inline">\(\text{Stab}(H)\)</span></li>
</ul></li>
</ul>
<h3 id="week5">week5</h3>
<h4 id="西罗p-子群">西罗p-子群</h4>
<blockquote>
<p>对于有限群<span class="math inline">\(G\)</span>和素数<span class="math inline">\(p\)</span>，如果<span class="math inline">\(G=p^a * m\)</span>，其中<span class="math inline">\(p\nmid m\)</span>，那么大小为<span class="math inline">\(p^a\)</span>的<span class="math inline">\(G\)</span>的子群称为西罗p-子群</p>
</blockquote>
<ul>
<li>如果<span class="math inline">\(P \leqslant H \leqslant G\)</span>，且<span class="math inline">\(P\)</span>是<span class="math inline">\(G\)</span>的西罗p-子群，那么<span class="math inline">\(P\)</span>也是<span class="math inline">\(H\)</span>的西罗p-子群</li>
</ul>
<h4 id="西罗第一定理">西罗第一定理</h4>
<blockquote>
<p>有限群<span class="math inline">\(G\)</span>一定存在西罗p-子群</p>
</blockquote>
<p>设<span class="math inline">\(n = p^a * b\)</span>，证明时，考虑群<span class="math inline">\(G\)</span>作用在集合<span class="math inline">\(X = \{S \subseteq G : |S| = p^a\}\)</span></p>
<p>首先，注意到<span class="math inline">\(p \nmid |X|\)</span>；其次，注意到<span class="math inline">\(|X| = \sum |O_x|\)</span>，因此存在<span class="math inline">\(x\)</span>，使<span class="math inline">\(p \nmid O_x\)</span></p>
<p>任取<span class="math inline">\(S \in O_x\)</span>，那么<span class="math inline">\(H=\text{Stab} (S) \leqslant G\)</span>，并且<span class="math inline">\([G:H] = |O_x|\)</span>，因此<span class="math inline">\(p \nmid [G:H]\)</span></p>
<p>由于<span class="math inline">\(|G|=[G:H]*|H|\)</span>，因此<span class="math inline">\(p^a | \;|H|\)</span>，故<span class="math inline">\(|H| \geq p^a\)</span></p>
<p>同时，取<span class="math inline">\(s \in S, h \in H\)</span>，有<span class="math inline">\(hs \in hS=S\)</span>，从而<span class="math inline">\(Hs \subseteq S\)</span>，那么<span class="math inline">\(|H|=|Hs| \leqslant |S| = p^a\)</span></p>
<h4 id="西罗第二定理">西罗第二定理</h4>
<blockquote>
<p>设<span class="math inline">\(P\)</span>为有限群<span class="math inline">\(G\)</span>的任意一个西罗p-子群，那么<span class="math inline">\(G\)</span>的任意一个西罗p-子群<span class="math inline">\(P&#39;\)</span>都被包含在<span class="math inline">\(G\)</span>的某个与<span class="math inline">\(P\)</span>的共轭的子群中。特别的，<span class="math inline">\(G\)</span>的所有西罗p-子群形成一个子群共轭类。</p>
</blockquote>
<p>考虑将<span class="math inline">\(P&#39;\)</span>作用在集合<span class="math inline">\(X = \{gP:g \in G\}\)</span>上，由于此时是p-群作用，并且<span class="math inline">\(p\nmid|X|=|G|/|P|\)</span>，那么存在着不动点<span class="math inline">\(gP\)</span></p>
<p>对这个不动点进行考虑，<span class="math inline">\(\forall x \in P&#39;, xgP = gP\)</span>，因此<span class="math inline">\(x \in gPg^{-1}\)</span>，因此<span class="math inline">\(P&#39; \subseteq gPg^{-1}\)</span></p>
<p>注意到大小的限制，因此对于任意的西罗p-子群<span class="math inline">\(P, P&#39;\)</span>，存在<span class="math inline">\(g \in G\)</span>，使得<span class="math inline">\(P&#39;=gPg^{-1}\)</span></p>
<ul>
<li>推论：设西罗p-子群<span class="math inline">\(P\)</span>，那么<span class="math inline">\(P \lhd G\)</span>的充要条件是<span class="math inline">\(P\)</span>是<span class="math inline">\(G\)</span>中唯一的西罗p-子群</li>
</ul>
<h4 id="西罗第三定理">西罗第三定理</h4>
<blockquote>
<p>设<span class="math inline">\(n = p^a * b(p \nmid b)\)</span>，设<span class="math inline">\(n_p\)</span>表示西罗p-子群的个数，那么</p>
<ul>
<li><span class="math inline">\(n_p \mid b\)</span></li>
<li><span class="math inline">\(n_p \equiv 1(\text{mod} \;p)\)</span></li>
<li>设<span class="math inline">\(P\)</span>为任一个西罗p-子群，那么<span class="math inline">\(n_p = [G:N_G(P)]\)</span></li>
</ul>
</blockquote>
<p>首先是第三条和第二条，由西罗第二定理和前文的结论，<span class="math inline">\(n_p = |\{gPg^{-1} : g \in G\}| = [G:N_G(P)]\)</span></p>
<p>由于<span class="math inline">\(P \leqslant N_G(P) \leqslant G\)</span>，那么<span class="math inline">\([G:P]=[G:N_G(P)]*[N_G(P):P]\)</span>，因此<span class="math inline">\(n_p \mid [G:P]=b\)</span></p>
<p>将群<span class="math inline">\(P\)</span>作用在集合<span class="math inline">\(X = \{gPg^{-1}:g\in G\}\)</span>（所有的西罗p-子群）上，<span class="math inline">\(x*gPg^{-1} = (xg)P(xg)^{-1}\)</span></p>
<p>考虑不动点，如果<span class="math inline">\(x \in P, g \in G\)</span>满足<span class="math inline">\(x * gPg^{-1} = gPg^{-1}\)</span>，那么<span class="math inline">\((g^{-1}xg)P = P(g^{-1}xg)\)</span></p>
<p>因此如果<span class="math inline">\(gPg^{-1} \in X\)</span>构成不动点，那么<span class="math inline">\(g^{-1}Pg \leqslant N_G(P)\)</span></p>
<p>由于<span class="math inline">\(P \leqslant N_G(P) \leqslant G\)</span>，因此<span class="math inline">\(P\)</span>也是<span class="math inline">\(N_G(P)\)</span>的西罗p-子群，并且由正规化子的性质<span class="math inline">\(P \lhd N_G(P)\)</span></p>
<p>那么根据西罗第二定理的推论，<span class="math inline">\(P\)</span>是唯一的不动点，那么<span class="math inline">\(n_p \equiv |X| \equiv |Fix(P)| \equiv 1(\text{mod}\;p)\)</span></p>
<h4 id="frattini引理">Frattini引理</h4>
<blockquote>
<p>设<span class="math inline">\(H\)</span>为群<span class="math inline">\(G\)</span>的有限正规子群，<span class="math inline">\(P\)</span>是<span class="math inline">\(H\)</span>的西罗p-子群，那么<span class="math inline">\(G=HN_G(P)\)</span></p>
</blockquote>
<p>也就是说，一个群可以由正规子群和其西罗p-子群的正规化子相乘来生成</p>
<ul>
<li><blockquote>
<p>设<span class="math inline">\(P\)</span>为<span class="math inline">\(G\)</span>的西罗p-子群，那么<span class="math inline">\(N_G(N_G(P))=N_G(P)\)</span></p>
<p>更一般地，<span class="math inline">\(N_G(P) \leqslant H \leqslant G\)</span>时，<span class="math inline">\(N_G(H)=H\)</span></p>
</blockquote></li>
</ul>
<h4 id="西罗定理的应用">西罗定理的应用</h4>
<ul>
<li>设<span class="math inline">\(p, q\)</span>为不同素数，并且<span class="math inline">\(p \not \equiv 1 (mod\;q), q \not\equiv 1(mod\;p)\)</span>，那么<span class="math inline">\(pq\)</span>阶群为循环群</li>
<li>设<span class="math inline">\(p,q\)</span>为不同素数，<span class="math inline">\(G\)</span>为<span class="math inline">\(p^2q\)</span>阶群，那么<span class="math inline">\(G\)</span>有<span class="math inline">\(p^2\)</span>阶或<span class="math inline">\(q\)</span>阶正规子群</li>
<li>设<span class="math inline">\(p,q,r\)</span>为不同素数，对<span class="math inline">\(pqr\)</span>阶群<span class="math inline">\(G\)</span>，满足<span class="math inline">\(G\)</span>有<span class="math inline">\(p\)</span>阶或<span class="math inline">\(q\)</span>阶或<span class="math inline">\(r\)</span>阶的正规子群</li>
</ul>
<h4 id="单群">单群</h4>
<blockquote>
<p>对不平凡的群<span class="math inline">\(G(G \neq \{e\})\)</span>，如果<span class="math inline">\(G\)</span>中没有异于<span class="math inline">\(\{e\}\)</span>和<span class="math inline">\(G\)</span>的正规子群，那么我们称<span class="math inline">\(G\)</span>为单群</p>
</blockquote>
<ul>
<li>Abel单群一定是素数阶循环群</li>
</ul>
<h4 id="同构定理-第一同构定理">同构定理 / 第一同构定理</h4>
<blockquote>
<p>设<span class="math inline">\(\sigma\)</span>为群<span class="math inline">\(G\)</span>到<span class="math inline">\(G^*\)</span>的同态，那么</p>
<ul>
<li><p><span class="math inline">\(G\)</span>中包含<span class="math inline">\(\ker \sigma\)</span>的子群和<span class="math inline">\(\sigma(G)\)</span>的子群之间存在一一对应关系<span class="math inline">\(H \to \sigma(H)\)</span></p>
<p><span class="math inline">\(\{H \leq G:\ker \sigma \subseteq H\}\)</span>和<span class="math inline">\(\{M:M\leq \sigma(G)\}\)</span>之间存在一一对应</p></li>
<li><p>如果<span class="math inline">\(\ker \sigma \subseteq H\)</span>，<span class="math inline">\(H \leq G \Rightarrow \sigma(H) \leq \sigma(G)\)</span></p></li>
<li><p>如果<span class="math inline">\(\ker \sigma \subseteq H, H \leq G\)</span>，那么<span class="math inline">\(H \lhd G \Leftrightarrow \sigma(H) \lhd \sigma(G)\)</span></p></li>
<li><p>如果<span class="math inline">\(\ker \sigma \subseteq H\)</span>，<span class="math inline">\(H \lhd G\)</span>，那么<span class="math inline">\(G/H \cong \sigma(G)/\sigma(H)\)</span></p></li>
</ul>
</blockquote>
<p>证明的一些简略提示：<span class="math inline">\(\sigma(a) \in \sigma(H) \Leftrightarrow a \in H\)</span></p>
<p>那么<span class="math inline">\(H = \{a:a \in H\} = \{a:\sigma(a) \in \sigma(H)\}\)</span>，利用该性质，可以推出映射为单射，满射容易验证</p>
<p>对于第二条，<span class="math inline">\(\sigma(a)\sigma(b)^{-1} = \sigma(ab^{-1}) \in \sigma(H)\)</span>可以验证</p>
<p>对于第三条，<span class="math inline">\(ghg^{-1} \in H \Leftrightarrow \sigma(g)\sigma(h)\sigma(g^{-1}) \in \sigma(H)\)</span></p>
<p>最后一条，考虑映射<span class="math inline">\(f(aH) = \sigma(a)\sigma(H)\)</span>即可</p>
<h4 id="同构定理补充">同构定理补充</h4>
<p>这里上课没讲，但我感觉很有用</p>
<blockquote>
<p>我们不妨定义<span class="math inline">\(\sigma^{-1}(H^*) =\{g \in G: \sigma(g) \in H^*\}\)</span></p>
</blockquote>
<ul>
<li><p>如果<span class="math inline">\(\ker \sigma \subseteq H\)</span>，那么<span class="math inline">\(\sigma^{-1}(\sigma(H)) = H\)</span></p>
<p><span class="math inline">\(H \subseteq \sigma^{-1}(\sigma(H))\)</span>易证，考虑证明另一个方向</p>
<p><span class="math inline">\(x \in \sigma^{-1}(\sigma(H)) \Leftrightarrow \exists h \in H, \sigma(x)=\sigma(h) \Leftrightarrow \exists h \in H,\sigma(xh^{-1}) = e^* \Leftrightarrow x \in (\ker \sigma) H=H\)</span></p></li>
<li><p>根据第一同构定理，上面的定理还可以写为，如果<span class="math inline">\(H^* \leq G^*\)</span>，那么<span class="math inline">\(\ker \sigma \leq \sigma^{-1}(H^*) \leq G\)</span></p></li>
<li><p>如果<span class="math inline">\(H^* \leq K^* \leq G^*\)</span>，那么<span class="math inline">\(\sigma^{-1}(H^*) \leq \sigma^{-1}(K^*) \leq \sigma^{-1}(G^*) = G\)</span></p></li>
</ul>
<h4 id="第一同构定理-第二同构定理-第三同构定理">第一同构定理 / 第二同构定理 / 第三同构定理</h4>
<blockquote>
<p>设<span class="math inline">\(K \lhd G\)</span>，那么</p>
<ul>
<li><span class="math inline">\(G\)</span>中包含<span class="math inline">\(K\)</span>的子群和<span class="math inline">\(G/K\)</span>的子群之间存在一一对应关系<span class="math inline">\(H \to H/K\)</span></li>
<li>如果<span class="math inline">\(K\subseteq H\)</span>，<span class="math inline">\(H \leq G \Rightarrow H/K \leq G/K\)</span></li>
<li>如果<span class="math inline">\(K \subseteq H, H \leq G\)</span>，那么<span class="math inline">\(H \lhd G \Leftrightarrow H/K \lhd G/K\)</span></li>
<li>如果<span class="math inline">\(K\subseteq H\)</span>，<span class="math inline">\(H \lhd G\)</span>，那么<span class="math inline">\(G/H \cong (G/K)/(H/K)\)</span></li>
</ul>
</blockquote>
<p>我们考虑从<span class="math inline">\(G\)</span>到<span class="math inline">\(G/K\)</span>的自然同态<span class="math inline">\(\sigma\)</span>，只需要证明<span class="math inline">\(\ker \sigma = K, \sigma(G)=G/K, \sigma(H)=H/K\)</span>即可</p>
<p>我们只考虑最后一个，即<span class="math inline">\(\sigma(H)=\{hK:h\in H\} = H/K\)</span></p>
<h3 id="week6">week6</h3>
<p>有些地方会指明<span class="math inline">\(\lhd\)</span>不含相等的情况，但本文中默认可以相等，如果需要指代不相等时，作特殊说明</p>
<h4 id="galois定理">Galois定理</h4>
<blockquote>
<p>设<span class="math inline">\(p\)</span>为素数，那么对p-群<span class="math inline">\(G\)</span>，对于<span class="math inline">\(i = 0,...,n\)</span>，存在<span class="math inline">\(G\)</span>的<span class="math inline">\(p^i\)</span>阶的正规子群<span class="math inline">\(H_i\)</span>，使得</p>
<p><span class="math display">\[\{e\} = H_0 \lhd H_1 ... \lhd H_n = G\]</span></p>
</blockquote>
<p>证明时，注意到条件等价于<span class="math inline">\(H_0 \subseteq H_1 ... \subseteq H_n = G\)</span></p>
<p>之后归纳，对阶为<span class="math inline">\(p\)</span>的群<span class="math inline">\(H\)</span>，考虑其商群<span class="math inline">\(G^* = G/H\)</span>形成的正规子群列<span class="math inline">\(G_0^*, G_1^*,...,G^*\)</span>，按照之前的同构定理的结论，如果<span class="math inline">\(G_i^* \subset G_{i+1}^*\)</span>，那么<span class="math inline">\(\sigma^{-1}(G_i^*)\subset \sigma^{-1}(G_{i+1}^*)\)</span>，设出<span class="math inline">\(\sigma^{-1}(G_i^*)\)</span>就差不多证完了</p>
<h4 id="第二同构定理-第三同构定理-第四同构定理">第二同构定理 / 第三同构定理 / 第四同构定理</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群、，<span class="math inline">\(H \lhd G\)</span>且<span class="math inline">\(K \leq G\)</span>，那么<span class="math inline">\(H\cap K \lhd K\)</span>，并且<span class="math inline">\(K/(H \cap K) \cong HK/H\)</span></p>
</blockquote>
<p>设出同构<span class="math inline">\(\sigma(k) = kH(K \to G/H)\)</span>，然后证明<span class="math inline">\(\ker \sigma = H \cap K\)</span>，<span class="math inline">\(\Im \sigma = HK/H\)</span></p>
<ul>
<li><p>设<span class="math inline">\(H\lhd G\)</span>，且<span class="math inline">\([G:H]\)</span>有限，那么对<span class="math inline">\(K \leq G\)</span>，有<span class="math inline">\([K:H\cap K] \mid [G:H]\)</span></p>
<p>这个定理是老师的私货...</p>
<p>由第二同态定理，<span class="math inline">\(K/(H\cap K) = HK / H\)</span>，因此<span class="math inline">\([K:H \cap K] = |HK/H|\)</span></p>
<p>此时，<span class="math inline">\(HK=KH\)</span>构成一个子群，且<span class="math inline">\(H \subseteq HK\)</span>，由第一同态定理和Lagrange定理，因此<span class="math inline">\([HK/H] \mid [G/H]\)</span></p></li>
</ul>
<h4 id="次正规子群">次正规子群</h4>
<p>由于正规性并不满足传递性，因此我们考虑研究一种和正规性差不多，但具有传递性的玩意</p>
<blockquote>
<p>设<span class="math inline">\(H \leq G\)</span>，那么称<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中次正规，当且仅当存在有限个子群<span class="math inline">\(H_0,...,H_n\)</span>，使得</p>
<p><span class="math display">\[H=H_0 \lhd H_1 \lhd H_2 ... \lhd H_n = G\]</span></p>
</blockquote>
<ul>
<li><p>如果<span class="math inline">\(H\)</span>在<span class="math inline">\(K\)</span>中次正规，<span class="math inline">\(K\)</span>在<span class="math inline">\(G\)</span>中次正规，那么<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中次正规</p></li>
<li><blockquote>
<p>设<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中次正规，那么</p>
<ul>
<li>对<span class="math inline">\(K \leq G\)</span>，<span class="math inline">\(H \cap K\)</span>在<span class="math inline">\(K\)</span>中次正规</li>
<li>对<span class="math inline">\(K \leq G\)</span>，如果<span class="math inline">\([G:H]\)</span>有限，有<span class="math inline">\([K:H\cap K] \mid [G:H]\)</span></li>
</ul>
</blockquote>
<p>不难看出，这个性质是上面性质的一个加强</p>
<p>在次正规的情况下进行证明，可以利用性质<span class="math inline">\([H_{i+1} \cap K: H_i \cap K] \mid [H_{i+1} : H_i]\)</span>（在第二同态定理中，令<span class="math inline">\(G = H_{i+1}, H = H_i, K = H_{i+1} \cap K\)</span>）</p></li>
<li><blockquote>
<p>设<span class="math inline">\(H_1,...,H_k\)</span>为群<span class="math inline">\(G\)</span>的次正规子群，那么<span class="math inline">\(\bigcap_{i=1}^k H_i\)</span>也是<span class="math inline">\(G\)</span>的次正规子群</p>
<p>如果<span class="math inline">\(\forall 1 \leq i \leq k, [G:H_i]\)</span>有限，那么<span class="math inline">\([G:\bigcap_{i=1}^k H_i] \mid \prod_{i=1}^k [G:H_i]\)</span></p>
</blockquote>
<p>利用上一条性质，归纳证明</p></li>
</ul>
<h4 id="正规群列">正规群列</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，称满足<span class="math inline">\(\{e\} = G_0 \lhd G_1 \lhd ... \lhd G_n=G\)</span>，并且<span class="math inline">\(G_i\)</span>两两不同的子群列为<strong>正规群列</strong></p>
<p><span class="math inline">\(n\)</span>称为正规群列的长度</p>
<p>称<span class="math inline">\(G_1/G_0, G_2/G_1..., G_n/G_{n-1}\)</span>为该正规群列相应的<strong>商群列</strong></p>
</blockquote>
<h4 id="正规群列的等价">正规群列的等价</h4>
<blockquote>
<p>称<span class="math inline">\(G\)</span>的两个正规群列<span class="math inline">\(G_0 \lhd G_1 ... \lhd G_n\)</span>和<span class="math inline">\(H_0 \lhd H_1 ... \lhd H_m\)</span>等价，当且仅当</p>
<ul>
<li><span class="math inline">\(n = m\)</span></li>
<li>存在长为<span class="math inline">\(n\)</span>的置换<span class="math inline">\(\sigma\)</span>，使得<span class="math inline">\(\forall i, G_i / G_{i-1} \cong H_{\sigma(i)} / H_{\sigma(i-1)}\)</span></li>
</ul>
</blockquote>
<p>注意定义中的商群列需要调顺序，这个道理跟<span class="math inline">\(6=2*3=3*2\)</span>这两种分解等价差不多</p>
<h4 id="正规群列的加细合成群列">正规群列的加细，合成群列</h4>
<blockquote>
<p>对正规群列<span class="math inline">\(G_0 \lhd G_1 ... \lhd G_n(1)\)</span>和<span class="math inline">\(H_0 \lhd H_1 ... \lhd H_m(2)\)</span>，如果<span class="math inline">\(\{G_0,G_1,...,G_n\} \subseteq \{H_0,H_1,...,H_m\}\)</span>，那么称<span class="math inline">\((2)\)</span>是<span class="math inline">\((1)\)</span>的<strong>加细（细分）</strong></p>
<p>如果一个正规群列没有除了自己以外的加细，则称其为一个<strong>合成群列</strong></p>
</blockquote>
<ul>
<li><p>设<span class="math inline">\(H \lhd G\)</span>，那么<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的极大正规子群，当且仅当<span class="math inline">\(G/H\)</span>为单群</p>
<p>由第一同构定理，<span class="math inline">\(H \leq K \lhd G\)</span>，当且仅当<span class="math inline">\(K/H \lhd G/H\)</span></p></li>
<li><p>正规群列<span class="math inline">\(G_0 \lhd G_1 ... \lhd G_n\)</span>为合成群列，当且仅当<span class="math inline">\(G_1/G_0,...,G_n/G_{n-1}\)</span>为单群</p></li>
<li><p>有限群<span class="math inline">\(G\)</span>一定有合成群列</p></li>
</ul>
<h4 id="jordan-holder定理">Jordan-Holder定理</h4>
<blockquote>
<p>设群<span class="math inline">\(G\)</span>有合成群列，那么</p>
<ul>
<li><span class="math inline">\(G\)</span>中的每个正规群列可以加细成合成群列</li>
<li><span class="math inline">\(G\)</span>中任意两个合成群列等价</li>
</ul>
</blockquote>
<h4 id="换位子">换位子</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，对<span class="math inline">\(x, y \in G\)</span>称<span class="math inline">\([x, y] = (yx)^{-1}xy =x^{-1}y^{-1}xy\)</span>为<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>的换位子</p>
</blockquote>
<ul>
<li><span class="math inline">\([x, y] = e \Leftrightarrow xy = yx\)</span></li>
<li><span class="math inline">\([x,y]^{-1} = [y,x]\)</span></li>
<li><span class="math inline">\(g[x,y]g^{-1} = [gxg^{-1}, gyg^{-1}] = [xg^{-1},y][y,g^{-1}]\)</span></li>
</ul>
<h4 id="导群-换位子群">导群 / 换位子群</h4>
<blockquote>
<p>称所有换位子生成的子群，<span class="math inline">\(\langle [x, y]:x, y \in G \rangle\)</span>，为群<span class="math inline">\(G\)</span>的导群，记为<span class="math inline">\(G&#39;\)</span>，也称为换位子群</p>
</blockquote>
<ul>
<li><span class="math inline">\(G&#39; = \{e\} \Leftrightarrow G\)</span>是Abel群</li>
<li>设<span class="math inline">\(H \lhd G\)</span>，则<span class="math inline">\(H&#39; \lhd G\)</span>
<ul>
<li>只需要证明<span class="math inline">\(gH&#39;g^{-1} \subseteq H&#39;\)</span>，注意到<span class="math inline">\(g[h,k]g^{-1} = [ghg^{-1}, gkg^{-1}] \in H&#39;\)</span>，以及若<span class="math inline">\(x=\prod[h_i, k_i]\)</span>，则<span class="math inline">\(gxg^{-1} = \prod g[h_i, k_i]g^{-1} \in H&#39;\)</span></li>
<li>特别的，如果<span class="math inline">\(H=G\)</span>，那么<span class="math inline">\(G&#39; \lhd G\)</span></li>
</ul></li>
<li>如果<span class="math inline">\(H \leq K\)</span>，那么<span class="math inline">\(H&#39; \leq K&#39;\)</span></li>
</ul>
<h4 id="最小正规子群">最小正规子群</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，则导群<span class="math inline">\(G&#39;\)</span>是使得<span class="math inline">\(G/H\)</span>为Abel群的<span class="math inline">\(G\)</span>的最小正规子群</p>
</blockquote>
<p>即证明，如果<span class="math inline">\(H \lhd G\)</span>且<span class="math inline">\(G/H\)</span>为Abel群，那么<span class="math inline">\(G&#39; \leq H\)</span></p>
<p>考虑<span class="math inline">\(\sigma:G\to G/H\)</span>，群为Abel群，当且仅当<span class="math inline">\(G&#39; \leq \ker \sigma\)</span></p>
<ul>
<li>这个定理也可以表明，如果<span class="math inline">\(H \lhd G\)</span>满足<span class="math inline">\(G&#39; \leq H\)</span>，则<span class="math inline">\(G/H\)</span>为Abel群</li>
<li>特别的，如果<span class="math inline">\(H=G&#39;\)</span>，那么<span class="math inline">\(G/G&#39;\)</span>为Abel群</li>
</ul>
<h4 id="高阶导群">高阶导群</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，记<span class="math inline">\(G^{(0)}=G, G^{(1)}=G&#39;, ..., G^{(n+1)}=(G^{(n)})&#39;\)</span></p>
<p>称<span class="math inline">\(G^{(n)}\)</span>为<span class="math inline">\(G\)</span>的<span class="math inline">\(n\)</span>阶导群</p>
</blockquote>
<ul>
<li><span class="math inline">\(G^{(n)} \lhd G\)</span>，且<span class="math inline">\(H \lhd G\)</span>时，<span class="math inline">\((G/H)^{(n)} = G^{(n)}H/H\)</span>
<ul>
<li>注意到<span class="math inline">\(G^{(n)}H=HG^{(n)}\)</span>，因此<span class="math inline">\(G^{(n)}H\)</span>构成子群，且<span class="math inline">\(H\)</span>在其中正规</li>
<li>证明时，利用归纳法，可以利用<span class="math inline">\(\langle [x,y]H:x, y \in G^{(n)}\rangle = \langle gH:g\in (G^{(n)})&#39;\rangle\)</span></li>
</ul></li>
</ul>
<h4 id="导列">导列</h4>
<blockquote>
<p>称<span class="math inline">\(G = G^{(0)} \rhd G^{(1)} ... \rhd G^{(n)} \rhd ...\)</span>为群<span class="math inline">\(G\)</span>的导列</p>
<p>使得<span class="math inline">\(G^{(n)}=G^{(n+1)}\)</span>的最小自然数<span class="math inline">\(n\)</span>称为<span class="math inline">\(G\)</span>导列的长度</p>
</blockquote>
<h4 id="可解群与abel列">可解群与Abel列</h4>
<blockquote>
<p>如果群<span class="math inline">\(G\)</span>有子群列，使得<span class="math inline">\(G=G_0 \rhd G_1 \rhd ... \rhd G_n = \{e\}\)</span>，且<span class="math inline">\(G_0/G_1, G_1/G_2, ..., G_{n-1}/G_n\)</span>为Abel群，则称<span class="math inline">\(G\)</span>为可解群，并称这样的子群列为Abel列</p>
</blockquote>
<ul>
<li>设<span class="math inline">\(G\)</span>为群，则<span class="math inline">\(G\)</span>为可解群，当且仅当存在<span class="math inline">\(n \in N\)</span>，使得<span class="math inline">\(G^{(n)} = \{e\}\)</span>
<ul>
<li>利用<span class="math inline">\(G/G&#39;\)</span>为Abel群，可以证明一个方向</li>
<li>对于另一个方向，我们证明<span class="math inline">\(G^{(i)} \leq G_i\)</span>，归纳，利用导群的性质即可</li>
</ul></li>
<li>Abel群是可解群</li>
</ul>
<h4 id="可解单群">可解单群</h4>
<blockquote>
<p>可解单群就是素数阶循环群</p>
</blockquote>
<p>注意到<span class="math inline">\(G&#39; \lhd G\)</span>，且<span class="math inline">\(G&#39; \neq G\)</span>，由单群的性质<span class="math inline">\(G&#39;=\{e\}\)</span>，因此<span class="math inline">\(G\)</span>为Abel单群，从而是素数阶循环群</p>
<h4 id="可解群的子群与商群">可解群的子群与商群</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为可解群</p>
<p>如果<span class="math inline">\(H \leq G\)</span>，则<span class="math inline">\(H\)</span>可解</p>
<p>如果<span class="math inline">\(H \lhd G\)</span>，那么<span class="math inline">\(G/H\)</span>也可解</p>
</blockquote>
<p>这也就是说，可解群的子群和商群都是可解的</p>
<ul>
<li><p>从导群的角度出发，利用<span class="math inline">\(H^{(n)} \leq G^{(n)}\)</span>，以及<span class="math inline">\((G/H)^{(n)}=G^{(n)}H/H\)</span>来证明</p></li>
<li><p>我尝试从Abel列的角度出发来证明，这依赖于下面的引理</p>
<ul>
<li><p>设<span class="math inline">\(H, K, L \leq G\)</span>，如果<span class="math inline">\(H \lhd K\)</span>，那么<span class="math inline">\(H \cap L \lhd K \cap L\)</span></p>
<p>条件即<span class="math inline">\(\forall k \in K, k^{-1}Hk \subseteq H\)</span>，要证为<span class="math inline">\(\forall x \in K \cap L, x^{-1}(H \cap L)x \subseteq H \cap L\)</span></p>
<p>由<span class="math inline">\(x \in K\)</span>，得到<span class="math inline">\(x^{-1}(H \cap L)x \subseteq x^{-1}Hx \subseteq H\)</span></p>
<p>由<span class="math inline">\(x \in L\)</span>，得到<span class="math inline">\(x^{-1}(H \cap L)x \subseteq x^{-1}Lx = L\)</span>，从而可以证明上述引理</p></li>
<li><p>设<span class="math inline">\(H, K, L \leq G\)</span>，如果<span class="math inline">\(K/H\)</span>为Abel群，那么<span class="math inline">\((K \cap L)/(H\cap L)\)</span>为Abel群</p>
<p><span class="math inline">\(K/H\)</span>为Abel群等价于<span class="math inline">\(K&#39; \leq H\)</span>，而我们只需要证明<span class="math inline">\((K \cap L)&#39;\leq H \cap L\)</span>即可</p>
<p>对于<span class="math inline">\(x_1, x_2 \in K \cap L\)</span>，我们有<span class="math inline">\([x_1, x_2] \in L\)</span>且<span class="math inline">\([x_1, x_2] \in K&#39; \subseteq H\)</span>从而证毕</p></li>
<li><p>有以上引理后，如果<span class="math inline">\(G\)</span>有Abel列<span class="math inline">\(G_0 \rhd G_1...\rhd G_n = \{e\}\)</span>，那么令<span class="math inline">\(H_i = G_i \cap H\)</span>，则<span class="math inline">\(H = H_0 \rhd H_1 ... \rhd H_n = \{e\}\)</span>，其也构成Abel列，从而<span class="math inline">\(H\)</span>可解</p></li>
<li><p>这是对子群的情况作出的证明，对于商群，令<span class="math inline">\(H_i = HG_i\)</span>，类似的证明</p></li>
</ul></li>
</ul>
<blockquote>
<p>如果<span class="math inline">\(H \lhd G\)</span>，且<span class="math inline">\(H\)</span>与<span class="math inline">\(G/H\)</span>都可解，则<span class="math inline">\(G\)</span>可解</p>
</blockquote>
<p>设<span class="math inline">\(H, G/H\)</span>的Abel列分别为<span class="math inline">\(H_0 \rhd H_1 ... \rhd H_m, G_0/H \rhd G_1/H...\rhd G_n/H\)</span></p>
<p>由第一同构定理，<span class="math inline">\((G_{i}/H)/(G_{i+1}/H) \cong G_i/G_{i+1}\)</span>，那么<span class="math inline">\(G_0 \rhd G_1, ..., \rhd G_n = H\)</span>也构成Abel列，后面再接上<span class="math inline">\(H\)</span>的Abel列即可</p>
<blockquote>
<p>设<span class="math inline">\(H, K \lhd G\)</span>，那么<span class="math inline">\(G/H, G/K\)</span>都可解，当且仅当<span class="math inline">\(G/(H \cap K)\)</span>可解</p>
</blockquote>
<p>"<span class="math inline">\(\Leftarrow\)</span>"：证明<span class="math inline">\(G/H\cong (G/(H \cap K)) / (H/(H \cap K))\)</span></p>
<p>"<span class="math inline">\(\Rightarrow\)</span>"：证明<span class="math inline">\((G/(H \cap K))/(H/(H\cap K)) \cong G/H\)</span>，且<span class="math inline">\(H/(H\cap K) \cong HK/K\)</span></p>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为可解群，有合成群列<span class="math inline">\(G=G_0 \rhd G_1 \rhd ... \rhd G_n = \{e\}\)</span>，那么商群<span class="math inline">\(G_i/G_{i+1}\)</span>都是素数阶循环群</p>
</blockquote>
<p>合成群列的商群为单群，而商群又可解，因此为可解单群，从而为素数阶循环群</p>
<h4 id="对换轮换">对换，轮换</h4>
<blockquote>
<p><span class="math inline">\(\sigma = (a_1, a_2, ..., a_n)\)</span>是一个置换，即<span class="math inline">\(\sigma(a_i) = a_{i+1}(1 \leq i \leq n)\)</span>（补充<span class="math inline">\(a_{n+1}=a_1\)</span>），其余地方则和单位置换一致，这种置换称为轮换</p>
<p>长度为<span class="math inline">\(2\)</span>的轮换称为对换</p>
</blockquote>
<ul>
<li><p>不相交的轮换可以交换</p></li>
<li><p>每一个置换可以写为若干不相交轮换的乘积</p></li>
<li><p>长为<span class="math inline">\(n\)</span>的轮换可以表为<span class="math inline">\(n-1\)</span>个对换的乘积，具体而言<span class="math inline">\((a_1,a_2, ..., a_n)=(a_1a_n)(a_1a_{n-1})...(a_1a_2)\)</span></p></li>
</ul>
<h3 id="week7">week7</h3>
<h4 id="置换的奇偶">置换的奇偶</h4>
<blockquote>
<p>对于置换<span class="math inline">\(\sigma\)</span>，定义<span class="math inline">\(N(\sigma) = \sum_{1\leq i&lt;j \leq n} [\sigma(i) &gt;\sigma(j)]\)</span></p>
<p>定义<span class="math inline">\(\text{sgn}(\sigma) = (-1)^{N(\sigma)}\)</span></p>
<p>如果<span class="math inline">\(\text{sgn}(\sigma) = 1\)</span>，则成为偶置换，如果<span class="math inline">\(\text{sgn}(\sigma) = -1\)</span>，则称为奇置换</p>
</blockquote>
<ul>
<li><span class="math inline">\(\prod_{1 \leq i &lt; j \leq n} \text{sgn}(\sigma(j) - \sigma(i)) = (-1)^{N(\sigma)} = \text{sgn} (\sigma)\)</span></li>
</ul>
<blockquote>
<p>一个置换称为奇（偶）排列，当且仅当其能写为奇（偶）个对换的乘积</p>
</blockquote>
<ul>
<li><p>右乘一个对换<span class="math inline">\((k, l) (k &lt; l)\)</span>，讨论<span class="math inline">\(i, j\)</span>和<span class="math inline">\(k, l\)</span>的大小关系，可以知道<span class="math inline">\(\text{sgn}(\sigma)\)</span>变号</p></li>
<li><p><span class="math inline">\(\text{sgn}(\sigma_1 \sigma_2) = \text{sgn}(\sigma_1) \text{sgn}(\sigma_2)\)</span></p></li>
</ul>
<h4 id="交错群">交错群</h4>
<blockquote>
<p>记<span class="math inline">\(A_n = \{\sigma \in S_n : \text{sgn}(\sigma) = 1\}\)</span>，那么</p>
<ul>
<li><span class="math inline">\(A_n \lhd S_n\)</span></li>
<li><span class="math inline">\(S_n / A_n \cong \{\pm1\}\)</span></li>
</ul>
</blockquote>
<p>考虑同态<span class="math inline">\(\phi(\sigma) = \text{sgn}(\sigma)\)</span>，那么<span class="math inline">\(\ker \phi = A_n\)</span>, <span class="math inline">\(\text{Im} \phi = \{\pm1\}\)</span></p>
<h4 id="置换群的生成元">置换群的生成元</h4>
<blockquote>
<p><span class="math inline">\(S_n = \langle (1, 2), (1, 2, 3, ..., n)\rangle\)</span></p>
</blockquote>
<ul>
<li>我们按照下面的步骤来证明
<ul>
<li><span class="math inline">\((1, 2)\)</span>和<span class="math inline">\((1, 2, 3, .., n)\)</span>可以生成所有的<span class="math inline">\((i, i + 1)\)</span></li>
<li><span class="math inline">\((i, i+1)\)</span>可以生成所有的<span class="math inline">\((1, i)\)</span></li>
<li><span class="math inline">\((1, i)\)</span>可以生成所有的轮换（<span class="math inline">\((i_1, ..., i_m) = (1, i_m)(1, i_{m-1}, ..., (1, i_1)(1, i_m))\)</span>），而轮换可以生成所有的置换</li>
</ul></li>
</ul>
<blockquote>
<p>当<span class="math inline">\(n \geq 5\)</span>时，<span class="math inline">\(A_n = \langle (1, 2, 3), ..., (1, 2, n)\rangle\)</span></p>
</blockquote>
<ul>
<li>所有的<span class="math inline">\((1, i)(1, j)\)</span>可以被上述元素生成，如<span class="math inline">\(i, j &gt; 2\)</span>时，<span class="math inline">\((1, i)(1, j)=(1, 2, i)^{-1}(1, 2, j)(1, 2, i)\)</span></li>
<li><span class="math inline">\(A_n\)</span>中的元素可以表为偶数个含<span class="math inline">\(1\)</span>对换的乘积</li>
</ul>
<h4 id="置换群的可解性">置换群的可解性</h4>
<blockquote>
<p><span class="math inline">\(S_n&#39; = A_n\)</span></p>
</blockquote>
<ul>
<li><p><span class="math inline">\(S_n / A_n \cong \{\pm1\}\)</span>为阿贝尔群，故<span class="math inline">\(S_n&#39; \leq A_n\)</span></p>
<p>任何一个<span class="math inline">\((1, 2, i) = [(1,2),(1,i)] \in S_n&#39;\)</span>，从而<span class="math inline">\(A_n \leq S_n&#39;\)</span></p></li>
</ul>
<blockquote>
<p>当<span class="math inline">\(n \leq 3\)</span>时，<span class="math inline">\(S_n&#39;&#39; = A_n&#39; = \{1\}\)</span></p>
<p>当<span class="math inline">\(n = 4\)</span>时，<span class="math inline">\(S_n&#39;&#39;&#39; = A_n&#39;&#39; = K&#39; = \{1\}\)</span></p>
<p>从而<span class="math inline">\(n \leq 4\)</span>时，<span class="math inline">\(S_n\)</span>都是可解群</p>
</blockquote>
<p>直接验证即可</p>
<blockquote>
<p>(<strong>Galois</strong>) 当<span class="math inline">\(n \geq 5\)</span>时，<span class="math inline">\(S_n\)</span>及<span class="math inline">\(A_n\)</span>不是可解群，并且<span class="math inline">\(A_n\)</span>是一个单群</p>
</blockquote>
<ul>
<li><p>对于前一部分，我们证明<span class="math inline">\(A_n&#39; = A_n\)</span>，而这又只需要注意到任何一个<span class="math inline">\((1, 2, i) = [(1,k,2),(1,j,i)](j, k \neq 1,2,i)\in A_n&#39;\)</span>即可</p></li>
<li><p>单群的证明比较复杂，跳过算了</p></li>
</ul>
<h3 id="week8">week8</h3>
<h4 id="第三同构定理第四同构定理蝴蝶引理">第三同构定理/第四同构定理/蝴蝶引理</h4>
<blockquote>
<p>设<span class="math inline">\(L_1 \lhd H_1 \leq G, L_2 \lhd H_2 \leq G\)</span>，则</p>
<ul>
<li><span class="math inline">\((H_1 \cap L_2)L_1 \lhd (H_1\cap H_2)L_1\)</span></li>
<li><span class="math inline">\((H_2\cap L_1)L_2 \lhd (H_1\cap H_2)L_2\)</span></li>
<li><span class="math inline">\((H_1\cap H_2) L_1 / (H_1\cap L_2)L_1 \cong (H_1\cap H_2) L_2 / (H_2\cap L_1)L_2\)</span></li>
</ul>
</blockquote>
<p>证明比较复杂，这里就列举两个比较关键的引理</p>
<ul>
<li>设<span class="math inline">\(K \leq H \leq G\)</span>，<span class="math inline">\(L \leq G\)</span>，则<span class="math inline">\(H \cap KL = K(H \cap L)\)</span></li>
<li>设<span class="math inline">\(K \lhd H \leq G, L \leq G\)</span>，则
<ul>
<li><span class="math inline">\(K \cap L \lhd H \cap L\)</span>，且<span class="math inline">\((H \cap L) / (K \cap L) \cong K(H\cap L)/K\)</span></li>
<li>若<span class="math inline">\(L \lhd G\)</span>，那么<span class="math inline">\(KL \lhd HL\)</span>，<span class="math inline">\(K(H \cap L) \lhd H\)</span>，并且<span class="math inline">\(HL/KL \cong H/K(H \cap L)\)</span></li>
</ul></li>
</ul>
<h4 id="schereier定理">Schereier定理</h4>
<blockquote>
<p>群<span class="math inline">\(G\)</span>的人任意两个正规群列存在等价的加细</p>
</blockquote>
<ul>
<li>证明的思路是假设有两个长为<span class="math inline">\(n, m\)</span>的，凑一个长为<span class="math inline">\(nm\)</span>的来证明，但比较复杂</li>
<li>这个定理可以方便的证明Jordan-Holder定理</li>
</ul>
<h4 id="外直积">外直积</h4>
<blockquote>
<p>设群<span class="math inline">\(G_1, G_2, ..., G_n\)</span>，定义<span class="math inline">\(G = G_1 \times G_2 \times ... \times G_n = \{(g_1, g_2, ..., g_n) : \forall i, g_i \in G_i\}\)</span></p>
<p>对于<span class="math inline">\(G\)</span>中的元素<span class="math inline">\(x=(x_1, x_2, ..., x_n), y=(y_1, y_2, ..., y_n)\)</span>定义乘法为<span class="math inline">\(xy=(x_1y_1, ..., x_ny_n)\)</span>，其中<span class="math inline">\(x_iy_i\)</span>为<span class="math inline">\(G_i\)</span>中的乘法</p>
<p>那么<span class="math inline">\(G\)</span>按照上述定义的乘法构成群，称为<span class="math inline">\(G_1, G_2, ..., G_n\)</span>的外直积</p>
</blockquote>
<p>虽然<span class="math inline">\(G\)</span>与<span class="math inline">\(G_i\)</span>之间太大关系，但是我们可以找出<span class="math inline">\(G\)</span>的一个子群，其与<span class="math inline">\(G_i\)</span>之间关系密切</p>
<p>令<span class="math inline">\(G_{i}^* = \{(e_1, e_2, ..., e_{i-1}, g_i, e_{i+1}, ..., e_n):g_i\in G_i\}\)</span>，那么</p>
<ul>
<li><span class="math inline">\(G_i \cong G_i^*\)</span></li>
<li><span class="math inline">\(G_i^* \lhd G\)</span></li>
<li><span class="math inline">\(G_i* \cap \prod_{j \neq i} G_j^* = \{e\}\)</span></li>
<li><span class="math inline">\(\prod_{i=1}^n G_i^* = G\)</span></li>
</ul>
<h4 id="内直积">内直积</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为群，<span class="math inline">\(G_1, G_2, ..., G_n \lhd G\)</span>，若<span class="math inline">\(G\)</span>中的每一个元素<span class="math inline">\(g\)</span>可以唯一的表示为<span class="math inline">\(g = g_1g_2...g_n, g_i\in G_i\)</span>，则称<span class="math inline">\(G\)</span>为<span class="math inline">\(G_1, G_2, ..., G_n\)</span>的内直积</p>
</blockquote>
<p>依据下面的定理，内直积可以有若干等价的定义</p>
<blockquote>
<p>设<span class="math inline">\(G_1, G_2, ..., G_n \lhd G\)</span>，则下列命题等价</p>
<ol type="a">
<li><p><span class="math inline">\(G_i \cap \prod_{j \neq i}G_j = \{e\}\)</span></p></li>
<li><p><span class="math inline">\(G\)</span>中的每个元素至多存在一种被表示为<span class="math inline">\(g_1g_2...g_n\)</span>的方式</p></li>
<li><p>单位元的表示方法唯一，也即若<span class="math inline">\(e = g_1g_2...g_n\)</span>，那么<span class="math inline">\(g_1=g_2=...=g_n=e\)</span></p></li>
</ol>
</blockquote>
<ul>
<li><ol type="a">
<li>-&gt; (b) : 设<span class="math inline">\(x_1x_2...x_n=y_1y_2...y_n\)</span>，那么<span class="math inline">\(x_ny_n^{-1}=(x_1x_2...x_{n-1})^{-1}(y_1y_2...y_{n-1})\)</span>，而<span class="math inline">\(x_1x_2...x_{n-1}, y_1y_2...y_{n-1} \in G_1G_2...G_{n-1}\)</span>，<span class="math inline">\(x_ny_n^{-1} \in G_n\)</span>，故<span class="math inline">\(x_n = y_n\)</span>，后面类似的进行讨论即可</li>
</ol></li>
<li><ol start="2" type="a">
<li>-&gt; (c) : trival</li>
</ol></li>
<li><ol start="3" type="a">
<li>-&gt; (a) : 设<span class="math inline">\(x_i = x_1x_2...x_{i-1}x_{i+1}...x_n\)</span>，不难证明存在<span class="math inline">\(x_j&#39; \in G_j\)</span>，使得<span class="math inline">\(x_i^{-1}x_j&#39; = x_jx_i^{-1}\)</span>（<span class="math inline">\(G_j=x_iG_jx_i^{-1}\)</span>），进行若干次交换，得到<span class="math inline">\(e=x_1&#39;x_2&#39;...x_{i-1}&#39;x_i^{-1}x_{i+1}...x_n\)</span>，从而<span class="math inline">\(x_i = e\)</span></li>
</ol></li>
</ul>
<p>按照上面的结论，内直积等价于</p>
<blockquote>
<ul>
<li><span class="math inline">\(G = G_1G_2...G_n\)</span></li>
<li><span class="math inline">\(\forall i, G_i \cap \prod_{j \neq i}G_j = \{e\}\)</span></li>
</ul>
</blockquote>
<p>不难注意到，这和上面外直积的性质非常的相像</p>
<h4 id="直积">直积</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为<span class="math inline">\(G_1, G_2, ..., G_n\)</span>的内直积，<span class="math inline">\(G&#39; = G_1 \times G_2 \times ... \times G_n\)</span>为外直积，那么<span class="math inline">\(G \cong G&#39;\)</span></p>
</blockquote>
<ul>
<li><p>构造映射<span class="math inline">\(\sigma((x_1, x_2, ..., x_n))=x_1x_2...x_n\)</span>即可</p>
<p>证明同态时，利用结论：设<span class="math inline">\(H, K \lhd G\)</span>，<span class="math inline">\(H \cap K = \{e\}\)</span>，则<span class="math inline">\(\forall h \in H, k \in K, hk=kh\)</span></p></li>
</ul>
<p>这个定理告诉我们外直积和内直积没什么区别...</p>
<ul>
<li>设<span class="math inline">\(G\)</span>为有限群，<span class="math inline">\(H \lhd G, K \lhd G\)</span>，若<span class="math inline">\(|H|*|K|=|G|\)</span>且<span class="math inline">\(H \cap K = \{e\}\)</span>，那么<span class="math inline">\(G \cong H \times K\)</span></li>
</ul>
<h3 id="week9">week9</h3>
<h4 id="有限abel群的sylow-p-子群的分解">有限Abel群的Sylow p-子群的分解</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为有限Abel群，设<span class="math inline">\(|G| = \prod_{i=1}^n p_i^{\alpha_i}\)</span>，其中<span class="math inline">\(p_1, p_2, ..., p_n\)</span>为两两不同的素数</p>
<p>令<span class="math inline">\(G_i\)</span>为其（唯一的）Sylow p-子群，那么<span class="math inline">\(G \cong G_1 \times G_2 \times...\times G_n\)</span></p>
</blockquote>
<p>首先，根据Abel群的性质，<span class="math inline">\(G_i \lhd G\)</span></p>
<p>其次，用第二同构定理得到<span class="math inline">\(|G_iG_j| \mid |G_i| * |G_j|\)</span>，稍作扩展，得到<span class="math inline">\(|\prod_{j \neq i} G_j| \mid \prod_{j \neq i}|G_j|\)</span></p>
<p>由于<span class="math inline">\(\gcd(\prod_{j\neq i} G_j, G_i) = 1\)</span>，因此<span class="math inline">\(G_i \cap \prod_{j \neq i}G_j = \{e\}\)</span></p>
<p>那么<span class="math inline">\(H = \prod_{i=1}^n G_i\)</span>构成<span class="math inline">\(G_1, G_2, ..., G_n\)</span>的内直积，其与外直积同构，由同构的大小关系又可以得到<span class="math inline">\(H=G\)</span></p>
<h4 id="幂指数">幂指数</h4>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为有限群，使得<span class="math inline">\(\forall g \in G, g^n = e\)</span>的最小的正整数<span class="math inline">\(n\)</span>称为<span class="math inline">\(G\)</span>的幂指数，记为<span class="math inline">\(exp(G)\)</span></p>
</blockquote>
<p>幂指数<span class="math inline">\(exp(G)\)</span>就是所有元素的阶数的最小公倍数</p>
<p>特别的，<span class="math inline">\(exp(C_{n_1} \times C_{n_2} ... \times C_{n_k}) = \text{lcm}(n_1, ..., n_k)\)</span></p>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为有限Abel群，那么<span class="math inline">\(exp(G) = \max_{x \in G} o(x)\)</span></p>
</blockquote>
<p>设<span class="math inline">\(g\in G\)</span>取到<span class="math inline">\(o(g)\)</span>最大值，考虑证明<span class="math inline">\(\forall x, o(x)|o(g)\)</span></p>
<p>如果<span class="math inline">\(\exists a, o(a) \nmid o(g)\)</span>，那么存在<span class="math inline">\(p\)</span>，使得<span class="math inline">\(v_p(o(a))&gt;v_p(o(g))\)</span></p>
<p>设<span class="math inline">\(g=p^\alpha n, a = p^\beta m\)</span>，那么<span class="math inline">\(o(g^{p^\alpha} a^m) = p^\beta n &gt; o(g)，\)</span>矛盾</p>
<p>最后对阶的计算依赖于以下引理</p>
<ul>
<li>如果<span class="math inline">\(\gcd(o(a), o(b)) = 1\)</span>，且<span class="math inline">\(ab=ba\)</span>，那么<span class="math inline">\(o(ab)=o(a)o(b)\)</span></li>
</ul>
<h4 id="有限abel群结构定理">有限Abel群结构定理</h4>
<p>引理</p>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为有限Abel群，<span class="math inline">\(a \in G\)</span>，<span class="math inline">\(o(a)=exp(G)\)</span>，那么存在<span class="math inline">\(H \leqslant G\)</span>，使得<span class="math inline">\(G\)</span>为<span class="math inline">\(\langle a \rangle, H\)</span>的内直积</p>
</blockquote>
<p>这个引理的证明非常的复杂，我们就略过了</p>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为不平凡的有限Abel群，那么</p>
<ol type="i">
<li><p>存在唯一的正整数<span class="math inline">\(n_1 \mid n_2 \mid ... \mid n_r\)</span>，使得<span class="math inline">\(G \cong C_{n_1} \times C_{n_2} \times ... \times C_{n_r}\)</span></p></li>
<li><p><span class="math inline">\(G\)</span>存在唯一的循环p-群的直积表示（比如<span class="math inline">\(C_2 \times C_{2^2} \times C_3\)</span>）</p></li>
</ol>
</blockquote>
<p>只证明存在性，唯一性省略</p>
<p>对于(i)，我们运用引理，取<span class="math inline">\(o(a) = exp(G)\)</span>，那么<span class="math inline">\(C_{n_r} = \langle a\rangle\)</span>，对<span class="math inline">\(H\)</span>进行类似的分解即可，注意到<span class="math inline">\(exp(H)\mid exp(G)\)</span>，如此可以保证存在性</p>
<p>对于(ii)，现对<span class="math inline">\(G\)</span>运用Sylow p-子群的分解，之后对每一个Sylow p-子群运用(i)即可</p>
<h4 id="有限生成abel群结构定理">有限生成Abel群结构定理</h4>
<blockquote>
<p>如果一个群<span class="math inline">\(G\)</span>由有限个元素<span class="math inline">\(a_1, a_2, ..., a_n\)</span>生成，即<span class="math inline">\(G = \langle a_1, a_2, ..., a_n\rangle\)</span>，则称<span class="math inline">\(G\)</span>为有限生成群</p>
</blockquote>
<p>对于有限生成Abel群，其结构也已确定，在这之前，我们需要定义挠子群</p>
<blockquote>
<p>记<span class="math inline">\(Tor(G) = \{g \in G : o(g) \;is\;finite\}\)</span>，那么<span class="math inline">\(Tor(G) \leq G\)</span>，称其为<span class="math inline">\(G\)</span>的挠子群</p>
</blockquote>
<p>下面我们正式介绍有限生成Abel群结构定理</p>
<blockquote>
<p>设<span class="math inline">\(G\)</span>为有限生成Abel群，那么<span class="math inline">\(Tor(G)\)</span>为有限子群，并且存在自然数<span class="math inline">\(r \in N\)</span>，使得<span class="math inline">\(G \cong Tor(G) \underbrace{\times Z \times Z....\times Z}_{r \text{个}}\)</span>，<span class="math inline">\(r\)</span>称为（有限生成Abel群）<span class="math inline">\(G\)</span>的秩</p>
</blockquote>
<p>证明略</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>abstract_algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>信息论</title>
    <url>/2021/08/information-theory/</url>
    <content><![CDATA[<span id="more"></span>
<p>临时补一下...</p>
<h2 id="information-theory">Information theory</h2>
<h3 id="entropy">Entropy</h3>
<p>对于离散型随机变量<span class="math inline">\(X\)</span>，出于方便，我们用<span class="math inline">\(|X|\)</span>来表示其样本空间的大小，那么，我们定义随机变量<span class="math inline">\(X\)</span>的熵（entropy）</p>
<p><span class="math display">\[\begin{align}H(X) = \sum_{x \in X} -p(x) \log p(x)  = \sum_{x \in X} p(x) \log \frac{1}{p(x)} \end{align}\]</span></p>
<p>（特别的，如果<span class="math inline">\(p(x) = 0\)</span>，认为<span class="math inline">\(p(x) \log \frac{1}{p(x)} = 0\)</span>）</p>
<p>熵有下列的性质</p>
<ul>
<li><p>如果<span class="math inline">\(X\)</span>均匀随机，那么<span class="math inline">\(H(X) = |X| * \frac{1}{|X|} * \log |X| = \log |X|\)</span></p></li>
<li><p><span class="math inline">\(0 \leq H(X) \leq \log |X|\)</span></p>
<ul>
<li><p>不等式左边成立当且仅当<span class="math inline">\(X\)</span>只在一个地方取得概率<span class="math inline">\(1\)</span>，其余地方取得概率<span class="math inline">\(0\)</span></p></li>
<li><p>不等式右边成立当且仅当<span class="math inline">\(X\)</span>​均匀分布</p></li>
<li><p>不等式的左边是显然的，右边则考虑函数<span class="math inline">\(x \log x\)</span>的凸性</p></li>
</ul></li>
</ul>
<p>对于服从二项分布的<span class="math inline">\(X\)</span>，有特殊的一种熵（Binary entropy function）</p>
<p><span class="math display">\[\begin{align}H(p) = H(X) = p \log \frac{1}{p}  + (1-p) \log \frac{1}{1-p} \end{align}\]</span></p>
<p>熵的定义只依赖于概率分布，只要确定了概率分布，我们就可以定义出熵，因此，在二元情况下，我们可以定义</p>
<p><span class="math display">\[\begin{align}H(X, Y) = \sum_{x \in X, y \in Y} p(x, y) \log \frac{1}{p(x, y)} \end{align}\]</span></p>
<p>为联合熵（joint entropy）</p>
<ul>
<li><span class="math inline">\(H(X, X) = H(X)\)</span>​</li>
<li><span class="math inline">\(H(X, Y) = H(Y, X)\)</span>​</li>
</ul>
<p>定义</p>
<p><span class="math display">\[\begin{align} H(X | Y = y) = \sum_x p(x | Y = y) \log \frac{1}{p(x|Y=y)} \end{align}\]</span></p>
<p><span class="math display">\[\begin{align}H(X|Y) &amp;= \sum_{y \in Y} p(y) H(X | Y = y) \\ &amp;= \sum_{y \in Y} p(y) \sum_{x \in X} p(x | y) \log \frac{1}{p(x | y)} \\ &amp;= \sum_{x \in X, y \in Y} p(x, y) \log \frac{1}{p(x|y)}\end{align}\]</span>​</p>
<p>其中第二项称为条件熵（conditional entropy）</p>
<p>注意到</p>
<p><span class="math display">\[\begin{align} \log p(x|y) = \log \frac{p(x, y)}{p(y)} = \log p(x, y) - \log p(y)\end{align}\]</span>​</p>
<p>（式中的<span class="math inline">\(p(y)\)</span>为对应的边缘分布函数）</p>
<p>我们有</p>
<p><span class="math display">\[\begin{align} H(X|Y) = H(X, Y) - H(Y)\end{align}\]</span></p>
<p>由对称性，得到</p>
<p><span class="math display">\[\begin{align} H(X,Y) = H(Y) + H(X|Y) = H(X) + H(Y | X)\end{align}\]</span></p>
<p>我们可以得到链式法则</p>
<p><span class="math display">\[\begin{align} H(X_1, X_2, ..., X_n) &amp;= H(X_1) + H(X_2, ..., X_n|X_1) \\ &amp;= H(X_1) +H(X_2 | X_1) + H(X_3,...,X_n | X_1, X_2) \\ &amp;= \sum_{i=1}^n H(X_i | X_{1}, ..., X_{i-1})\end{align}\]</span>​</p>
<ul>
<li>当<span class="math inline">\(X, Y\)</span>独立时，<span class="math inline">\(H(X, Y) = H(X) + H(Y)\)</span></li>
<li>贝叶斯公式：<span class="math inline">\(H(X, Y | Z) = H(X|Z) + H(Y | X, Z)\)</span>
<ul>
<li>注意到<span class="math inline">\(p(x, y | z) = \frac{p(x, y, z)}{p(z)} = \frac{p(x, y, z)}{p(x, z)} * \frac{p(x, z)}{p(z)} = p(y|x, z) * p(x|z)\)</span></li>
</ul></li>
<li>当且仅当<span class="math inline">\(Y\)</span>是<span class="math inline">\(X\)</span>的一个函数时，<span class="math inline">\(H(Y|X) = 0\)</span>，也即<span class="math inline">\(H(X, Y) = H(X)\)</span></li>
</ul>
<h3 id="relative-entropy">Relative entropy</h3>
<p>对于概率函数<span class="math inline">\(p(x), q(x)\)</span>，定义</p>
<p><span class="math display">\[\begin{align} D(p || q) = \sum_{x \in X} p(x) \log \frac{p(x)}{q(x)}\end{align}\]</span></p>
<p>为相对熵（relative entropy），也称KL距离，用于衡量两个概率函数之间的“距离”</p>
<p>但是KL距离并不是一种度量（metric）</p>
<ul>
<li><p>当<span class="math inline">\(p(x) = 0\)</span>时，<span class="math inline">\(0 \log \frac{0}{q(x)} = 0\)</span>，反之若<span class="math inline">\(p(x) \neq 0, q(x) = 0\)</span>时，<span class="math inline">\(p(x) \log \frac{p(x)}{0} = \infty\)</span></p></li>
<li><p><span class="math inline">\(D(p || q) \geq 0\)</span>​，当且仅当<span class="math inline">\(p = q\)</span>时取等​</p>
<ul>
<li><p><span class="math inline">\(-D(p || q) = \sum_{x\in X} - p(x) \log \frac{q(x)}{p(x)} \leq \log \sum q(x) \leq \log 1 = 0\)</span></p>
<p>其中第一步为琴生不等式</p>
<p>当且仅当<span class="math inline">\(q(x)/p(x) \equiv C\)</span>，并且<span class="math inline">\(\sum q(x) = 1\)</span>时取等，从而<span class="math inline">\(1 = \sum p(x) = \frac{1}{C} \sum q(x) = \frac {1}{C}\)</span>，于是<span class="math inline">\(C = 1\)</span>，进而<span class="math inline">\(p(x) = q(x)\)</span>，对于<span class="math inline">\(0\)</span>的讨论这里略去</p></li>
</ul></li>
</ul>
<p>定义差分距离（也即向量的1-范数）</p>
<p><span class="math display">\[\begin{align} V(p, q) = \sum_{x \in X} |p(x) - q(x)|\end{align}\]</span></p>
<p>Pinsker 不等式：<span class="math inline">\(D(p || q) \geq \frac{1}{2 \ln 2} V^2(p, q)\)</span>​​（不懂，先记着）</p>
<p>对于<span class="math inline">\(p(x, y), q(x, y)\)</span>，定义条件相对熵为</p>
<p><span class="math display">\[\begin{align} D( p(y|x) || q(y|x)) &amp;= \sum_{x} p(x) D(p(Y|x)||q(Y|x)) \\ &amp;= \sum_x \sum_y p(x)p(y|x) \log \frac{p(y|x)}{q(y|x)} \\ &amp;= \sum_{x, y} p(x, y) \log \frac{ p(y|x)}{q(y|x)}\end{align}\]</span>​</p>
<p>有了条件相对熵之后，就可以类比的写出链式法则</p>
<p><span class="math display">\[\begin{align} D(p(x, y) || q(x, y)) = D(p(x) || q(x)) + D(p(y|x) || q(y|x))\end{align}\]</span></p>
<p>只需注意到<span class="math inline">\(\log \frac{p(x, y)}{q(x, y)} = \log \frac{p(x) p(y|x)}{q(x) q(y|x)} = \log \frac{p(x)}{q(x)} + \log \frac{p(y|x)}{q(y|x)}\)</span></p>
<h3 id="mutual-information">Mutual information</h3>
<p>定义</p>
<p><span class="math display">\[\begin{align} I(X;Y) &amp;= D(p(x, y) || p(x)p(y)) \\ &amp;= \sum_{x \in X, y \in Y} p(x, y) \log \frac{p(x, y)}{p(x)p(y)}\end{align}\]</span></p>
<p>为<span class="math inline">\(X, Y\)</span>的互信息（mutual information）</p>
<ul>
<li><span class="math inline">\(I(X;Y) = I(Y;X)\)</span></li>
<li><span class="math inline">\(I(X;X) = H(X)\)</span>​</li>
<li>既然<span class="math inline">\(I(X;Y)\)</span>是一个KL距离，那么<span class="math inline">\(I(X;Y) \geq 0\)</span>​，等号成立当且仅当<span class="math inline">\(p(x, y) = p(x)p(y)\)</span>，即<span class="math inline">\(X, Y\)</span>独立</li>
</ul>
<p>由于<span class="math inline">\(\log \frac{p(x, y)}{p(x)p(y)} = \log p(x, y) - \log p(x) - \log p(y)\)</span></p>
<p>因此</p>
<p><span class="math display">\[\begin{align} I(X;Y) &amp;= H(X) + H(Y) - H(X, Y) \\ &amp;= H(X) - H(X | Y)\\ &amp;= H(Y) - H(Y|X)\end{align}\]</span>​</p>
<ul>
<li>由<span class="math inline">\(I(X;Y) = H(X) - H(X|Y) \geq 0\)</span>​，那么<span class="math inline">\(H(X|Y) \leq H(X)\)</span>​​，当<span class="math inline">\(X, Y\)</span>​独立时取等</li>
<li><span class="math inline">\(I(X;Y) \leq H(X)\)</span></li>
</ul>
<p>定义</p>
<p><span class="math display">\[\begin{align} I(X;Y | Z) &amp;= \sum_{x, y, z} p(x ,y, z) \log \frac{p(x, y | z)}{p(x|z) p(y|z) } \\ &amp;= H(X|Z) - H(X|Y,Z)\end{align}\]</span>​</p>
<p>当且仅当在给定<span class="math inline">\(Z\)</span>的情况下，<span class="math inline">\(X, Y\)</span>独立时取等</p>
<p>计算条件互信息时，有链式法则</p>
<p><span class="math display">\[\begin{align} I(X_1, X_2, ..., X_n ; Y) = \sum_{i=1}^n I(X_i ; Y|X_1, X_2, ..., X_{i-1})\end{align}\]</span></p>
<h3 id="entropy-bound">Entropy Bound</h3>
<p><span class="math display">\[H(X_1, X_2, ..., X_n) \leq \sum_{i=1}^n H(X_i)\]</span></p>
<p>取等当且仅当<span class="math inline">\(X_1, ..., X_n\)</span>独立（用链式法则证明）</p>
<p>接下来要引入马尔科夫链，称<span class="math inline">\(X, Y, Z\)</span>形成马尔科夫链，当且仅当</p>
<p><span class="math display">\[\begin{align} p(x, y, z) = p(x)p(y|x)p(z|y)\end{align}\]</span></p>
<p>（也就是<span class="math inline">\(p(z|y) = p(z|x, y)\)</span>），写作<span class="math inline">\(X \to Y \to Z\)</span></p>
<ul>
<li><p>如果<span class="math inline">\(X\to Y \to Z\)</span>，那么<span class="math inline">\(I(X;Z|Y) = 0\)</span></p></li>
<li><p>如果<span class="math inline">\(X \to Y \to Z\)</span>，那么<span class="math inline">\(I(X;Y) \geq I(X;Z)\)</span></p>
<ul>
<li><span class="math inline">\(I(X;Y) - I(X;Z) = I(X;Y,Z) - I(X;Z|Y) - (I(X;Y,Z) - I(X;Y|Z)) = I(X;Y|Z) \geq 0\)</span></li>
<li>由上述等式，还能观察到<span class="math inline">\(I(X;Y) \geq I(X;Y|Z)\)</span></li>
<li>但是，一般情况下，<span class="math inline">\(I(X;Y) \geq I(X;Y|Z)\)</span>不一定成立</li>
</ul></li>
<li><p>如果<span class="math inline">\(X \to Y \to Z\)</span>，那么<span class="math inline">\(H(X|Z) \geq H(X|Y)\)</span></p></li>
<li><p>$ H(X|Z) - H(X|Y,Z) = I(X;Y|Z)I(X;Z|Y) = H(X|Y) - H(X|Y,Z)$</p></li>
</ul>
<h3 id="entropy-rate">Entropy rate</h3>
<p>稳态过程，一个随机过程称为稳态，如果其任意子集的联合分布具有时间不变性，</p>
<p><span class="math display">\[\begin{align} \forall n, l, x_1, x_2,..., x_n \in X, P(X_1 = x_1, X_2 = x_2, ..., X_n = x_n) = P(X_{1+l} = x_1, ..., X_{n+l} = x_n)\end{align}\]</span></p>
<p>稳态过程具有时间可逆性，即</p>
<p><span class="math display">\[\begin{align} H(X_0 | X_{-1},X_{-2},..X_{-n}) = H(X_0 | X_1, X_2, ..., X_n)\end{align}\]</span></p>
<p>而对于马尔科夫链，其为稳态充要条件为<span class="math inline">\(p(X_{n+1}) = p(X_n)\)</span></p>
<p>或者说<span class="math inline">\(P(x_1,x_2,...,x_n)^T = (x_1, ..., x_n)^T\)</span>，其中<span class="math inline">\(P\)</span>为转移矩阵</p>
<hr />
<p>对于随机过程，定义熵率</p>
<p><span class="math display">\[\begin{align} H(X) = \lim_{n \to \infty} \frac{1}{n} H(X_1, X_2, ..., X_n)\end{align}\]</span></p>
<p>熵率不一定存在，但对于稳态而言，熵率是存在的</p>
<p>我们先考虑<span class="math inline">\(A_n = H(X_n | X_{n-1}, ..., X_1)\)</span></p>
<p>注意到<span class="math inline">\(0 \leq A_{n+1} = H(X_{n+1} | X_{n},...,X_1) \leq H(X_{n+1} | X_n,...,X_2) = H(X_n | X_{n-1},...,X_1) = A_n\)</span>，<span class="math inline">\(A_n\)</span>单调递减有下限，因此<span class="math inline">\(A_n\)</span>有极限</p>
<p>那么</p>
<p><span class="math display">\[\begin{align} H&#39;(X) = \lim_{n \to \infty} H(X_n | X_{n-1},...,X_1)\end{align}\]</span></p>
<p>存在，根据数学分析中的结论，我们有</p>
<p><span class="math display">\[\begin{align} H(X) = H&#39;(X)\end{align}\]</span></p>
<p>存在</p>
<p>特别的，对于稳态马尔科夫链，将有<span class="math inline">\(H(X) = H&#39;(X) = H(X_2 | X_1)\)</span></p>
<p>如果设出马尔科夫链的极限分布<span class="math inline">\(\pi\)</span>和转移矩阵<span class="math inline">\(P\)</span>，那么我们将得到</p>
<p><span class="math display">\[\begin{align} H(X) = \sum_{ij} \pi_i P_{ij} \log \frac{1}{P_{ij}}\end{align}\]</span></p>
<hr />
<p>设<span class="math inline">\(Y = f(X)\)</span>，如果<span class="math inline">\(\{X\}\)</span>构成稳态的马尔科夫链，那么<span class="math inline">\(\{Y\}\)</span>也构成稳态的马尔科夫链</p>
<ul>
<li><span class="math inline">\(p(X_{n+1}) = p(X_n) \Rightarrow p(Y_{n+1}) = p(Y_n)\)</span></li>
</ul>
<p>那么，<span class="math inline">\(H(Y) = \lim_{n \to \infty} H(Y_n | Y_{n-1}, ..., Y_1)\)</span></p>
<p>通过一些（奇怪的）技巧，我们可以对<span class="math inline">\(H(Y)\)</span>进行更好的估值，这依赖于以下定理</p>
<p><span class="math display">\[\begin{align} H(Y_n | Y_{n-1},...,Y_1, X_1) \leq H(y) \leq H(Y_n | Y_{n-1},...,Y_1)\end{align}\]</span></p>
<p><span class="math display">\[\begin{align} \lim_{n \to \infty} H(Y_n | Y_{n-1},...,Y_1,X_1) = \lim_{n \to \infty} H(Y_n|Y_{n-2},...,Y_1) = H(y)\end{align}\]</span>​</p>
<ul>
<li>注意到<span class="math inline">\(Y\)</span>是<span class="math inline">\(X\)</span>的函数，尝试在熵的已知中添加<span class="math inline">\(Y\)</span></li>
</ul>
<h3 id="data-compression">Data Compression</h3>
<p>大概到了新的阶段</p>
<p>对于一个随机变量<span class="math inline">\(X\)</span>的信源编码（source code），是一个从随机变量<span class="math inline">\(X\)</span>的样本空间到一个有限长度的字符串的映射（不妨设字母表为<span class="math inline">\(D\)</span>，记所有的有限长度的字符串的集合为<span class="math inline">\(D^*\)</span>），让<span class="math inline">\(C(x)\)</span>表示对应于<span class="math inline">\(x\)</span>的编码，而<span class="math inline">\(l(x)\)</span>表示<span class="math inline">\(C(x)\)</span>的长度</p>
<p>记<span class="math inline">\(L(C) = E_{p(x)}[l(x)] = \sum_{x} p(x) l(x)\)</span>，一般的，我们希望一个编码方式能够最小化<span class="math inline">\(L(C)\)</span></p>
<p>对于一种编码，称其扩展<span class="math inline">\(C^*\)</span>为以<span class="math inline">\(X\)</span>的样本空间为字符集构成的有限字符串映射到有限长度的字符串的映射，满足<span class="math inline">\(C(x_1 + x_2 + ... + x_n) = C(x_1) + C(x_2) + ... + C(x_n)\)</span>，这里的"+"表示字符串的拼接</p>
<ul>
<li>当一种编码的<strong>扩展</strong>是一个单射时，称这种编码是唯一可解码的</li>
<li>一种编码称为前缀码，或者即时码，如果任意两个码都没有互为前缀，类似的定义后缀码</li>
</ul>
<h5 id="kraft-inequality">Kraft inequality</h5>
<p>Kraft 不等式：对于一种前缀码，设其字母表大小为<span class="math inline">\(D\)</span>​​，那么编码长度<span class="math inline">\(l_1, ..., l_m (m = |X|)\)</span>​​将满足</p>
<p><span class="math display">\[\begin{align} \sum_{i=1}^m D^{-l_i} \leq 1\end{align}\]</span></p>
<p>并且，给定一组满足该不等式的编码长度，那么一定存在一种前缀码以这些长度编码</p>
<ul>
<li>考虑用Trie树表示前缀码，反过来则用归纳法证明</li>
<li>这个结论在编码长度有可数无穷的情况下也是对的，可以考虑用<span class="math inline">\([0,1)\)</span>中的<span class="math inline">\(D\)</span>进制小数来证明</li>
</ul>
<p>利用拉格朗日乘数法，得到最优情况下，我们应该控制编码长度为<span class="math inline">\(l_i = -\log_D p_i(p_i = D^{-l_i})\)</span>，此时<span class="math inline">\(L(C) = H_D(X)\)</span></p>
<p>但是一般的，这个长度不是整数，因此一般的有<span class="math inline">\(L(C) \geq H_D(X)\)</span>​，但是我们有<span class="math inline">\(H_D(X) \leq L(C) &lt; H_D(X) + 1\)</span>​</p>
<h5 id="shannon-codes">Shannon codes</h5>
<p>我们直接取<span class="math inline">\(l_i = \lceil -\log_D p_i \rceil\)</span>，就有<span class="math inline">\(-\log_D p_i \leq l_i &lt; -\log_D p_i + 1\)</span>，于是<span class="math inline">\(H_D(X) \leq L(C) &lt; H_D(X) + 1\)</span>，这种编码称为Shannon codes</p>
<p>进一步，如果我们对<span class="math inline">\(X_1, X_2,...,X_n\)</span>​（样本空间相同）一起编码，运用刚刚的结论，得到</p>
<p><span class="math display">\[H(X_1, ..., X_n) \leq E [l(X_1, ..., X_n)] &lt; H(X_1,...,X_n) + 1\]</span></p>
<blockquote>
<p>将<span class="math inline">\(L(C)\)</span>记为编码一个随机变量所用的期望长度，那么<span class="math inline">\(L(C) = \frac{1}{n} E [l(X_1, ..., X_n)]\)</span>，代入上式，得到 <span class="math display">\[\frac{H(X_1, ..., X_n)}{n} \leq L(C)&lt; \frac{H(X_1,...,X_n) + 1}{n}\]</span></p>
<p>如果<span class="math inline">\(X_1,...,X_n,...\)</span>构成一个稳态的话，根据前文的结论，我们有<span class="math inline">\(L(C) \to H(X)\)</span>（这里为熵率）</p>
</blockquote>
<p>这种编码方式称为区块编码，而上述结论称为香农第一定理</p>
<hr />
<p>如果我们运用<span class="math inline">\(\{q(x)\}\)</span>来给一个概率为<span class="math inline">\(\{p(x)\}\)</span>的随机变量编码，那么我们将有</p>
<p><span class="math display">\[\begin{align} H(p) + D(p||q) \leq E_p \; \lceil\log \frac{1}{q(x)} \rceil &lt; H(p) + D(p || q) + 1\end{align}\]</span>​</p>
<p>当然，这里的<span class="math inline">\(\lceil\log \frac{1}{q(x)} \rceil\)</span>表示编码长度</p>
<p>这个式子只需要对取整号进行简单放缩后，运用定义就可以得到</p>
<hr />
<p>Kraft不等式的约束范围非常非常广，事实上，我们只考虑前缀码就足够了</p>
<p>对于一种唯一可解码，设其字母表大小为<span class="math inline">\(D\)</span>​，那么编码长度<span class="math inline">\(l_1, ..., l_m (m = |X|)\)</span>​将满足</p>
<p><span class="math display">\[\begin{align} \sum_{i=1}^m D^{-l_i} \leq 1\end{align}\]</span></p>
<p>并且，给定一组满足该不等式的编码长度，那么一定存在一种唯一可解码以这些长度编码</p>
<h5 id="huffman-codes">Huffman codes</h5>
<p>哈夫曼编码可以使得<span class="math inline">\(L(C)\)</span>最小，并且哈夫曼编码是一种前缀码</p>
<p>这玩意初中生都会了....就不写了</p>
<p>有个扩展叫canonical codes，就先不学了..。</p>
<h5 id="shannon-fano-elias-coding">Shannon-Fano-Elias coding</h5>
<p>考虑<span class="math inline">\(X\)</span>的分布函数<span class="math inline">\(F(x)\)</span>，定义其MCDF为<span class="math inline">\(F^*(x) = F(x) - \frac{1}{2} p(x)\)</span></p>
<p>不难发现，<span class="math inline">\(F^*(x)\)</span>和<span class="math inline">\(p(x) &gt; 0\)</span>的<span class="math inline">\(x\)</span>​之间存在着对应关系，从而可以用于编码</p>
<p>考虑截取<span class="math inline">\(F^*(x)\)</span>的前<span class="math inline">\(l(x) = \lceil \log \frac{1}{p(x)}\rceil + 1\)</span>位（二进制），那么有<span class="math inline">\(F^*(x) - C(x) \leq \frac{1}{2^{l(x)}} \leq \frac{p(x)}{2} = F^*(x) - F^*(x-1)\)</span></p>
<p>因此这种编码方式也构成一种前缀码，由于多用了1个bit来避免重复，因此此时<span class="math inline">\(L &lt; H(x) + 2\)</span>​</p>
<h3 id="channel">Channel</h3>
<p>一个信道的模型，大概就是对信息进行编码，通过信道（可能有噪声，以一个概率来描述），之后解码</p>
<p>我们假设发送了<span class="math inline">\(w = x_1x_2...x_k\)</span>，经过信道后得到<span class="math inline">\(y_1y_2...y_k\)</span></p>
<p>这些数字的生成是有先后顺序的，<span class="math inline">\(w \to x_1 \to y_1 \to x_2 \to y_2 ... \to x_k \to y_k\)</span></p>
<p>为了表示方便，记<span class="math inline">\(x^i = x_1,x_2...,x_i, y^i = y_1, y_2, ..., y_i\)</span></p>
<p>对于一个好的信道，我们希望它能发送更多的信息，也即熵尽可能大</p>
<h5 id="discrete-memoryless-channel">Discrete memoryless channel</h5>
<p>离散无记忆信道（DMC），满足</p>
<p><span class="math display">\[\begin{align} p(y_k | x^k, y^{k-1}) = p(y_k | x_k) \end{align}\]</span></p>
<p>其中<span class="math inline">\(x_k\)</span>是第<span class="math inline">\(k\)</span>个发送的信息，而<span class="math inline">\(x^k\)</span>为前<span class="math inline">\(k\)</span>次发送的信息，<span class="math inline">\(y^{k-1}\)</span>为前<span class="math inline">\(k-1\)</span>​个发送后的信息</p>
<p>而一个无反馈（feedback）的信道，满足</p>
<p><span class="math display">\[\begin{align} p(x_k | x^{k-1}, y^{k-1}) = p(x_k | x^{k-1})\end{align}\]</span></p>
<p>也就是前<span class="math inline">\(k-1\)</span>次经过信道后的信息对于第<span class="math inline">\(k\)</span>次发送的信息没有影响</p>
<p>结合这两个概率，一般默认DMC是没有反馈的</p>
<p>对于DMC而言，有</p>
<p><span class="math display">\[\begin{align} p(y^n |x^n) =  \prod_{i=1}^n p(y_i | x_i)\end{align}\]</span>​</p>
<p>用熵来表示，就是</p>
<p><span class="math display">\[\begin{align} H(Y^n | X^n) = \sum_{i=1}^n H(Y_i | X_i) \end{align}\]</span>​</p>
<p>运用上式，有</p>
<p><span class="math display">\[H(Y^n) - H(Y^n|X^n)= H(Y^n) - \sum_{i=1}^n H(Y_i | X_i) \leq \sum_{i=1}^n (H(Y_i) - H(Y_i | X_i))\]</span></p>
<p><span class="math display">\[\begin{align} I(X^n ; Y^n) \leq \sum_{i=1}^n I(X_i ; Y_i) \end{align}\]</span></p>
<p>在DMC中，<span class="math inline">\(w \to X^n \to Y^n \to w&#39;\)</span>构成一个马尔科夫链，其中<span class="math inline">\(w&#39;\)</span>​为解码后的信息</p>
<h5 id="channel-coding">Channel coding</h5>
<p>编码器（encoder），是一个将信息映射到<span class="math inline">\(X^n\)</span>的映射，并且要求是单射，类似的有解码器</p>
<p>码本（codebook），记录了编码器的映射规则，码本为发送者和接收者共有</p>
<p>码字（codewords），用<span class="math inline">\(x^n(i)\)</span>表示编码<span class="math inline">\(i\)</span>的字符串</p>
<p>对于一个信道<span class="math inline">\((X, p(y|x), Y)\)</span>​​​而言，其一个编码<span class="math inline">\((M, n)\)</span>包括发送信息的集合（<span class="math inline">\(M\)</span>​），编码器（引申出码本和码字），解码器</p>
<p>为了衡量信道发送的信息是否有误，定义</p>
<p><span class="math display">\[\begin{align}\lambda_i = p( g(Y^n) \neq i | X^n = x^n(i)) = \sum_{y^n} p(y^n | x^n(i))* [g(y^n) \neq i] \end{align}\]</span></p>
<p>定义最大错误概率为</p>
<p><span class="math display">\[\begin{align} \lambda^{(n)} = \max_{i \in [M]} \lambda_i\end{align}\]</span></p>
<p>定义平均错误概率为</p>
<p><span class="math display">\[\begin{align} P_e^{(n)} = \frac{1}{M} \sum_{i=1}^M \lambda_i\end{align}\]</span></p>
<p>对于一个信道编码<span class="math inline">\((M, n)\)</span>​，定义码率为</p>
<p><span class="math display">\[\begin{align} R = \frac{\log M}{n} \end{align}\]</span>​</p>
<p>如果存在一系列的编码<span class="math inline">\((2^{nR}, n)\)</span>，使得当<span class="math inline">\(n \to \infty\)</span>时，<span class="math inline">\(\lambda^{(n)} \to 0\)</span>，就称码率<span class="math inline">\(R\)</span>​是可取的</p>
<p>定义信道容量<span class="math inline">\(C\)</span>为所有可取码率的上确界</p>
<ul>
<li><p>信道编码定理</p>
<p><strong>对于DMC而言，一切小于信道容量<span class="math inline">\(C\)</span>​的码率是可取的</strong></p></li>
<li><p>特别的，对于默认的DMC，<span class="math inline">\(C = \max_{p(x)} I(X;Y)\)</span></p>
<p>而对于有反馈的DMC而言，信道容量并不能得到提高</p></li>
</ul>
<h5 id="typical-set">Typical set</h5>
<p>接下来是一点关于典型集的内容...</p>
<blockquote>
<p>如果<span class="math inline">\(X_1,...,X_n,...\)</span>是i.i.d.的，那么</p>
<p><span class="math display">\[\begin{align} -\frac{1}{n} \log p(X_1,...,X_n) \to H(X) (n \to \infty)\end{align}\]</span>​</p>
</blockquote>
<p>这个性质称为AEP（渐进均分性），根据大数定理，我们知道满足上述条件的<span class="math inline">\(X\)</span>序列的概率和几乎是<span class="math inline">\(1\)</span>​</p>
<p>我们把满足上述条件的序列弄成一个集合<span class="math inline">\(A_{\epsilon}^{(n)}\)</span>​，称为典型集（typical set），形式化的讲就是，如果<span class="math inline">\((x_1,...,x_n) \in X^n\)</span>在集合<span class="math inline">\(A_{\epsilon}^{(n)}\)</span>中，那么</p>
<p><span class="math display">\[\begin{align}2^{-n(H(X) + \epsilon)} \leq p(x_1,...,x_n)  \leq 2^{-n(H(X) - \epsilon)}\end{align}\]</span></p>
<ul>
<li>上述式子等价于：<span class="math inline">\(|\frac{1}{n} \log p(x_1,...,x_n) + H(X)| \leq \epsilon\)</span></li>
<li>根据之前的讨论，当<span class="math inline">\(n\)</span>足够大时，典型集中的序列的概率之和趋近于<span class="math inline">\(1\)</span></li>
<li><span class="math inline">\((1 - \epsilon) 2^{n(H(X) - \epsilon)} \leq |A_{\epsilon}^{(n)}| \leq 2^{n(H(X) - \epsilon)}\)</span>，也就是其大小趋近于<span class="math inline">\(2^{nH(X)}\)</span>​
<ul>
<li>注意到<span class="math inline">\(A_{\epsilon}^{(n)}\)</span>的概率和有上界<span class="math inline">\(1\)</span>，有下界<span class="math inline">\(1- \epsilon\)</span>​</li>
</ul></li>
</ul>
<p>对于两个随机过程，我们可以定义联合典型集</p>
<p>如果<span class="math inline">\((x^n , y^n) \in X^n \times Y^n\)</span>在集合<span class="math inline">\(A_{\epsilon}^{(n)}\)</span>中，那么</p>
<p><span class="math inline">\(2^{-n(H(X) + \epsilon)} \leq p(x^n) \leq 2^{-n(H(X) - \epsilon)}\)</span>​</p>
<p><span class="math inline">\(2^{-n(H(X) + \epsilon)} \leq p(y^n) \leq 2^{-n(H(X) - \epsilon)}\)</span>​</p>
<p><span class="math inline">\(2^{-n(H(X,Y) + \epsilon)} \leq p(x^n, y^n) \leq 2^{-n(H(X, Y) - \epsilon)}\)</span>​</p>
<ul>
<li><p><span class="math inline">\(|A_{\epsilon}^{(n)}| \to 2^{nH(X,Y)}\)</span></p></li>
<li><p>如果<span class="math inline">\((X&#39;, Y&#39;) \sim p(x^n)p(y^n)\)</span>，那么<span class="math inline">\(p((X&#39;, Y&#39;) \in A_{\epsilon}^{(n)}) \to 2^{-nI(X;Y)}\)</span>​</p>
<ul>
<li><p><span class="math inline">\(p((X&#39;, Y&#39;) \in A_{\epsilon}^{(n)}) = \sum_{(x^n, y^n)} p(x^n) p(y^n) \to 2^{nH(X, Y)} * 2^{-nH(X)} * 2^{-nH(Y)} = 2^{-nI(X;Y)}\)</span></p>
<p>式中为集合的大小乘上相应的概率，具体的写法就分两个方向放缩</p></li>
</ul></li>
</ul>
<h5 id="source-channel-coding-theorem">Source-channel coding theorem</h5>
<ul>
<li><p>信源信道联合编码定理</p>
<p>如果<span class="math inline">\(X_1, ..., X_n\)</span>是一个满足渐进均分性，并且<span class="math inline">\(H(X) &lt; C\)</span>，那么存在一种信源信道的联合编码方案，使得<span class="math inline">\(p(X^n \neq (X^n)&#39;) \to 0\)</span></p>
<p>反之，对于任何稳态随机过程，如果<span class="math inline">\(H(X) &gt; C\)</span>，那么不存在使得<span class="math inline">\(p(X^n \neq (X^n)&#39;) \to 0\)</span>的一种联合编码方案</p></li>
</ul>
<p>感觉该知道的都差不多了....先记到这里...</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>information theory</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑谜语人</title>
    <url>/2022/05/logic/</url>
    <content><![CDATA[<span id="more"></span>
<p>参考的教材为宋公的《数理逻辑十二讲》，这本书挺一言难尽的</p>
<h2 id="完全性定理">完全性定理</h2>
<h4 id="描述">描述</h4>
<p>在一阶逻辑和其对应的自然推理系统，<span class="math inline">\(\Gamma \vdash \Delta \Leftrightarrow \Gamma \models \Delta\)</span></p>
<h4 id="证明">证明</h4>
<p>分为两部分证明</p>
<hr />
<p><span class="math inline">\(Soundness\)</span>：<span class="math inline">\(\Gamma \vdash \Delta \Rightarrow \Gamma \models \Delta\)</span></p>
<p><span class="math inline">\(\Gamma \vdash \Delta\)</span>即可证，那么存在一个证明树<span class="math inline">\(T\)</span>，我们按照该证明树证明<span class="math inline">\(\Gamma \models \Delta\)</span>有效</p>
<p>引理4.8：<span class="math inline">\(G\)</span>的公理有效</p>
<p>引理4.9：对于除Cut以外的规则，所有上矢列有效，当且仅当下矢列有效</p>
<p>对于Cut规则，上矢列有效，则下矢列有效，反之不然</p>
<p>利用引理4.8和4.9，我们就能证明<span class="math inline">\(Soundness\)</span></p>
<hr />
<p><span class="math inline">\(Completeness\)</span>：<span class="math inline">\(\Gamma \models \Delta \Rightarrow \Gamma \vdash \Delta\)</span></p>
<p>可以选择利用和上面差不多的说辞来证明，说明存在一个不利用Cut规则的证明树即可，这里不选择这条路</p>
<p>书中选择了从协调性的理论出发，具体而言，需要利用<strong>定理6.19</strong>：若<span class="math inline">\(\Gamma\)</span>协调，则<span class="math inline">\(\Gamma\)</span>可满足</p>
<p><strong>定理6.17</strong>：如果<span class="math inline">\(\Gamma\)</span>协调，那么存在<span class="math inline">\(\Gamma \subseteq \Phi\)</span>，使得<span class="math inline">\(\Phi\)</span>为Henkin集</p>
<p><strong>定理6.18</strong>：若<span class="math inline">\(\Phi\)</span>为Henkin集，那么<span class="math inline">\(\Phi\)</span>为Hintikka集</p>
<p><strong>定理3.26</strong>：若<span class="math inline">\(\Phi\)</span>为Hintikka集，那么<span class="math inline">\(\Phi\)</span>可满足</p>
<p>根据上述三条定理，我们就足以证明定理6.19</p>
<p>利用定理6.19和协调的定义，我们可以证明completeness（定理6.20）</p>
<h2 id="紧性定理">紧性定理</h2>
<h4 id="描述-1">描述</h4>
<p>设<span class="math inline">\(\Gamma\)</span>为命题的集合，若<span class="math inline">\(\Gamma\)</span>的任何有穷子集可满足，那么<span class="math inline">\(\Gamma\)</span>可满足</p>
<h4 id="可满足与协调">可满足与协调</h4>
<p>定理6.19实际上告诉我们：可满足性等价于协调性</p>
<p>因此，我们可以说明<span class="math inline">\(Con(\Gamma)\)</span>，反设不协调，那么存在一个有限子集不可满足，矛盾</p>
<h4 id="语义证明">语义证明</h4>
<p>我们先给出上滤和超滤的定义</p>
<ul>
<li><p>对于集合<span class="math inline">\(E\)</span>，记其幂集为<span class="math inline">\(\mathscr{P}(E)\)</span>，称<span class="math inline">\(F \subseteq \mathscr{P}(E)\)</span>当且仅当</p>
<ul>
<li><span class="math inline">\(E \in F\)</span></li>
<li><span class="math inline">\(A, B \in F \Rightarrow A \cap B \in F\)</span></li>
<li><span class="math inline">\(A \in F, A \subseteq B \Rightarrow B \in F\)</span></li>
<li><span class="math inline">\(\emptyset \notin F\)</span></li>
</ul></li>
<li><p><span class="math inline">\(F\)</span>为<span class="math inline">\(E\)</span>超滤指<span class="math inline">\(F\)</span>为<span class="math inline">\(E\)</span>的极大上滤</p></li>
<li><p>对于幂集的一个子集，<span class="math inline">\(C \subseteq \mathscr{P}(E)\)</span>，称<span class="math inline">\(C\)</span>有有穷交性质（也称<span class="math inline">\(C\)</span>有f.i.p.），当且仅当</p>
<p><span class="math inline">\(\forall A_1, ..., A_n \in C, A_1 \cap A_2 ... \cap A_n \neq \emptyset\)</span></p></li>
</ul>
<hr />
<p>在下文中，我们将使用小写字母来指代公式，<span class="math inline">\(\Delta\)</span>来指代公式的集合，大写字母来指代公式的集合的幂集的元素，花体来指代公式的集合的幂集的子集</p>
<p>设<span class="math inline">\(\Gamma\)</span>是一个有穷可满足的命题集，我们设<span class="math inline">\(\mathscr{O}(\Gamma) = \{\Delta | \Delta 为\Gamma的有穷子集\}\)</span>，自然<span class="math inline">\(\mathscr{O}(\Gamma) \subseteq \mathscr{P}(\Gamma)\)</span></p>
<p>对于<span class="math inline">\(\Delta \in \mathscr{O}(\Gamma)\)</span>，我们记<span class="math inline">\(v_{\Delta}\)</span>为满足满足<span class="math inline">\(\Delta\)</span>的赋值</p>
<p>令<span class="math inline">\(A^{\subseteq} = \{\Delta \in I| a \in \Delta \}\)</span>，也即所有包含公式<span class="math inline">\(a\)</span>的集合构成的集合</p>
<p>令<span class="math inline">\(\mathscr{C}(\Gamma) = \{A^{\subseteq} | a \in \Gamma\}\)</span></p>
<p><strong>命题11.8</strong>：<span class="math inline">\(\mathscr{C}(\Gamma)\)</span>有f.i.p.</p>
<p>注意到<span class="math inline">\(\{a_1, a_2, ..., a_n\} \in A_1^\subseteq \cap A_2^\subseteq ... \cap A_n^\subseteq\)</span></p>
<p><strong>命题11.4</strong>：如果<span class="math inline">\(C\)</span>有f.i.p.，那么存在一个包含<span class="math inline">\(C\)</span>的超滤<span class="math inline">\(U\)</span>，（且<span class="math inline">\(U\)</span>保持了f.i.p.）</p>
<p>不难想象，命题11.4的正确性和AC等价</p>
<p>根据命题11.4，我们取一个包含<span class="math inline">\(\mathscr{C}(\Gamma)\)</span>的超滤<span class="math inline">\(\mathscr{U}\)</span></p>
<p><strong>命题11.9</strong>：若<span class="math inline">\(a \in \Gamma\)</span>，那么<span class="math inline">\(\{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta} \models a\} \in \mathscr{U}\)</span></p>
<p><span class="math inline">\(a \in \Gamma\)</span>，因此<span class="math inline">\(A^{\subseteq} \in \mathscr{C}(\Gamma) \subseteq\mathscr{U}\)</span></p>
<p>由于<span class="math inline">\(A^{\subseteq}\)</span>中的子集都是有穷的，从而是可满足的，因此<span class="math inline">\(A^{\subseteq} \subseteq \{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta} \models a\}\)</span></p>
<p>根据上滤的性质，<span class="math inline">\(\{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta} \models a\} \in \mathscr{U}\)</span></p>
<p><strong>命题11.3</strong>：<span class="math inline">\(U\)</span>为上滤，且有f.i.p.，那么<span class="math inline">\(U\)</span>为超滤当且仅当<span class="math inline">\(\forall X \subseteq E\)</span>，<span class="math inline">\(X \in U \leftrightarrow (E-X) \notin U\)</span></p>
<p>按定义证明</p>
<p><strong>命题11.10</strong>：对于<span class="math inline">\(\Gamma\)</span>，和其由上定义的<span class="math inline">\(\mathscr{U}\)</span>，<span class="math inline">\(\mathscr{O}(\Gamma)\)</span></p>
<p>定义赋值<span class="math inline">\(v\)</span>为：<span class="math inline">\(v(P) = T \Leftrightarrow \{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta}(P) = T\} \in \mathscr{U}\)</span>，那么，<span class="math inline">\(v \models \Gamma\)</span></p>
<hr />
<p>证明：首先，我们要给出这个赋值的一些性质</p>
<ul>
<li><span class="math inline">\(v(P) = F \Leftrightarrow \{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta}(P) = F\} \in \mathscr{U}\)</span></li>
</ul>
<p>注意到如果<span class="math inline">\(v(P) = F\)</span>，那么<span class="math inline">\(\{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta}(P) = T\} \notin \mathscr{U}\)</span>，根据命题11.3，我们有<span class="math inline">\(\{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta}(P) = F\} \in \mathscr{U}\)</span>，反之同理</p>
<p>根据赋值的以上的性质，我们有</p>
<ul>
<li>对任何公式<span class="math inline">\(a\)</span>，<span class="math inline">\(v(a) = T(F) \Leftrightarrow \{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta}(a) = T(F)\} \in \mathscr{U}\)</span></li>
</ul>
<p>现在，对于任何公式<span class="math inline">\(a \in \Gamma\)</span>，根据命题11.9，有<span class="math inline">\(\{\Delta \in \mathscr{O}(\Gamma) | v_{\Delta} \models a\} \in \mathscr{U}\)</span>，根据以上的结论，有<span class="math inline">\(v \models T\)</span> <span class="math inline">\(\square\)</span></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>logic</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵分析 1</title>
    <url>/2021/07/matrix-analysis-1/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="矩阵之间的关系">矩阵之间的关系</h4>
<ul>
<li><strong>相抵</strong>：存在非奇异矩阵<span class="math inline">\(P, Q\)</span>，使得<span class="math inline">\(B = PAQ\)</span>时，则称<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>相抵</li>
<li><strong>相似</strong>：存在非奇异方阵<span class="math inline">\(P\)</span>，使得<span class="math inline">\(B = P^{-1}AP\)</span>时，称<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>相似</li>
<li><strong>合同</strong>：存在非奇异方阵<span class="math inline">\(P\)</span>，使得<span class="math inline">\(B = P^TAP\)</span>时，称<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>合同</li>
</ul>
<h4 id="特征值">特征值</h4>
<ul>
<li><p>对于方阵<span class="math inline">\(A\)</span>，如果存在<span class="math inline">\(\lambda \in P\)</span>以及非零向量<span class="math inline">\(x \in V^n\)</span>，使得<span class="math inline">\(Ax = \lambda x\)</span>，则称<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(A\)</span>的<strong>特征值</strong>，<span class="math inline">\(x\)</span>为<span class="math inline">\(A\)</span>的<strong>特征向量</strong></p></li>
<li><p><span class="math inline">\(Ax = \lambda x \Leftrightarrow (\lambda I - A)x = 0\)</span>，因此非零向量<span class="math inline">\(x\)</span>存在，要求<span class="math inline">\(|\lambda I - A| = 0\)</span>，称<span class="math inline">\(f(\lambda) = |\lambda I - A|\)</span>为矩阵<span class="math inline">\(A\)</span>的<strong>特征多项式</strong></p>
<ul>
<li><span class="math inline">\(|\lambda I - A| = \lambda^n + \sum_{k=1}^n (-1)^k A_k \lambda^{n-k} = \prod(\lambda - \lambda_i)\)</span>，其中<span class="math inline">\(A_k\)</span>表示矩阵<span class="math inline">\(A\)</span>的所有<span class="math inline">\(k\)</span>阶主子式的和，<span class="math inline">\(\lambda_1, ..., \lambda_n\)</span>表示矩阵<span class="math inline">\(A\)</span>的所有特征值</li>
<li>对于上式中的<span class="math inline">\(A_1\)</span>，即<span class="math inline">\(a_{11} + a_{22} + ... + a_{nn}\)</span>，我们称其为矩阵的迹，记做<span class="math inline">\(tr(A)\)</span>，由根与系数的关系，我们知道<span class="math inline">\(A_1 = tr(A) = \sum \lambda_i\)</span>，<span class="math inline">\(A_n = |A| = \prod\lambda_i\)</span></li>
</ul></li>
<li><p>example</p>
<p>矩阵</p>
<p><span class="math display">\[A = \begin{pmatrix}
0 &amp;  0&amp; 0 &amp; \dots &amp; 0 &amp;-a_{n} \\
1&amp; 0 &amp; 0 &amp; \dots &amp; 0 &amp; -a_{n-1}\\ 
0 &amp; 1 &amp; 0 &amp; \dots &amp;  0&amp; -a_{n-2}\\ 
\dots &amp;\dots  &amp; \dots &amp; \dots &amp;  \dots&amp; \dots \\\
0&amp; 0 &amp;0  &amp; \dots &amp; 1&amp;-a_1 
\end{pmatrix}\]</span></p>
<p>的特征多项式为<span class="math inline">\(f(\lambda) = \lambda^n + a_1 \lambda^{n-1} + ... + a_n\)</span></p></li>
<li><p>对可逆矩阵<span class="math inline">\(A, B \in C^{n*n}\)</span>，由<span class="math inline">\(|\lambda I - B| = |A^{-1}| |\lambda I - B| |A| = |\lambda I - A^{-1}BA|\)</span>，可以知道相似矩阵之间有相同的特征的多项式，从而由相同的特征值，相同的迹</p></li>
<li><p>对<span class="math inline">\(A \in C^{m \times n}, B \in C^{n \times m}\)</span>，由<span class="math inline">\(\lambda^n | \lambda I_m - AB| = \lambda^m |\lambda I_n - BA|\)</span>，我们可以知道<span class="math inline">\(AB\)</span>与<span class="math inline">\(BA\)</span>有相同的非零特征值</p></li>
<li><p>设<span class="math inline">\(\lambda_i\)</span>是<span class="math inline">\(|\lambda I - A|\)</span>的<span class="math inline">\(m_i\)</span>重根，则称<span class="math inline">\(m_i\)</span>是<span class="math inline">\(\lambda_i\)</span>的<strong>代数重复度</strong>，注意到<span class="math inline">\(\sum m_i = n\)</span></p></li>
<li><p>记<span class="math inline">\(V_{\lambda_i} = \{x:(\lambda_i I - A)x = 0\}\)</span>为<span class="math inline">\(A\)</span>的属于<span class="math inline">\(\lambda_i\)</span>的<strong>特征子空间</strong>，并称<span class="math inline">\(\dim (V_{\lambda_i})\)</span>为<span class="math inline">\(\lambda_i\)</span>的<strong>几何重复度</strong></p></li>
<li><p><strong>几何重复度</strong>不大于<strong>代数重复度</strong></p>
<ul>
<li>通过代数重复度构造出一组包含<span class="math inline">\((\lambda_i I - A)x = 0\)</span>的基础解系的基，记这组基的坐标为<span class="math inline">\(C\)</span>，考虑<span class="math inline">\(C^{-1}AC\)</span>的特征多项式</li>
</ul></li>
<li><p>设<span class="math inline">\(\lambda_1, ..., \lambda_r\)</span>是矩阵<span class="math inline">\(A\)</span>的不同的特征值，<span class="math inline">\(x_{1}^{(i)}, ..., x_{s_i}^{(i)}\)</span>是属于<span class="math inline">\(\lambda_i\)</span>的线性无关的特征向量，那么<span class="math inline">\(x_1^{(1)}, ..., x_{s_1}^{(1)}, ..., x_1^{(r)}, ..., x_{s_r}^{(r)}\)</span>也是线性无关的</p>
<ul>
<li>利用线性无关的充要条件为零向量的组合系数仅有<span class="math inline">\(0\)</span>，对于<span class="math inline">\(kx^{(i)}\)</span>，注意到乘以<span class="math inline">\(\lambda_j\)</span>和<span class="math inline">\(Ax^{(i)} = \lambda_i x^{(i)}\)</span>将是两种不一样的变化即可</li>
</ul></li>
<li><p>矩阵<span class="math inline">\(A\)</span>可对角化（和对角矩阵相似）的充要条件为<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量</p>
<ul>
<li><p>注意到以这<span class="math inline">\(n\)</span>个特征向量为基即可，也因此，相似中的转移矩阵即为这<span class="math inline">\(n\)</span>个特征向量的坐标</p></li>
<li><p>注意和对角矩阵相似时，相似中的转移矩阵和对角矩阵一定会对应于特征值和相应的特征向量</p></li>
<li><p>如果<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量，则称<span class="math inline">\(A\)</span>有完备的特征向量系</p>
<p>否则，称<span class="math inline">\(A\)</span>为<strong>亏损矩阵</strong></p></li>
<li><p>如果每个代数重复度和几何重复度相等，则称<span class="math inline">\(A\)</span>为<strong>单纯矩阵</strong></p></li>
<li><p><span class="math inline">\(A\)</span>可对角化的充要条件有其他不同的表述，比如<span class="math inline">\(V^n = V_{\lambda_1} \oplus ... \oplus V_{\lambda_r}\)</span></p></li>
</ul></li>
</ul>
<h4 id="不变子空间">不变子空间</h4>
<ul>
<li>对于线性变换<span class="math inline">\(\mathscr{A}\)</span>，如果<span class="math inline">\(\mathscr{A}W \subseteq W\)</span>，则称<span class="math inline">\(W\)</span>为<span class="math inline">\(\mathscr{A}\)</span>的<strong>不变子空间</strong></li>
<li>有两类较为容易发现的子空间
<ul>
<li><span class="math inline">\(\ker \mathscr{A} = \mathscr{A}^{-1}(0) = \{x:\mathscr{A}x = 0\}\)</span>，核空间</li>
<li><span class="math inline">\(\text{Im} \mathscr{A} = \mathscr{A}V\)</span>，值域</li>
<li>联系方程组，我们可以知道，若线性变换<span class="math inline">\(\mathscr{A}\)</span>对应于矩阵<span class="math inline">\(A\)</span>，核空间实际上对应于<span class="math inline">\(A\)</span>的解空间，我们记<span class="math inline">\(\dim \ker \mathscr{A} = \text{null } A\)</span>，而值域实际上是<span class="math inline">\(A\)</span>的列向量张成的空间，因此其维数应该是<span class="math inline">\(\text{rank} A\)</span></li>
<li><strong>维数公式</strong>：$ A + A = n $</li>
</ul></li>
</ul>
<h4 id="schur-th">Schur TH</h4>
<ul>
<li><p>任何<span class="math inline">\(n\)</span>阶矩阵都酉相似于一个上三角阵，即存在一个<span class="math inline">\(n\)</span>阶酉矩阵<span class="math inline">\(U\)</span>和一个上三角阵<span class="math inline">\(T\)</span>，使得</p>
<p><span class="math display">\[A = UTU^H\]</span></p>
<p>式中<span class="math inline">\(T\)</span>的主对角元为<span class="math inline">\(A\)</span>的特征值</p>
<ul>
<li>每一次选择一个特征向量后进行归纳</li>
</ul></li>
<li><p>如果<span class="math inline">\(A^H = A\)</span>，则称<span class="math inline">\(A\)</span>为<strong>埃米尔特矩阵</strong></p>
<ul>
<li>对埃米尔特矩阵运用Schur TH：<span class="math inline">\(A = UTU^H\)</span>，从而<span class="math inline">\(A^H = UT^HU^H\)</span>，由<span class="math inline">\(A=A^H\)</span>，我们得到<span class="math inline">\(T = T^H\)</span>，也就是说，<span class="math inline">\(T\)</span>是对角矩阵，并且<span class="math inline">\(A\)</span>的特征值都是实数</li>
</ul></li>
</ul>
<h4 id="正定矩阵">正定矩阵</h4>
<ul>
<li><p>对于埃米尔特矩阵<span class="math inline">\(A\)</span>，如果<span class="math inline">\(x^HAx\geq 0\)</span>，则称<span class="math inline">\(A\)</span>为半正定矩阵，记作<span class="math inline">\(A\geq 0\)</span>；类似的，如果<span class="math inline">\(x^HAx &gt; 0\)</span>，则称<span class="math inline">\(A\)</span>为正定矩阵，记作<span class="math inline">\(A&gt;0\)</span></p>
<ul>
<li>如果<span class="math inline">\(A&gt;0\)</span>，<span class="math inline">\(k&gt;0\)</span>，那么<span class="math inline">\(kA&gt;0\)</span></li>
<li>如果<span class="math inline">\(A \geq 0, B \geq 0\)</span>，那么<span class="math inline">\(A+B\geq 0\)</span></li>
</ul></li>
<li><p>矩阵<span class="math inline">\(A\)</span>正定（半正定）的充要条件是其特征值都是正数（非负数）</p>
<ul>
<li>神奇恒等式：设<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(A\)</span>的特征值，<span class="math inline">\(\xi\)</span>为对应的单位特征向量，那么<span class="math inline">\(\lambda = \xi^HA\xi\)</span></li>
</ul></li>
<li><p>矩阵<span class="math inline">\(A\)</span>为正定（半正定）矩阵的充要条件为存在非奇异矩阵（矩阵）<span class="math inline">\(P\)</span>，使得<span class="math inline">\(A=P^HP\)</span></p>
<ul>
<li>如果<span class="math inline">\(A&gt;0\)</span>，那么<span class="math inline">\(A^{-1}&gt;0\)</span></li>
<li>如果<span class="math inline">\(A&gt;0\)</span>，且<span class="math inline">\(C\)</span>非奇异，则<span class="math inline">\(C^HAC&gt;0\)</span></li>
<li>如果<span class="math inline">\(A \geq 0\)</span>，则<span class="math inline">\(C^HAC \geq 0\)</span></li>
</ul></li>
<li><p>设<span class="math inline">\(A,B\)</span>都是<span class="math inline">\(n\)</span>阶埃米尔特矩阵，且<span class="math inline">\(B&gt;0\)</span>，则存在非奇异矩阵<span class="math inline">\(Q\)</span>，使得<span class="math inline">\(Q^HBQ=I, Q^HAQ=\text{diag}\{\lambda_1, ..., \lambda_n\}\)</span>（可同时对角化），且<span class="math inline">\(\lambda_1,...,\lambda_n\)</span>为<span class="math inline">\(AB^{-1}\)</span>的特征值</p></li>
<li><p>如果<span class="math inline">\(A-B\geq 0\)</span>，那么称<span class="math inline">\(A\)</span>大于等于<span class="math inline">\(B\)</span>，记做<span class="math inline">\(A\geq B\)</span></p>
<ul>
<li><p>这不是一个well order...</p></li>
<li><p><span class="math inline">\(A \geq B\)</span>等价于<span class="math inline">\(x^HAx\geq x^HBx\)</span>恒成立</p>
<p>以下性质几乎是显然的</p>
<ul>
<li><p>如果<span class="math inline">\(A, B\)</span>是对角阵，那么条件也等价于<span class="math inline">\(a_{ii} \geq b_{ii}\)</span></p></li>
<li><p><span class="math inline">\(A \geq B, B \geq C\)</span>可得<span class="math inline">\(A \geq C\)</span></p></li>
<li><p><span class="math inline">\(A \geq B\)</span>，且<span class="math inline">\(k&gt;0\)</span>，那么<span class="math inline">\(kA \geq kB\)</span></p></li>
<li><p>若<span class="math inline">\(A_1 \geq B_1, A_2 \geq B_2\)</span>，那么<span class="math inline">\(A_1 + A_2 \geq B_1 + B_2\)</span></p></li>
<li><p>若<span class="math inline">\(A \geq B\)</span>，那么<span class="math inline">\(P^HAP\geq P^HBP\)</span></p></li>
</ul></li>
<li><p>若<span class="math inline">\(A \geq 0\)</span>，则<span class="math inline">\(A \leq tr(A)I\)</span>（利用<span class="math inline">\(tr(A)\geq \lambda_i\)</span>）</p></li>
<li><p>若<span class="math inline">\(A\geq B\)</span>，则<span class="math inline">\(B^{-1} \geq A^{-1}\)</span></p></li>
<li><p>若<span class="math inline">\(A, B\)</span>可交换，且<span class="math inline">\(A \geq B\)</span>，那么<span class="math inline">\(A^2 \geq B^2\)</span></p></li>
<li><p><span class="math inline">\(Schwartz\)</span>不等式：若<span class="math inline">\(A,B\)</span>分别为<span class="math inline">\(n\times m, m \times l\)</span>的矩阵，且<span class="math inline">\(AA^H\)</span>非奇异，则<span class="math inline">\(B^HB \geq (AB)^H(AA^H)^{-1}(AB)\)</span>，等号成立当且仅当存在<span class="math inline">\(n \times l\)</span>的矩阵<span class="math inline">\(C\)</span>，使<span class="math inline">\(B=A^HC\)</span></p></li>
</ul></li>
<li><p>对埃尔米特矩阵<span class="math inline">\(A\)</span>，有<span class="math inline">\(\lambda_{min} I \leq A \leq \lambda_{max} I\)</span></p></li>
<li><p>定义：记<span class="math inline">\(R(x) = \frac{x^HAx}{x^Hx}\)</span>，称其为<strong>诶尔米特矩阵</strong><span class="math inline">\(A\)</span>的瑞利商</p>
<ul>
<li>瑞利商是实数（注意到<span class="math inline">\(R(x) = R(x)^H\)</span>）</li>
<li><span class="math inline">\(\forall k \neq 0, R(kx) = R(x)\)</span></li>
<li><span class="math inline">\(\lambda_{min} \leq R(x) \leq \lambda_{max}\)</span>，并且可以取得等号</li>
</ul></li>
<li><p><strong>极大极小定理</strong>：设<span class="math inline">\(A\)</span>是<span class="math inline">\(n\)</span>阶埃尔米特矩阵，其特征值为<span class="math inline">\(\lambda_1 \geq \lambda_2 ... \geq \lambda_n\)</span>，<span class="math inline">\(V_i\)</span>是<span class="math inline">\(C^n\)</span>中<span class="math inline">\(i\)</span>维子空间，那么</p>
<p><span class="math display">\[\lambda_i = \max_{V_i} \min_{x \in V_i, x \neq 0} R(x)\]</span></p>
<p><span class="math display">\[\lambda_{n-i+1} = \min_{V_i} \max_{x \in V_i, x \neq 0} R(x)\]</span></p>
<ul>
<li>这个定理初看可能相当地令人疑惑，我们可以这么考虑，取<span class="math inline">\(x_1, x_2, ..., x_n\)</span>为分别属于<span class="math inline">\(\lambda_1, ..., \lambda_n\)</span>的特征向量，并且其构成标准正交向量基，那么对于<span class="math inline">\(\lambda_i\)</span>而言，当我们考虑<span class="math inline">\(Span(x_1, ..., x_i)\)</span>时，这个空间中的最小值恰好就是<span class="math inline">\(\lambda_i\)</span>，而对于其他的<span class="math inline">\(i\)</span>维空间，必然跟<span class="math inline">\(Span(x_{i+1}, ..., x_n)\)</span>有交，此时<span class="math inline">\(Span(x_{i+1}, ..., x_n)\)</span>中向量的存在将使最小值比<span class="math inline">\(\lambda_i\)</span>小，从而取到等号</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>matrix_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵分析 2</title>
    <url>/2021/07/matrix-analysis-2/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="lambda矩阵"><span class="math inline">\(\lambda\)</span>矩阵</h4>
<ul>
<li><span class="math inline">\(\lambda\)</span>矩阵：矩阵中的每一项都是关于<span class="math inline">\(\lambda\)</span>的多项式的矩阵称为<span class="math inline">\(\lambda\)</span>矩阵</li>
<li><span class="math inline">\(\lambda\)</span>矩阵的秩：若<span class="math inline">\(A(\lambda)\)</span>至少有一个<span class="math inline">\(r\)</span>阶子式不是零多项式，并且所有的<span class="math inline">\(r+1\)</span>阶子式都是零多项式，则称<span class="math inline">\(A(\lambda)\)</span>的秩为<span class="math inline">\(r\)</span>，记作<span class="math inline">\(\text{rank} A(\lambda)\)</span></li>
<li>可逆矩阵：<span class="math inline">\(A(\lambda)\)</span>称作可逆矩阵，当且仅当存在<span class="math inline">\(B(\lambda)\)</span>，使得<span class="math inline">\(A(\lambda) B(\lambda) = B(\lambda)A(\lambda) = I\)</span>，并且，记<span class="math inline">\(B(\lambda) = A(\lambda)^{-1}\)</span></li>
<li>可逆矩阵的充要条件：<span class="math inline">\(A(\lambda)\)</span>可逆，当且仅当<span class="math inline">\(|A(\lambda)|\)</span>是一个非零常数</li>
<li>如果存在可逆矩阵<span class="math inline">\(P(\lambda), Q(\lambda)\)</span>，使得<span class="math inline">\(B(\lambda) = P(\lambda) A(\lambda) Q(\lambda)\)</span>，则称<span class="math inline">\(B(\lambda)\)</span>与<span class="math inline">\(A(\lambda)\)</span>相抵，记作<span class="math inline">\(A(\lambda) \simeq B(\lambda)\)</span></li>
</ul>
<h4 id="lambda矩阵的标准形"><span class="math inline">\(\lambda\)</span>矩阵的标准形</h4>
<ul>
<li><p>每个<span class="math inline">\(A(\lambda)\)</span>都相抵与一个Smith标准形，即</p>
<p><span class="math display">\[A(\lambda) \simeq \text{diag} \{ d_1(\lambda), d_2(\lambda), ..., d_r(\lambda),0...0 \}\]</span></p>
<p>其中<span class="math inline">\(d_i(\lambda)\)</span>的首项系数为<span class="math inline">\(1\)</span>，并且<span class="math inline">\(d_{i - 1}(\lambda) \mid d_i(\lambda)\)</span></p>
<ul>
<li>考虑多项式的辗转相除，并利用归纳法</li>
</ul></li>
</ul>
<h4 id="不变因子行列式因子初等因子">不变因子，行列式因子，初等因子</h4>
<ul>
<li><p>不变因子：Smith标准形中的<span class="math inline">\(d_1(\lambda)\)</span>, <span class="math inline">\(d_2(\lambda)\)</span>, ..., <span class="math inline">\(d_r(\lambda)\)</span>称为<span class="math inline">\(A(\lambda)\)</span>的不变因子</p></li>
<li><p>行列式因子：<span class="math inline">\(A(\lambda)\)</span>的所有<span class="math inline">\(k\)</span>阶子式的最大公因式称为<span class="math inline">\(A(\lambda)\)</span>的<span class="math inline">\(k\)</span>阶行列式因子，记作<span class="math inline">\(D_k(\lambda)\)</span></p></li>
<li><p>初等因子：对于不变因子，不妨设<span class="math inline">\(d_i(\lambda) = \prod(\lambda - \lambda_j)^{r_{ij}}\)</span>，那么<span class="math inline">\((\lambda- \lambda_j)^{r_{ij}}\)</span>的全体称为初等因子</p></li>
<li><p>example</p>
<p><span class="math display">\[A(x) = \begin{pmatrix}
-x+1 &amp;x^2  &amp; x \\
 x&amp; x &amp;-x \\
 x^2+1 &amp; x^2 &amp; -x^2
\end{pmatrix}\]</span></p>
<p>的行列式因子为<span class="math inline">\(D_1(x) = 1, D_2(x) = x, D_3(x) = x^3+x^2\)</span></p>
<p>而其不变因子为<span class="math inline">\(d_1(x) = 1, d_2(x) = x, d_3(x) = x^2(x+1)\)</span></p>
<p>其初等因子则为<span class="math inline">\(x, x^2, (x+1)\)</span></p></li>
<li><p>相抵的矩阵有相同的秩和行列式因子</p>
<ul>
<li>只需要子式之间的整除关系即可</li>
</ul></li>
<li><p>在Smith标准形下，行列式因子和不变因子之间的关系是容易得出的：<span class="math inline">\(D_i(\lambda) = D_{i-1}(\lambda)d_i(\lambda)\)</span>，由此，我们得到结论：</p>
<ul>
<li>相抵的矩阵有相同的不变因子</li>
<li>相抵的矩阵有相同的Smith标准形，有相同的Smith标准形的矩阵相抵</li>
<li>一个矩阵的Smith标准形是唯一的</li>
</ul></li>
<li><p>初等因子和不变因子之间，在知晓秩的情况下，存在一一对应，因此在相抵变换下，初等因子也是不变的</p>
<ul>
<li>如果用初等因子来描述相抵，那么将是：两个有相同的初等因子和秩的矩阵相抵</li>
</ul></li>
<li><p>分块矩阵的初等因子是好求的：设<span class="math inline">\(A(\lambda) = \text{diag} \{ A_1(\lambda), A_2(\lambda), ..., A_m(\lambda)\}\)</span>，则<span class="math inline">\(A_i(\lambda)\)</span>的初等因子的全体的集合为<span class="math inline">\(A(\lambda)\)</span>的初等因子</p>
<ul>
<li>考虑两个分块子矩阵的Smith标准形和原矩阵的Smith标准形之间的系数关系</li>
</ul></li>
</ul>
<h4 id="若尔当标准形">若尔当标准形</h4>
<ul>
<li><p>若尔当块</p>
<p><span class="math display">\[J(x, k) = \begin{pmatrix}
x &amp;1  &amp; 0 &amp; 0 &amp; ... &amp; 0 \\
 0&amp; x &amp;1 &amp; 0 &amp; ... &amp; 0 \\
... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\ 0 &amp; 0&amp;0&amp;0&amp;...&amp;1\\ 0 &amp; 0&amp;0&amp;0&amp;...&amp;x\end{pmatrix}\]</span></p>
<p>考虑<span class="math inline">\(J(x, k)\)</span>的特征矩阵</p>
<p><span class="math display">\[\lambda I - J = \begin{pmatrix}
\lambda - x &amp; - 1  &amp; 0 &amp; 0 &amp; ... &amp; 0 \\
 0&amp; \lambda - x &amp; -1 &amp; 0 &amp; ... &amp; 0 \\
... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\ 0 &amp; 0&amp;0&amp;0&amp;...&amp;-1\\ 0 &amp; 0&amp;0&amp;0&amp;...&amp;\lambda - x\end{pmatrix}\]</span></p>
<p>由于去掉左边<span class="math inline">\(k\)</span>列和右边<span class="math inline">\(k\)</span>列的主子式的绝对值为<span class="math inline">\(1\)</span>，而<span class="math inline">\(|\lambda I - J| = (\lambda - x)^k\)</span></p>
<p>因此，其行列式因子为<span class="math inline">\(D_1(\lambda) = ... = D_{k-1}(\lambda) = 1\)</span>，而<span class="math inline">\(D_k(\lambda) = (\lambda - x)^k\)</span></p>
<p>那么，其不变因子为<span class="math inline">\(d_1(\lambda) = ... = d_{k-1}(\lambda) = 1\)</span>，而<span class="math inline">\(d_k(\lambda) = (\lambda - x)^k\)</span></p>
<p>初等因子则只有<span class="math inline">\((\lambda - x)^k\)</span></p></li>
<li><p>若尔当标准形</p>
<p>形如</p>
<p><span class="math display">\[J = \begin{pmatrix} J_1 &amp;&amp;&amp;\\ &amp;J_2&amp;&amp; \\&amp;&amp;...&amp; \\&amp;&amp;&amp;J_n \end{pmatrix}\]</span></p>
<p>的矩阵称为若尔当标准形，其中<span class="math inline">\(J_i\)</span>为若尔当块</p>
<p>由于<span class="math inline">\(J_i\)</span>的初等因子只有<span class="math inline">\((\lambda - \lambda_i)^{k_i}\)</span>，因此<span class="math inline">\(J\)</span>的初等因子为<span class="math inline">\((\lambda- \lambda_i)^{k_i}\)</span>的全体，并且<span class="math inline">\(\sum k_i = n\)</span></p></li>
<li><p>定理：矩阵<span class="math inline">\(A \sim B\)</span>的充要条件是<span class="math inline">\(\lambda I - A \cong \lambda I - B\)</span></p>
<p>这个定理的证明比较复杂，我们省去，关键在于利用<span class="math inline">\(\lambda I - A\)</span>是关于<span class="math inline">\(\lambda\)</span>的一次式进行次数限制</p></li>
<li><p>定理：每个<span class="math inline">\(A\)</span>都与一个若尔当标准形<span class="math inline">\(J\)</span>相似，并且这个若尔当标准形除了<span class="math inline">\(J\)</span>中若尔当块的排列顺序外，被<span class="math inline">\(A\)</span>所唯一决定</p>
<ul>
<li><p>由于<span class="math inline">\(|\lambda I - A|\)</span>的次数为<span class="math inline">\(n\)</span>，因此<span class="math inline">\(D_n(\lambda) = \prod (\lambda - \lambda_i)^{m_i}\)</span>，其中<span class="math inline">\(\sum m_i = n\)</span></p>
<p>由于<span class="math inline">\(D_n(\lambda) = \prod d_i(\lambda)\)</span>，因此初等因子的次数的和应该等于<span class="math inline">\(D_n(\lambda)\)</span>，也就是<span class="math inline">\(\lambda I - A\)</span>的初等因子的次数的和为<span class="math inline">\(n\)</span></p>
<p>不妨设<span class="math inline">\(\lambda I - A\)</span>的初等因子为<span class="math inline">\((\lambda - \lambda_i&#39;)^{m_i&#39;} (\sum m_i&#39; = n)\)</span>，对于每个<span class="math inline">\((\lambda - \lambda_i&#39;)^{m_i&#39;}\)</span>，存在若尔当块<span class="math inline">\(J_i\)</span>，使得<span class="math inline">\(\lambda I - J_i\)</span>以<span class="math inline">\((\lambda - \lambda_i&#39;)^{m_i&#39;}\)</span>作为初等因子</p>
<p>将这些<span class="math inline">\(J_i\)</span>组合在一起，得到一个若尔当标准形<span class="math inline">\(J\)</span></p>
<p><span class="math inline">\(\lambda I - J\)</span>与<span class="math inline">\(\lambda I - A\)</span>有相同的初等因子，并且秩相等，因此<span class="math inline">\(\lambda I - J \cong \lambda I - A\)</span>，而且<span class="math inline">\(J\)</span>是唯一确定的，由上一条定理知，<span class="math inline">\(A \sim J\)</span></p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>matrix_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵分析 3</title>
    <url>/2021/07/matrix-analysis-3/</url>
    <content><![CDATA[<span id="more"></span>
<p>这一章的内容十分的有趣</p>
<h4 id="三角分解">三角分解</h4>
<p>我们先对三角分解作一个简单的定义</p>
<ul>
<li>如果矩阵<span class="math inline">\(A\)</span>可以表示为一个上三角矩阵<span class="math inline">\(L\)</span>和一个下三角矩阵<span class="math inline">\(U\)</span>的乘积，即<span class="math inline">\(A = LU\)</span>，那么这种乘积称为<span class="math inline">\(A\)</span>的<strong>三角分解</strong>或<strong><span class="math inline">\(LU\)</span>分解</strong>，特别的，如果<span class="math inline">\(L\)</span>是单位下三角矩阵（主对角线上的元素为<span class="math inline">\(1\)</span>），那么此时的三角分解称为<strong>Doolittle分解</strong>，如果<span class="math inline">\(U\)</span>是单位上三角矩阵，那么称为<strong>Crout分解</strong></li>
</ul>
<p>在讨论三角分解的存在性之前，我们先对唯一性来作一些描述</p>
<p>如果<span class="math inline">\(A = LU\)</span>，并且<span class="math inline">\(L, U\)</span>都不是单位三角矩阵，那么对于任意<span class="math inline">\(k \neq 0\)</span>，<span class="math inline">\(A = (kL)(k^{-1}U)\)</span>将是另一种分解方式，而加入了单位三角矩阵的限制后，我们就有了下述结论</p>
<ul>
<li><p>对于方阵<span class="math inline">\(A\)</span>，其可以唯一地分解为</p>
<p><span class="math display">\[A = LDU\]</span></p>
<p>的充要条件为<span class="math inline">\(A\)</span>的前<span class="math inline">\(n - 1\)</span>个顺序主子式<span class="math inline">\(H_1,H_2,...,H_{n-1}\)</span>都不为<span class="math inline">\(0\)</span>，式中<span class="math inline">\(L, U\)</span>分别为单位下三角矩阵，单位上三角矩阵，<span class="math inline">\(D\)</span>为对角矩阵，并且设<span class="math inline">\(D = diag\{d_1,d_2,...,d_n\}\)</span>，则<span class="math inline">\(d_1 = 1, d_i = H_i/H_{i-1}\)</span></p>
<ul>
<li>这个定理的证明按照大小进行归纳即可</li>
</ul></li>
<li><p>由于<span class="math inline">\(LDU\)</span>分解是唯一的，因此Doolittle分解和Crout分解也都是唯一的</p></li>
</ul>
<p>我们还可以讨论特殊矩阵的<span class="math inline">\(LDU\)</span>分解</p>
<ul>
<li><p>对于对称正定矩阵<span class="math inline">\(A\)</span>，存在一个实的可逆下三角矩阵<span class="math inline">\(L\)</span>，使得</p>
<p><span class="math display">\[A = LL^T\]</span></p>
<p>在限定<span class="math inline">\(L\)</span>的对角线元素为正时，<span class="math inline">\(L\)</span>是唯一的</p>
<ul>
<li><p>存在性：由于<span class="math inline">\(A\)</span>的顺序主子式都大于<span class="math inline">\(0\)</span>，因此<span class="math inline">\(A\)</span>存在<span class="math inline">\(LDU\)</span>分解，不妨设<span class="math inline">\(A = LDU\)</span></p>
<p>由于<span class="math inline">\(A = A^T\)</span>，那么<span class="math inline">\(LDU = U^TDL^T\)</span>，由<span class="math inline">\(LDU\)</span>分解的唯一性，我们得到<span class="math inline">\(U^T = L\)</span></p>
<p>即<span class="math inline">\(A = LDL^T\)</span>，由于<span class="math inline">\(|A| \neq 0\)</span>，因此<span class="math inline">\(L, D\)</span>都可逆，那么<span class="math inline">\(D = L^{-1}A(L^{-1})^T\)</span>，如此，<span class="math inline">\(D\)</span>也是正定矩阵，因此<span class="math inline">\(D\)</span>中元素都将大于<span class="math inline">\(0\)</span>，设<span class="math inline">\(D = diag(d_1, d_2, ..., d_n)\)</span>，再设<span class="math inline">\(D&#39; = diag(\sqrt d_1, \sqrt d_2, ..., \sqrt d_n)\)</span>，那么<span class="math inline">\(A = (LD&#39;)(LD&#39;)^T\)</span>，由<span class="math inline">\(|LD&#39;| = |L||D&#39;| \neq 0\)</span>知<span class="math inline">\(LD&#39;\)</span>可逆</p></li>
<li><p>唯一性：设<span class="math inline">\(A = L_1L_1^T = L_2L_2^T\)</span>，则<span class="math inline">\((L_2^{-1}L_1) = (L_2^{-1}L_1)^T\)</span>，<span class="math inline">\(L_2^{-1}L_1\)</span>是上三角矩阵，因此<span class="math inline">\(L_2^{-1}L_1 = I\)</span>，即<span class="math inline">\(L_1 = L_2\)</span></p></li>
</ul></li>
</ul>
<h4 id="qr分解"><span class="math inline">\(QR\)</span>分解</h4>
<ul>
<li><p>如果实（复）非奇异矩阵<span class="math inline">\(A\)</span>能表示为一个正交（酉）矩阵<span class="math inline">\(Q\)</span>和一个实（复）非奇异上三角矩阵<span class="math inline">\(R\)</span>的乘积，那么</p>
<p><span class="math display">\[A = QR\]</span></p>
<p>就称为<span class="math inline">\(A\)</span>的<span class="math inline">\(QR\)</span>分解</p></li>
<li><p>任何非奇异矩阵<span class="math inline">\(A\)</span>都存在<span class="math inline">\(QR\)</span>分解，并且除了对角线上的元素差一个绝对值为<span class="math inline">\(1\)</span>的因子外，<span class="math inline">\(QR\)</span>分解是唯一的</p>
<ul>
<li><p>存在性：设<span class="math inline">\(A\)</span>的列向量为<span class="math inline">\((a_1, a_2, ..., a_n)\)</span>，其可以构成一组基，我们对这组基进行Schmidt正交化，得到一组标准正交基<span class="math inline">\((b_1, b_2, ..., b_n)\)</span></p>
<p>那么，由Schmidt正交化的公式<span class="math inline">\(b_i&#39; = a_i - \sum_{j &lt; i} b_j&#39; * \frac{(a_i, b_j)}{(b_j, b_j)}\)</span>，标准化之后乘一个非零常数，应该存在<span class="math inline">\(R\)</span>为非奇异上三角矩阵，使得<span class="math inline">\((b_1, b_2, ..., b_n) = (a_1, a_2, ..., a_n) R\)</span></p>
<p>由于<span class="math inline">\(R\)</span>可逆，那么<span class="math inline">\((a_1, a_2, ..., a_n) = (b_1,b_2,...,b_n)R^{-1}\)</span>，取<span class="math inline">\(Q = (b_1,b_2,...,b_n)\)</span>即可</p></li>
<li><p>唯一性：设<span class="math inline">\(A = Q_1R_1 = Q_2R_2\)</span>，那么<span class="math inline">\(Q_2^{-1}Q_1 = R_2R_1^{-1}\)</span>，<span class="math inline">\(Q_2^{-1}Q_1\)</span>为正交阵，<span class="math inline">\(R_2R_1^{-1}\)</span>为上三角阵，不难知道，<span class="math inline">\(Q_2^{-1}Q_1 = R_2R_1^{-1} = I\)</span>，即<span class="math inline">\(Q_1 = Q_2\)</span></p></li>
</ul></li>
</ul>
<h4 id="谱分解">谱分解</h4>
<h5 id="正规矩阵">正规矩阵</h5>
<ul>
<li>如果<span class="math inline">\(AA^H = A^HA\)</span>，则称<span class="math inline">\(A\)</span>为<strong>正规矩阵</strong></li>
<li>如果对实方阵<span class="math inline">\(A\)</span>，<span class="math inline">\(AA^T=A^TA\)</span>，则称<span class="math inline">\(A\)</span>为<strong>实正规矩阵</strong></li>
</ul>
<p>正规矩阵有一些较为简单的性质</p>
<ul>
<li><p>如果三角阵<span class="math inline">\(L\)</span>是正规矩阵，那么<span class="math inline">\(L\)</span>是对角阵</p>
<ul>
<li><p>由<span class="math inline">\(LL^H = LL^H\)</span>，我们有<span class="math inline">\(\sum_{k} \overline{l_{ki}} * l_{kj} = \sum_{k} \overline{l_{jk}} * l_{ik}\)</span>，而当<span class="math inline">\(i = j\)</span>时，有<span class="math inline">\(\sum_k |l_{ki}|^2 = \sum_k |l_{ik}|^2\)</span></p>
<p>不妨设<span class="math inline">\(L\)</span>是下三角阵，由于<span class="math inline">\(\sum_k |l_{k1}|^2 = \sum_k |l_{1k}|^2 = |l_{11}|^2\)</span>，我们得到<span class="math inline">\(l_{21} = l_{31} = ... = l_{n1} = 0\)</span>，之后对<span class="math inline">\(i = j = 2\)</span>进行讨论，得到<span class="math inline">\(l_{32} = ... = l_{n2} = 0\)</span>，依次类推，我们可以得到<span class="math inline">\(L\)</span>只在对角线上非零，即<span class="math inline">\(L\)</span>为对角阵</p></li>
</ul></li>
</ul>
<p>埃米尔特矩阵和酉矩阵都是正规矩阵，尝试将埃米尔特矩阵和酉矩阵的性质推导到正规矩阵上，一般来说，我们有下述定理</p>
<ul>
<li><p>方阵<span class="math inline">\(A\)</span>酉相似于对角阵的充要条件为<span class="math inline">\(A\)</span>是正规矩阵</p>
<p>考虑这个定理的证明</p>
<ul>
<li>充分性：根据Schur定理，存在酉矩阵<span class="math inline">\(U\)</span>，使得<span class="math inline">\(A = U^HLU\)</span>，其中<span class="math inline">\(L\)</span>为上三角阵，并且对角线上为<span class="math inline">\(A\)</span>的特征值，那么由<span class="math inline">\(A^HA= AA^H\)</span>，得到<span class="math inline">\(L^HL = LL^H\)</span>，由于<span class="math inline">\(L\)</span>同时是三角阵和正规阵，那么<span class="math inline">\(L\)</span>将是对角阵，因而<span class="math inline">\(A\)</span>与对角阵<span class="math inline">\(L\)</span>酉相似</li>
<li>必要性：设<span class="math inline">\(A = U^H \Lambda U\)</span>，其中<span class="math inline">\(\Lambda\)</span>为对角阵，那么<span class="math inline">\(AA^H = U^H \Lambda \Lambda^H U = U^H \Lambda^H \Lambda U = A^HA\)</span></li>
</ul></li>
</ul>
<p>如果<span class="math inline">\(A\)</span>酉相似于对角阵，即<span class="math inline">\(A = U^H \Lambda U\)</span>，那么矩阵<span class="math inline">\(U\)</span>可以看做是<span class="math inline">\(A\)</span>的特征向量的集合，而<span class="math inline">\(\Lambda\)</span>则为<span class="math inline">\(A\)</span>对应的特征值，因此<span class="math inline">\(A\)</span>将有<span class="math inline">\(n\)</span>个互相正交的单位特征向量</p>
<h5 id="谱分解-1">谱分解</h5>
<ul>
<li><p>对于正规矩阵<span class="math inline">\(A\)</span>，存在酉矩阵<span class="math inline">\(U\)</span>，使得<span class="math inline">\(A = U^H \Lambda U\)</span></p>
<p>记<span class="math inline">\(U = (u_1, u_2, ..., u_n)\)</span>，那么</p>
<p><span class="math display">\[\begin{align*}
 A &amp;= (u_1, u_2, ..., u_n)^H *diag(\lambda_1, \lambda_2,..., \lambda_n)* (u_1, u_2, ..., u_n)\\ 
 &amp;= \lambda_1 u_1^Hu_1 + \lambda_2 u_2^Hu_2 + ... + \lambda_nu_n^Hu_n
\end{align*}\]</span></p>
<p>我们称此为<span class="math inline">\(A\)</span>的谱分解或者特征值分解</p></li>
<li><p>如果我们将谱分解稍微改写形式<span class="math inline">\(A = \lambda_1(u_{11}^Hu_{11} + ...+u_{1s}^Hu_{1s}) + ... + \lambda_r(u_{r1}^Hu_{r1} + ...+u_{rs}^Hu_{rs})\)</span>，其中<span class="math inline">\(\lambda_i\)</span>互不相同</p>
<p>记<span class="math inline">\(P_1 = u_{11}^Hu_{11} + ...+u_{1s}^Hu_{1s}, ...,P_r = u_{r1}^Hu_{r1} + ...+u_{rs}^Hu_{rs}\)</span></p>
<p>由于<span class="math inline">\(u_{11}, ..., u_{1s}, ..., u_{r1}, ..., u_{rs}\)</span>两两正交，我们有<span class="math inline">\(P_iP_j = O, P_i^2 = P_i, P_i^H=P_i\)</span>，因此单独取出<span class="math inline">\(P_i\)</span>，其表示为一种正交投影</p></li>
</ul>
<h4 id="最大秩分解">最大秩分解</h4>
<ul>
<li><p>设<span class="math inline">\(A\)</span>是秩为<span class="math inline">\(r\)</span>的<span class="math inline">\(m * n\)</span>的矩阵，那么存在秩为<span class="math inline">\(r\)</span>的<span class="math inline">\(m * r\)</span>的矩阵<span class="math inline">\(B\)</span>以及<span class="math inline">\(r * n\)</span>的矩阵<span class="math inline">\(C\)</span>，使得</p>
<p><span class="math display">\[A = BC\]</span></p>
<p>也就是说，<span class="math inline">\(A\)</span>可以分解为两个满秩矩阵的积</p>
<ul>
<li><p>设<span class="math inline">\(A\)</span>的列向量为<span class="math inline">\(a_1, a_2, ...,a_n\)</span>，那么<span class="math inline">\(A = (a_1, a_2, ..., a_n)\)</span></p>
<p>不妨设列向量中的极大线性无关组为<span class="math inline">\((a_1, a_2, ..., a_r)\)</span>，由于<span class="math inline">\(a_1, a_2,..., a_n\)</span>中任意元素可以被<span class="math inline">\(a_1,...a_r\)</span>表出，不妨设<span class="math inline">\(a_i = \sum_{j=1}^r a_j c_{ji}\)</span></p>
<p>那么</p>
<p><span class="math display">\[A = (a_1, a_2,..., a_r) \begin{pmatrix} c_{11} &amp; c_{12} &amp; ... &amp; c_{1n} \\ c_{21} &amp; c_{22} &amp; ... &amp; c_{2n} \\ ... &amp;... &amp; ... &amp;... \\c_{r1} &amp; c_{r2} &amp; ... &amp; c_{rn}\end{pmatrix}\]</span></p>
<p>记</p>
<p><span class="math display">\[B = (a_1, a_2,..., a_r), C = \begin{pmatrix} c_{11} &amp; c_{12} &amp; ... &amp; c_{1n} \\ c_{21} &amp; c_{22} &amp; ... &amp; c_{2n} \\ ... &amp;... &amp; ... &amp;... \\c_{r1} &amp; c_{r2} &amp; ... &amp; c_{rn}\end{pmatrix}\]</span></p>
<p>由于<span class="math inline">\(r = rank(A) \leq \min\{rank(B), rank(C)\} \leq r\)</span>，因此两者秩都为<span class="math inline">\(r\)</span></p></li>
<li><p>注意到这个证明中，没有对所取的<span class="math inline">\(a_1,...,a_r\)</span>作任何的限制，因此，我们甚至可以限制<span class="math inline">\(a_1,...,a_r\)</span>为一组标准正交基</p></li>
</ul></li>
<li><p>example：</p>
<p>求</p>
<p><span class="math display">\[A = \begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; 0 \\3 &amp; 3 &amp; 2 &amp; 1\end{pmatrix}\]</span></p>
<p>的最大秩分解</p>
<p>我们可以利用初等行变化保持线性关系的性质</p>
<p>将<span class="math inline">\(A\)</span>化作行标准形</p>
<p><span class="math display">\[A&#39; = \begin{pmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}\]</span></p>
<p>取<span class="math inline">\(1, 3, 4\)</span>列的列向量作为极大线性无关组，即</p>
<p><span class="math display">\[B = \begin{pmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0  \\3 &amp; 2 &amp; 1\end{pmatrix}\]</span></p>
<p>再取<span class="math inline">\(A&#39;\)</span>中的非零行（也即组合系数），令</p>
<p><span class="math display">\[C = \begin{pmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p>
<p>那么<span class="math inline">\(A = BC\)</span>，且<span class="math inline">\(B, C\)</span>满秩</p></li>
</ul>
<h4 id="奇异值分解">奇异值分解</h4>
<p>矩阵的奇异值分解又称<strong>SVD(Singular Value Decomposition)分解</strong></p>
<h5 id="奇异值">奇异值</h5>
<ul>
<li><p>引理：矩阵<span class="math inline">\(AA^H\)</span>的特征值为非负实数</p>
<ul>
<li>矩阵<span class="math inline">\(AA^H\)</span>半正定，并且为埃尔米特矩阵，因此其特征值为非负实数</li>
</ul></li>
<li><p>对于矩阵<span class="math inline">\(A\)</span>，我们记<span class="math inline">\(AA^H\)</span>的特征值为<span class="math inline">\(\lambda_1, \lambda_2,...,\lambda_n\)</span>，我们称<span class="math inline">\(\sigma_i = \sqrt \lambda_{i}\)</span>为矩阵<span class="math inline">\(A\)</span>的奇异值</p></li>
<li><p>若<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>酉相抵（存在酉矩阵<span class="math inline">\(U, V\)</span>，使得<span class="math inline">\(B = UAV\)</span>），则<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>有相同的奇异值</p>
<ul>
<li><span class="math inline">\(B^HB = V^HA^HU^HUAV=V^H(A^HA)V = V^{-1}(A^HA)V\)</span>，那么<span class="math inline">\(B^HB\)</span>与<span class="math inline">\(A^HA\)</span>有相同的特征值，因此<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>有相同的奇异值</li>
</ul></li>
</ul>
<h5 id="奇异值分解-1">奇异值分解</h5>
<ul>
<li><p>对于任意<span class="math inline">\(n*m\)</span>大小的复矩阵<span class="math inline">\(A\)</span>，存在酉矩阵<span class="math inline">\(U, V\)</span>，使得</p>
<p><span class="math display">\[U^HAV = diag(\sigma_1, \sigma_2, ..., \sigma_r, 0, ..., 0)\]</span></p>
<p>其中<span class="math inline">\(\sigma_1, \sigma_2, ..., \sigma_r\)</span>为<span class="math inline">\(A\)</span>的非零奇异值</p>
<ul>
<li><p>下面的证明不仅给出了证明方法，而且还给出了构造的具体方法</p></li>
<li><p>由于<span class="math inline">\(AA^H\)</span>为埃尔米特矩阵，并且半正定，因此存在酉矩阵<span class="math inline">\(U\)</span>，使得</p>
<p><span class="math display">\[U^HAA^HU = diag(\sigma_1^2, \sigma_2^2, ..., \sigma_r^2, 0, ..., 0) \tag{a}\]</span></p>
<p>如果记<span class="math inline">\(U = (U_1, U_2)\)</span>，其中<span class="math inline">\(U_1\)</span>为<span class="math inline">\(U\)</span>的前<span class="math inline">\(r\)</span>个列向量构成的矩阵，那么我们可以得到<span class="math display">\[U_1^HAA^HU_1 = \Lambda^2 \tag{b}\]</span></p>
<p><span class="math display">\[U_2^HAA^HU_2 = O \tag{c}\]</span></p>
<p>由于<span class="math inline">\(AA^H = O\)</span>，当且仅当<span class="math inline">\(A = O\)</span>（考察对角线上的元素），因此<span class="math inline">\(U_2^HA = O\)</span></p>
<p>现在我们尝试构造<span class="math inline">\(V = (V_1, V_2)\)</span>，其中<span class="math inline">\(V_1\)</span>为<span class="math inline">\(n * r\)</span>的矩阵，使得<span class="math inline">\(U^HAV = \Lambda\)</span></p>
<p>不难知道</p>
<p><span class="math display">\[(U_1, U_2)^H A (V_1, V_2) = \begin{pmatrix} U_1^HAV_1 &amp; U_1^HAV_2\\ U_2^HAV_1 &amp; U_2^HAV_2 \end{pmatrix}\]</span></p>
<p>与<span class="math inline">\(\begin{pmatrix} \Lambda &amp; O\\ O &amp; O \end{pmatrix}\)</span>对比，我们得到<span class="math inline">\(U_1^HAV_1 = \Lambda, U_1^HAV_2 = U_2^HAV_1 =U_2^HAV_2=O\)</span></p>
<p>由于<span class="math inline">\(U_2^HA=O\)</span>，后面两项的成立是显然的，观察<span class="math inline">\((b)\)</span>式，我们知道取<span class="math inline">\(V_1 = A^HU_1 \Lambda^{-1}\)</span>可以满足要求，暂定<span class="math inline">\(V_1\)</span>，从而<span class="math inline">\(U_1^HAV_2 = \Lambda^{H} V_1^HV_2\)</span>，只需要取<span class="math inline">\(V_2\)</span>时，保证其与<span class="math inline">\(V_1\)</span>正交即可，这个当然是可以满足的</p>
<p>我们还需要确定<span class="math inline">\(V_1\)</span>满足酉矩阵的要求，代入<span class="math inline">\(V_1\)</span>，我们得到<span class="math inline">\(V_1^HV_1=(\Lambda^{-1})^H(U_1^HA A^HU_1)\Lambda^{-1} = \Lambda^{-1}\Lambda^2\Lambda^{-1} = I\)</span>，这也就证明了<span class="math inline">\(V_1\)</span>确实满足条件</p></li>
</ul></li>
</ul>
<h4 id="极分解">极分解</h4>
<ul>
<li><p>对于任意<span class="math inline">\(n*n\)</span>的复阵<span class="math inline">\(A\)</span>，存在酉矩阵<span class="math inline">\(U\)</span>和唯一的半正定矩阵<span class="math inline">\(G, H\)</span>，使得</p>
<p><span class="math display">\[A = GU = UH\]</span></p>
<ul>
<li><p>存在性：设<span class="math inline">\(A\)</span>的奇异值分解为<span class="math inline">\(A = U^H_0 \Lambda V\)</span></p>
<p>那么令<span class="math inline">\(G = U^H_0 \Lambda U, H = V^H \Lambda V, U_1 = U^H_0V\)</span>，得到<span class="math inline">\(A = GU_1 = U_1H\)</span></p></li>
<li><p>唯一性：由于<span class="math inline">\(U\)</span>可逆，唯一性显然</p></li>
</ul></li>
</ul>
<h4 id="可同时对角化">可同时对角化</h4>
<p>这个知识点感觉还是点一点...</p>
<p>一般在高等代数中，就会接触到一个结论</p>
<ul>
<li><p>设<span class="math inline">\(A, B\)</span>都是<span class="math inline">\(n\)</span>阶埃米尔特矩阵，且<span class="math inline">\(A\)</span>正定，那么存在非奇异矩阵<span class="math inline">\(Q\)</span>，使得</p>
<p><span class="math display">\[Q^{H}AQ = I, Q^HBQ= diag\{\lambda_1, \lambda_2, ...\lambda_n\}\]</span></p>
<ul>
<li><p>一般采取如下方式证明：由于<span class="math inline">\(A\)</span>正定，因此存在非奇异矩阵<span class="math inline">\(P\)</span>，使得<span class="math inline">\(P^HAP = I\)</span>，由于<span class="math inline">\(P^HBP\)</span>仍为埃尔米特矩阵，因此存在酉矩阵<span class="math inline">\(U\)</span>，使得<span class="math inline">\((PU)^H B (PU) = diag\{\lambda_1, ..., \lambda_n\}\)</span>，令<span class="math inline">\(Q = PU\)</span>即可</p></li>
<li><p>我们尝试考察<span class="math inline">\(\lambda_1,...,\lambda_n\)</span>的值，首先，它们是<span class="math inline">\(P^HBP\)</span>的特征值</p>
<p>注意到<span class="math inline">\(|\lambda I - P^HBP| = |\lambda P^HAP - P^HBP| = |P^H||P||A|*|\lambda I - A^{-1}B|\)</span></p>
<p>由于<span class="math inline">\(|P| \neq 0, |A| \neq 0\)</span>，因此<span class="math inline">\(\lambda_1, ... \lambda_n\)</span>也是<span class="math inline">\(A^{-1}B\)</span>的特征追</p></li>
</ul></li>
</ul>
<p>现在我们来考虑同时酉对角化的问题，也即</p>
<ul>
<li><p>设<span class="math inline">\(A, B\)</span>为正规矩阵，则<span class="math inline">\(A, B\)</span>可同时酉对角化的充要条件为<span class="math inline">\(AB = BA\)</span></p>
<ul>
<li><p>“<span class="math inline">\(\Rightarrow\)</span>”：设<span class="math inline">\(A = U^H \Lambda_1 U, B = U^H \Lambda_2 U\)</span>，则<span class="math inline">\(AB = BA\)</span>可以由<span class="math inline">\(\Lambda_1, \Lambda_2\)</span>的可交换性得出</p></li>
<li><p>“<span class="math inline">\(\Leftarrow\)</span>”：设<span class="math inline">\(A\)</span>对应于特征值<span class="math inline">\(a\)</span>的特征子空间为<span class="math inline">\(V_a\)</span>，取<span class="math inline">\(V_a\)</span>的一组标准正交基为<span class="math inline">\(a_1, a_2,...,a_r\)</span></p>
<p>注意到<span class="math inline">\(AB a_i = BAa_i = Baa_i = a (Ba_i)\)</span>，这说明<span class="math inline">\(Ba_1, Ba_2,...,Ba_r\)</span>也是<span class="math inline">\(V_a\)</span>中的元素，也说明<span class="math inline">\(BV_a \subseteq V_a\)</span></p>
<p>设从<span class="math inline">\(C^n\)</span>到<span class="math inline">\(V_a\)</span>的投影变换为<span class="math inline">\(P_a\)</span>，考虑线性映射<span class="math inline">\(B_a = P_aBP_a\)</span>，由于<span class="math inline">\(P_aV_a = V_a\)</span>，因此<span class="math inline">\(B_aV_a \subseteq V_a\)</span>，注意到<span class="math inline">\(B_aB_a^H = P_aBB^HP_a = P_aB^HBP_a = B_a^HB_a\)</span>，那么<span class="math inline">\(B_a\)</span>在<span class="math inline">\(V_a\)</span>上是一个正规变换，也就相应的对应于正规矩阵</p>
<p>设<span class="math inline">\(B_a\)</span>的线性无关的标准正交特征向量组为<span class="math inline">\(b_1,b_2,...,b_k\)</span>，由于<span class="math inline">\(b_i \in V_a\)</span>，因此<span class="math inline">\(b_i\)</span>是<span class="math inline">\(A\)</span>的一个特征向量，又<span class="math inline">\(B b_i = P_a B P_a b_i = B_ab_i\)</span>，这说明<span class="math inline">\(b_i\)</span>也是<span class="math inline">\(B\)</span>的一个特征向量</p>
<p>由于<span class="math inline">\(B_a\)</span>在<span class="math inline">\(V_a\)</span>上对应于正规矩阵，那么应该有<span class="math inline">\(k = r\)</span>，那么对于每个特征值，我们都能找到相应的公共特征向量，鉴于<span class="math inline">\(A\)</span>是正规矩阵，我们还可以把这些公共特征向量处理为正交的向量，因此得到两者可以同时酉对角化</p></li>
</ul></li>
<li><p>如果<span class="math inline">\(AB = BA\)</span>，且<span class="math inline">\(A, B\)</span>为正规矩阵，那么<span class="math inline">\(AB\)</span>也为正规矩阵</p>
<ul>
<li><span class="math inline">\(A, B\)</span>可同时酉对角化，设<span class="math inline">\(A = U^H \Lambda_1 U, B = U^H \Lambda_2 U\)</span>，那么<span class="math inline">\(AB = U^H \Lambda_1 \Lambda_2 U\)</span>，因此<span class="math inline">\(AB\)</span>酉相似于对角矩阵，如此<span class="math inline">\(AB\)</span>为正规矩阵</li>
<li>不难发现，<span class="math inline">\(AB\)</span>的特征值和<span class="math inline">\(A, B\)</span>的特征值之间存在关系，也即在按照同时酉对角化矩阵的顺序排列下时，有<span class="math inline">\(\lambda_{AB}^{(i)} = \lambda_{A}^{(i)} * \lambda_{B}^{(i)}\)</span>，且对应的特征向量也是相同的</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>matrix_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵分析 4</title>
    <url>/2021/07/matrix-analysis-4/</url>
    <content><![CDATA[<span id="more"></span>
<p>这一节来记一些乱七八糟的习题</p>
<blockquote>
<p><span class="math inline">\(AA^H\)</span>和<span class="math inline">\(A^HA\)</span>有相同的非零特征值</p>
</blockquote>
<p>我们可以考虑特征值的定义的角度来证明这一点</p>
<p>设<span class="math inline">\(\lambda\)</span>是<span class="math inline">\(AA^H\)</span>的特征向量，<span class="math inline">\(x\)</span>是对应的特征向量，即<span class="math inline">\(AA^Hx = \lambda x\)</span>，由于<span class="math inline">\(\lambda, x \neq 0\)</span>，因此<span class="math inline">\(\lambda x \neq 0\)</span>，从而<span class="math inline">\(A^Hx \neq 0\)</span>，那么由<span class="math inline">\((A^HA)(A^Hx) = \lambda(A^Hx)\)</span>知，<span class="math inline">\(\lambda\)</span>是<span class="math inline">\(A^HA\)</span>的特征值，那么，<span class="math inline">\(AA^H\)</span>的所有非零特征值都是<span class="math inline">\(A^HA\)</span>的非零特征值，反过来也是如此，因此两者非零特征值的集合是相同的</p>
<p>下面，我们还需要证明两者的特征值的代数重复度相同，由于<span class="math inline">\(AA^H, A^HA\)</span>都可对角化，我们只需要证明两者的几何重复度相同</p>
<p>设<span class="math inline">\(x_1, x_2, ..., x_n\)</span>是对应于<span class="math inline">\(AA^H\)</span>的特征值<span class="math inline">\(\lambda\)</span>的线性无关的特征向量，由之前推导的对应关系，我们考虑证明<span class="math inline">\(A^Hx_1, A^Hx_2,...,A^Hx_n\)</span>线性无关</p>
<p>设有<span class="math inline">\(\sum k_i A^H x_i = 0\)</span>，那么<span class="math inline">\(\sum k_i (AA^H) x_i = 0\)</span>，从而<span class="math inline">\(\lambda \sum k_ix_i = 0\)</span>，因此<span class="math inline">\(k_1=k_2=...=k_n=0\)</span></p>
<blockquote>
<p>对于<span class="math inline">\(n*n\)</span>的复矩阵<span class="math inline">\(A\)</span>，设<span class="math inline">\(\lambda_1, ..., \lambda_n\)</span>为其<span class="math inline">\(n\)</span>个特征值，那么<span class="math inline">\(\sum_{i=1}^n |\lambda_i|^2 \leq \sum_{1 \leq i, j \leq n} |a_{ij}|^2\)</span>，当且仅当<span class="math inline">\(A\)</span>是正规矩阵时取得等号</p>
</blockquote>
<p>考虑Schur TH，存在酉矩阵<span class="math inline">\(U\)</span>，使得<span class="math inline">\(A = U^HBU\)</span>，其中<span class="math inline">\(B\)</span>为上三角矩阵，并且对角线元素为<span class="math inline">\(A\)</span>的特征值</p>
<p>注意到<span class="math inline">\(AA^H = U^HBB^HU\)</span>，而<span class="math inline">\(tr(AA^H) = \sum |a_{ij}|^2\)</span>，<span class="math inline">\(tr(BB^H) = \sum |b_{ij}|^2 \geq \sum |\lambda_i|^2\)</span>，当且仅当<span class="math inline">\(B\)</span>是对角矩阵时，取到等号</p>
<p>由于相似矩阵的特征多项式相同，那么他们将有相同的迹，因此<span class="math inline">\(\sum |a_{ij}|^2 = tr(AA^H) = tr(BB^H)\geq \sum |\lambda_i|^2\)</span>，当且仅当<span class="math inline">\(A\)</span>是正规矩阵时取得等号</p>
<blockquote>
<p>设<span class="math inline">\(\sigma_1, ..., \sigma_n\)</span>是<span class="math inline">\(A\)</span>的奇异值，那么<span class="math inline">\(tr(A^HA) = tr(AA^H) = \sum_{i=1}^r \sigma_i^2\)</span></p>
</blockquote>
<p>设<span class="math inline">\(M = AA^H\)</span>，由上个定理证明过程，我们知道，只要证明<span class="math inline">\(M\)</span>可酉对角化即可</p>
<p>由于<span class="math inline">\(M\)</span>是埃尔米特矩阵，这是显然的</p>
<blockquote>
<p>矩阵<span class="math inline">\(A\)</span>的非零奇异值的个数是该矩阵的秩</p>
</blockquote>
<p>我们知道<span class="math inline">\(rank(A) = rank(AA^H)\)</span>，而对于<span class="math inline">\(AA^H\)</span>而言，其酉相似于一个对角矩阵<span class="math inline">\(B\)</span>，对角线上的元素为<span class="math inline">\(A\)</span>的奇异值的平方，因此<span class="math inline">\(rank(AA^H)\)</span>为<span class="math inline">\(A\)</span>的非零奇异值的个数</p>
<blockquote>
<p>设<span class="math inline">\(A\)</span>为可逆埃米尔特矩阵，且<span class="math inline">\(A\)</span>的谱分解为<span class="math inline">\(\sum \lambda_i x_i x_i^H\)</span>，那么<span class="math inline">\(A^{-1} = \sum \lambda_i^{-1} x_ix_i^H\)</span></p>
</blockquote>
<p>设<span class="math inline">\(X = \sum \lambda_i^{-1} x_ix_i^H\)</span>，那么<span class="math inline">\(AX = \sum_{i, j} \lambda_i* \lambda_j^{-1} x_ix_i^H x_jx_j^H = \sum_{i} x_ix_i^H = \sum_{i, j} x_ix_j^H = UU^H = I\)</span></p>
<blockquote>
<p>若<span class="math inline">\(A\)</span>是正规矩阵，则<span class="math inline">\(A\)</span>的奇异值就是<span class="math inline">\(A\)</span>的特征值的模</p>
</blockquote>
<p>由<span class="math inline">\(A\)</span>是正规矩阵，<span class="math inline">\(A\)</span>可酉对角化，因此<span class="math inline">\(A = U^H diag(\lambda_1, \lambda_2, ..., \lambda_n) U\)</span></p>
<p>继而<span class="math inline">\(AA^H = U^H diag(|\lambda_1|^2, |\lambda_2|^2, ..., |\lambda_n|^2) U\)</span>，那么<span class="math inline">\(|\lambda_1|^2, |\lambda_2|^2, ..., |\lambda_n|^2\)</span>就是<span class="math inline">\(AA^H\)</span>的特征值，从而<span class="math inline">\(|\lambda_1|, |\lambda_2|, ..., |\lambda_n|\)</span>就是<span class="math inline">\(A\)</span>的奇异值</p>
<blockquote>
<p>酉矩阵特征值值的模都为<span class="math inline">\(1\)</span></p>
</blockquote>
<p>由于<span class="math inline">\(x^Hy = x^HU^HUy = (Ux)^H(Uy)\)</span>，对于酉矩阵<span class="math inline">\(U\)</span>的特征值<span class="math inline">\(\lambda\)</span>，我们对其特征向量<span class="math inline">\(x\)</span>进行考察，那么<span class="math inline">\(x^Hx = (Ux)^HUx = \lambda^H \lambda x^Hx = |\lambda|^2 x^Hx\)</span>，故<span class="math inline">\(|\lambda| = 1\)</span></p>
<blockquote>
<p>若<span class="math inline">\(A\)</span>是正规矩阵，且<span class="math inline">\(A\)</span>的特征值的模为<span class="math inline">\(1\)</span>，那么<span class="math inline">\(A\)</span>为酉矩阵</p>
</blockquote>
<p>直接运用上题的结论即可</p>
<blockquote>
<p>两个正规矩阵相似的充要条件是两者的特征多项式相同</p>
</blockquote>
<p>充分性：如果正规矩阵<span class="math inline">\(A, B\)</span>的特征多项式相同，那么存在酉矩阵<span class="math inline">\(U_1, U_2\)</span>，使得<span class="math inline">\(A = U_1^H \Lambda U_1, B = U_2^H \Lambda U_2\)</span>，从而<span class="math inline">\(A = (U_1^{-1}U_2)^H \Lambda (U_1^{-1}U_2)\)</span>，从而两者相似</p>
<p>必要性：相似矩阵有相同的特征多项式</p>
<blockquote>
<p>若<span class="math inline">\(A\)</span>为实矩阵，且<span class="math inline">\(A^TA = AA^T\)</span>，那么<span class="math inline">\(A\)</span>是对称矩阵</p>
</blockquote>
<p><span class="math inline">\(A\)</span>满足正规矩阵的定义，因此有<span class="math inline">\(A = U^H \Lambda U\)</span>，其中<span class="math inline">\(U\)</span>为酉矩阵，<span class="math inline">\(\Lambda\)</span>为特征值构成的对角阵</p>
<p>那么由<span class="math inline">\(A^H=A\)</span>，<span class="math inline">\(A^H = A^T\)</span>，我们得到<span class="math inline">\(A=A^T\)</span></p>
<blockquote>
<p>正规矩阵<span class="math inline">\(A\)</span>是埃尔米特矩阵，当且仅当<span class="math inline">\(A\)</span>的特征值全为实数</p>
</blockquote>
<p>”<span class="math inline">\(\Rightarrow\)</span>“：显然</p>
<p>"<span class="math inline">\(\Leftarrow\)</span>"：我们考虑矩阵<span class="math inline">\(A\)</span>的谱分解，<span class="math inline">\(A = \sum_{i} \lambda_i x_ix_i^H\)</span>，则有<span class="math inline">\(A^H = \sum_i \lambda_i^H x_i x_i^H = \sum_i \lambda_i x_ix_i^H = A\)</span></p>
<blockquote>
<p><span class="math inline">\(tr(xy^H) = y^Hx\)</span></p>
</blockquote>
<p>取一组标准正交基，设出<span class="math inline">\(x, y\)</span>在这组标准正交基下的坐标为，然后就不难看出了</p>
<p>特别的，如果我们令<span class="math inline">\(y = Ax\)</span>，则有<span class="math inline">\(tr(Axx^H) = x^HAx\)</span></p>
<p>暂定</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>matrix_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵分析 5</title>
    <url>/2021/08/matrix-analysis-5/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="向量范数">向量范数</h3>
<h4 id="介绍">介绍</h4>
<ul>
<li>定义：如果<span class="math inline">\(V\)</span>是数域<span class="math inline">\(P\)</span>上的线性空间，且对于<span class="math inline">\(x \in V\)</span>，存在<span class="math inline">\(V \to R\)</span>的函数<span class="math inline">\(||x||\)</span>，满足
<ul>
<li>非负性：<span class="math inline">\(||x|| \geq 0\)</span>，当且仅当<span class="math inline">\(x = 0\)</span>取等</li>
<li>齐次性：<span class="math inline">\(||kx|| = |k|*||x||\)</span></li>
<li>三角不等式：<span class="math inline">\(||x+y|| \leq ||x|| + ||y||\)</span></li>
</ul></li>
</ul>
<p>这里记录一些常见的范数</p>
<ul>
<li><p><span class="math inline">\(||x|| = \sqrt {\sum_{i=1}^n |x_i|^2}\)</span>，称作<strong>2-范数</strong>或者<strong>欧式范数</strong>，记为<span class="math inline">\(||x||_2\)</span></p>
<ul>
<li>该函数显然满足非负性和齐次性，利用柯西不等式可以得到三角不等式也满足</li>
</ul></li>
<li><p><span class="math inline">\(||x|| = max_{i=1}^n |x_i|\)</span>，称作<strong><span class="math inline">\(\infty-\)</span>范数</strong>，记为<span class="math inline">\(||x||_{\infty}\)</span></p>
<ul>
<li>验证三条性质都是简单的</li>
</ul></li>
<li><p><span class="math inline">\(||x|| = (\sum_{i=1}^n |x_i|^p)^{\frac{1}{p}}\)</span>，称作<strong>p-范数</strong>，其中<span class="math inline">\(1 \leq p &lt; +\infty\)</span>，记为<span class="math inline">\(||x||_p\)</span></p>
<ul>
<li>非负性和齐次性仍然是显然的</li>
<li>三角不等式则可由Young不等式或Holder不等式得出</li>
<li>不难发现<span class="math inline">\(p= 2\)</span>和<span class="math inline">\(p \to +\infty\)</span>的情况下，p-范数变为上述两种情况</li>
</ul></li>
<li><p>对于正定埃尔米特矩阵<span class="math inline">\(A\)</span>，定义<span class="math inline">\(||x||_A = \sqrt {x^HAx}\)</span>，称作<strong>椭圆范数</strong></p>
<ul>
<li><p>非负性和齐次性仍然是显然的</p></li>
<li><p>三角不等式：由于<span class="math inline">\(A\)</span>是正定埃尔米特矩阵，因此存在非奇异矩阵<span class="math inline">\(P\)</span>，使得<span class="math inline">\(A = P^HP\)</span></p>
<p>那么，<span class="math inline">\(||x||_A = ||Px||_2\)</span>，而<span class="math inline">\(||P(x+y)||_2 = ||Px+Py||_2 \leq ||Px||_2 + ||Py||_2\)</span></p></li>
</ul></li>
</ul>
<h4 id="向量范数的等价性">向量范数的等价性</h4>
<ul>
<li><p>称向量范数<span class="math inline">\(||\cdot||_a\)</span>，<span class="math inline">\(||\cdot||_b\)</span>等价，当且仅当存在<span class="math inline">\(c_1, c_2 &gt; 0\)</span>，使得对于任意<span class="math inline">\(x\)</span>，</p>
<p><span class="math display">\[c_1||x||_b \leq ||x||_a \leq c_2||x||_b\]</span></p></li>
<li><p>两个范数等价，当且仅当它们具有相同的敛散性</p>
<ul>
<li><p>充分性是显然的，我们考虑必要性的证明</p>
<p>反证法，不妨设对于任意大的整数<span class="math inline">\(n\)</span>，都存在<span class="math inline">\(x_n\)</span>，使得<span class="math inline">\(||x_n||_b &gt; n||x_n||_a\)</span></p>
<p>那么，我们考虑序列<span class="math inline">\(x_n&#39; = x_n * ||x_n||_b^{-1}\)</span>，显然<span class="math inline">\(\lim_{n \to \infty} ||x_n&#39;||_b = 1\)</span></p>
<p>而<span class="math inline">\(||x_n&#39;||_a = ||x_n||_a *||x_n||_b^{-1} &lt; \frac{1}{n}\)</span>，因此<span class="math inline">\(\lim_{n \to \infty} ||x_n&#39;||_a = 0\)</span>，这与有相同的敛散性这一条件矛盾，矛盾的根源在于假设，因此命题是正确的</p></li>
</ul></li>
<li><p>有限维线性空间上的不同范数是等价的</p>
<ul>
<li><p>向量范数的等价关系有传递性，我们只需证明所有范数都与某种范数等价即可</p></li>
<li><p>首先，由于是有限维线性空间，我们取一组基底<span class="math inline">\(e_1, e_2, ..., e_n\)</span>，对于任意向量<span class="math inline">\(x\)</span>，如果<span class="math inline">\(x = \sum x_ie_i\)</span>，那么，对于向量范数<span class="math inline">\(||\cdot||_a\)</span>，定义<span class="math inline">\(f(x_1, x_2, ..., x_n) = ||x||_a\)</span>，不难证明<span class="math inline">\(f(x_1,x_2,...,x_n)\)</span>是一个连续函数</p>
<p>不妨设<span class="math inline">\(||x||_b\)</span>是另一种范数，我们考虑<span class="math inline">\(f(x_1,x_2,...,x_n)\)</span>在<span class="math inline">\(||x||_b = 1\)</span>上的分布情况，由<span class="math inline">\(f\)</span>的连续性可知它可以取到最大值<span class="math inline">\(M\)</span>和最小值<span class="math inline">\(m\)</span></p>
<p>而对于<span class="math inline">\(||x||_b = k(k \neq 0)\)</span>的一般情况，我们有<span class="math inline">\(m \leq ||x * k^{-1}||_a \leq M\)</span>，即<span class="math inline">\(m||x||_b \leq ||x||_a \leq M ||x||_b\)</span></p></li>
</ul></li>
</ul>
<h3 id="矩阵范数">矩阵范数</h3>
<h4 id="矩阵范数-1">矩阵范数</h4>
<ul>
<li><p>定义：对于矩阵<span class="math inline">\(A\)</span>，如果存在实值函数<span class="math inline">\(||A||\)</span>，满足</p>
<ul>
<li>非负性：<span class="math inline">\(||A|| \geq 0\)</span>，当且仅当<span class="math inline">\(A = O\)</span>时取等</li>
<li>齐次性：<span class="math inline">\(||kA|| = k||A||\)</span></li>
<li>三角不等式：<span class="math inline">\(||A+B|| \leq ||A|| + ||B||\)</span></li>
<li>相容性：<span class="math inline">\(||AB|| \leq ||A|| *||B||\)</span></li>
</ul>
<p>称该函数为<strong>矩阵范数</strong></p></li>
</ul>
<p>定义中的次乘性的一个感性理解是，当<span class="math inline">\(||A|| &lt; 1\)</span>时，将有<span class="math inline">\(\lim_{n \to \infty} ||A||^n = 0(n \to \infty)\)</span></p>
<ul>
<li><p>不难验证下列函数都是矩阵范数</p>
<p><span class="math display">\[||A||_{m_1} = \sum_{i, j} |a_{ij}|\]</span></p>
<p><span class="math display">\[||A||_{m_2} = n* \max_{i.j} |a_{i,j}|\]</span></p>
<p><span class="math display">\[||A||_F = (\sum_{i.j} |a_{ij}|^2)^{1/2}\]</span></p></li>
</ul>
<p>最后一种矩阵范数简称为F-范数，F-范数有不错的性质</p>
<ul>
<li>设<span class="math inline">\(U, V\)</span>为酉矩阵，那么<span class="math inline">\(||A||_F = ||UAV||_F\)</span>
<ul>
<li>注意到<span class="math inline">\(||A||_F = (tr(AA^H))^{1/2}\)</span>，<span class="math inline">\((UAV)(UAV)^H\)</span>和<span class="math inline">\(AA^H\)</span>相似</li>
</ul></li>
<li>矩阵范数在有限维线性空间下也有等价性</li>
</ul>
<h4 id="算子范数">算子范数</h4>
<ul>
<li><p>定义：设<span class="math inline">\(||x||\)</span>是一个向量范数，那么，我们定义<span class="math inline">\(||A|| = \sup_{x \neq 0} \frac{||Ax||}{||x||} = \max_{x = 1} ||Ax||\)</span>为由向量范数<span class="math inline">\(||\cdot||\)</span>诱导出的算子范数</p>
<ul>
<li><p>由定义，算子范数满足<span class="math inline">\(||Ax|| \leq ||A|| *||x||\)</span>，此时，我们称矩阵范数<span class="math inline">\(||A||\)</span>和向量范数<span class="math inline">\(||x||\)</span>相容</p></li>
<li><p>算子范数是一种矩阵范数</p>
<ul>
<li>非负性，齐次性，三角不等式都可以转化为向量范数来证明</li>
<li>对于次乘性，设<span class="math inline">\(x_0\)</span>是在<span class="math inline">\(||x|| = 1\)</span>中，使得<span class="math inline">\(||ABx||\)</span>取到最大值的<span class="math inline">\(x\)</span>，那么<span class="math inline">\(||AB|| = ||ABx_0|| \leq ||A||*||Bx_0|| \leq ||A||*||B||\)</span>，其中的不等式利用的是算子范数的性质</li>
</ul></li>
<li><p><span class="math inline">\(||I||=1\)</span>对任何算子范数成立</p></li>
</ul></li>
<li><p>我们给出几个特例的算子范数</p>
<p>对应于向量范数<span class="math inline">\(||x||_1, ||x||_2, ||x||_{\infty}\)</span>的算子范数分别为</p>
<p><span class="math display">\[||A||_1 = \max_{j} \sum_{i=1}^m |a_{ij}|\]</span></p>
<p><span class="math display">\[||A||_2 = \sigma_{max} = \sqrt {\lambda_{max} }\]</span></p>
<p>上式中<span class="math inline">\(\lambda_{max}\)</span>表示矩阵<span class="math inline">\(AA^H\)</span>的最大特征值</p>
<p><span class="math display">\[||A||_{\infty} =\max_{i} \sum_{j=1}^n |a_{ij}|\]</span></p>
<p>它们分别被称作列范数，谱范数，行范数</p>
<ul>
<li><p>列范数和行范数不难证明，我们对谱范数稍作解释</p>
<p>对<span class="math inline">\(||x||=1\)</span>，不难得到<span class="math inline">\(||Ax||^2_2 = (Ax)^HAx = x^H A^HAx\)</span></p>
<p>设<span class="math inline">\(A^HA\)</span>的谱分解为<span class="math inline">\(\sum \lambda_i x_i^Hx_i\)</span>，其中<span class="math inline">\(\lambda_1 \geq ... \geq \lambda_m\)</span>，并设<span class="math inline">\(x = \sum a_ix_i\)</span></p>
<p>那么<span class="math inline">\(x^HA^HAx = \sum \lambda_i |a_i|^2 \leq \lambda_1\)</span>，当<span class="math inline">\(a_1 = 1\)</span>时可以取到等号</p></li>
</ul></li>
</ul>
<h3 id="谱范数">谱范数</h3>
<h4 id="性质">性质</h4>
<p>谱范数和F-范数一样，有比较好的性质</p>
<ul>
<li><p>设<span class="math inline">\(U, V\)</span>为酉矩阵，那么<span class="math inline">\(||A||_2 = ||UAV||_2\)</span></p>
<ul>
<li>证明：<span class="math inline">\(AA^H\)</span>和<span class="math inline">\((UAV)(UVA)^H\)</span>相似</li>
</ul></li>
<li><p><span class="math inline">\(||A||_2 = ||A^H||_2\)</span></p>
<ul>
<li><span class="math inline">\(AA^H\)</span>和<span class="math inline">\(A^HA\)</span>有相同的非零特征值</li>
</ul></li>
<li><p><span class="math inline">\(||A||_2 = \max_{||x||_2 = 1, ||y||_2=1} |y^HAx|\)</span></p>
<ul>
<li><p><span class="math inline">\(|y^HAx| \leq ||y^H||_2 * ||A||_2*||x||_2 \leq ||A||_2\)</span></p>
<p>存在<span class="math inline">\(x_0\)</span>满足条件，并且使得<span class="math inline">\(||Ax_0||_2 = ||A||_2\)</span>，此时，取<span class="math inline">\(y_0 = Ax_0 * ||Ax_0||^{-1}\)</span>可以取得等号</p></li>
</ul></li>
<li><p><span class="math inline">\(||A^HA||_2 = ||A||_2^2\)</span></p>
<ul>
<li><p><span class="math inline">\(||A^HA||_2 \leq ||A^H||_2 * ||A||_2 = ||A||_2^2\)</span></p>
<p><span class="math inline">\(||A^HA||_2 = \max |y^HA^HAx| \geq \max |x^HA^HAx|\)</span></p></li>
</ul></li>
</ul>
<h4 id="谱半径">谱半径</h4>
<ul>
<li>定义：设<span class="math inline">\(A\)</span>的特征值为<span class="math inline">\(\lambda_1, ..., \lambda_n\)</span>，那么称<span class="math inline">\(\rho(A) = \max_{i} |\lambda_i|\)</span>，称为<span class="math inline">\(A\)</span>的<strong>谱半径</strong></li>
</ul>
<p>谱半径有非常良好的性质</p>
<ul>
<li><span class="math inline">\(\rho(A) \leq ||A||\)</span>，谱半径不会超过<span class="math inline">\(A\)</span>的<strong>任何</strong>一种范数</li>
</ul>
<p>为了证明这个定理，我们需要一个引理 `</p>
<ul>
<li><p>引理：对于任何一种矩阵范数<span class="math inline">\(||\cdot||_A\)</span>，存在与其相容的向量范数<span class="math inline">\(||\cdot||_v\)</span></p>
<ul>
<li><p>任取<span class="math inline">\(y \neq 0, y \in V\)</span>，那么定义<span class="math inline">\(||x||_v = ||xy^H||_A\)</span></p>
<p>容易验证这是一个向量范数，我们来考虑相容性</p>
<p><span class="math inline">\(||M||_A * ||x||_v = ||M||_A*||xy^H||_A \geq ||Mxy^H||_A = ||Mx||_v\)</span></p></li>
</ul></li>
</ul>
<p>现在让我们回到定理的证明，设<span class="math inline">\(\lambda\)</span>为其特征值，<span class="math inline">\(x\)</span>为其对应的特征向量，<span class="math inline">\(||\cdot||_v\)</span>取与其相容的向量范数，那么<span class="math inline">\(|\lambda|*||x||_v = ||\lambda x||_v = ||Ax||_v \leq ||A|| * ||x||_v\)</span>，于是<span class="math inline">\(|\lambda| \leq ||A||\)</span></p>
<ul>
<li>如果<span class="math inline">\(A\)</span>的正规矩阵，那么<span class="math inline">\(\rho(A) = ||A||_2\)</span></li>
</ul>
<p>即证<span class="math inline">\(A\)</span>的特征值的模的最大值等于<span class="math inline">\(A\)</span>的最大奇异值，这个由特征值的模与奇异值之间的对应关系可以得到</p>
<ul>
<li><span class="math inline">\(||A||_2 = \sqrt {\rho(AA^H)}\)</span></li>
</ul>
<p>这个是显然的</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>matrix_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>2021杭电多校第二场T9</title>
    <url>/2021/07/problem-1/</url>
    <content><![CDATA[<span id="more"></span>
<h4 id="吐槽">吐槽</h4>
<p>杭电多校的好题太少了，出题人要么是水平问题，要么是态度问题...</p>
<h4 id="题面">题面</h4>
<p>给定<span class="math inline">\(n\)</span>个数<span class="math inline">\(a_1, ..., a_n\)</span>，询问有多少个三元有序对<span class="math inline">\((i, j, k)\)</span>满足<span class="math inline">\(i &lt; j &lt; k\)</span>，并且<span class="math inline">\(a_i a_j a_k\)</span>是一个完全平方数</p>
<p><span class="math inline">\(n \leq 10^5, \max a_i \leq 10^5\)</span></p>
<h4 id="题解">题解</h4>
<p>首先，我们将<span class="math inline">\(a_i\)</span>质因数分解为<span class="math inline">\(p_1^{r_1}...p_k^{r_k}\)</span>，不难发现只有<span class="math inline">\(r_1\)</span>的奇偶影响答案的统计，因此我们只需要考虑形如<span class="math inline">\(p_1...p_k\)</span>的数即可</p>
<p>记<span class="math inline">\(M = 10^5\)</span>，分最大质因子<span class="math inline">\(&gt; \sqrt M\)</span>的数和最大质因子<span class="math inline">\(\leq \sqrt M\)</span>的数考虑</p>
<p>三元组只可能是下列两种情况之一：</p>
<ul>
<li>三个数的最大质因子都<span class="math inline">\(\leq \sqrt M\)</span>，形如这样的数可以爆搜，大概有1600000组</li>
<li>三个数中有两个数的最大质因子<span class="math inline">\(&gt; \sqrt M\)</span>，我们可以枚举最大质因子<span class="math inline">\(p\)</span>，如果最大质因子为<span class="math inline">\(p\)</span>的数有<span class="math inline">\(&lt; \sqrt M\)</span>个，那么我们直接暴力枚举，否则，最大质因子为<span class="math inline">\(p\)</span>的数对应的值只会有<span class="math inline">\(&lt; \sqrt M\)</span>个，我们按照权值来暴力，此时，由于每个最大质因子<span class="math inline">\(p\)</span>的平均复杂度<span class="math inline">\(&lt; \sqrt M\)</span>，因此总复杂度小于<span class="math inline">\(M \sqrt M\)</span></li>
</ul>
<p>做法挺明显的....码的时候有一点点细节</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define gc </span>getchar</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> read<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> w <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="dt">char</span> c <span class="op">=</span> gc<span class="op">();</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>c <span class="op">&gt;</span> <span class="ch">&#39;9&#39;</span> <span class="op">||</span> c <span class="op">&lt;</span> <span class="ch">&#39;0&#39;</span><span class="op">)</span> <span class="op">&#123;</span> <span class="cf">if</span><span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;-&#39;</span><span class="op">)</span> w <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> c <span class="op">=</span> gc<span class="op">();</span> <span class="op">&#125;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>c <span class="op">&gt;=</span> <span class="ch">&#39;0&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">&#39;9&#39;</span><span class="op">)</span> p <span class="op">=</span> p <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> c <span class="op">-</span> <span class="ch">&#39;0&#39;</span><span class="op">,</span> c <span class="op">=</span> gc<span class="op">();</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p <span class="op">*</span> w<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define rep</span><span class="op">(</span>io<span class="op">,</span><span class="pp"> </span>st<span class="op">,</span><span class="pp"> </span>ed<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">=</span><span class="pp"> </span>st<span class="op">;</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">&lt;=</span><span class="pp"> </span>ed<span class="op">;</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">++)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define drep</span><span class="op">(</span>io<span class="op">,</span><span class="pp"> </span>ed<span class="op">,</span><span class="pp"> </span>st<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">=</span><span class="pp"> </span>ed<span class="op">;</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">&gt;=</span><span class="pp"> </span>st<span class="op">;</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">--)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> sid <span class="op">=</span> <span class="fl">1e5</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> M <span class="op">=</span> <span class="fl">1e5</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>vector <span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr<span class="op">[</span>sid<span class="op">];</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> _gcd<span class="op">[</span><span class="dv">500</span><span class="op">][</span><span class="dv">500</span><span class="op">],</span> mul<span class="op">[</span><span class="dv">500</span><span class="op">][</span><span class="dv">500</span><span class="op">];</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxfac<span class="op">[</span>sid<span class="op">],</span> <span class="fu">tr</span><span class="op">[</span>sid<span class="op">],</span> pr<span class="op">[</span>sid<span class="op">],</span> nop<span class="op">[</span>sid<span class="op">],</span> cnt<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> num<span class="op">[</span>sid<span class="op">],</span> tnum<span class="op">[</span>sid<span class="op">];</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> gcd<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b <span class="op">?</span> gcd<span class="op">(</span>b<span class="op">,</span> a <span class="op">%</span> b<span class="op">)</span> <span class="op">:</span> a<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> M<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>nop<span class="op">[</span>i<span class="op">])</span> pr<span class="op">[++</span> cnt<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> cnt<span class="op">;</span> j <span class="op">++)</span> <span class="op">&#123;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> p <span class="op">=</span> i <span class="op">*</span> pr<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>p <span class="op">&gt;</span> M<span class="op">)</span> <span class="cf">break</span><span class="op">;</span> nop<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i <span class="op">%</span> pr<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqrt_M <span class="op">=</span> sqrt<span class="op">(</span>M<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> sqrt_M<span class="op">)</span> rep<span class="op">(</span>j<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> sqrt_M<span class="op">)</span> _gcd<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> gcd<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> sqrt_M<span class="op">)</span> rep<span class="op">(</span>j<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> sqrt_M<span class="op">)</span> </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>i <span class="op">||</span> j<span class="op">)</span> mul<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> j <span class="op">/</span> _gcd<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">/</span> _gcd<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> mul<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> M<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> t <span class="op">=</span> i<span class="op">;</span> <span class="fu">tr</span><span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> pr<span class="op">[</span>j<span class="op">]</span> <span class="op">*</span> pr<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;=</span> t<span class="op">;</span> j <span class="op">++)</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>t <span class="op">%</span> pr<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span><span class="op">(</span>t <span class="op">%</span> pr<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> t <span class="op">/=</span> pr<span class="op">[</span>j<span class="op">],</span> num <span class="op">++;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>num <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span> <span class="fu">tr</span><span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> pr<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>t <span class="op">&gt;</span> sqrt_M<span class="op">)</span> maxfac<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="fu">tr</span><span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> t<span class="op">;</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> ans<span class="op">;</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> dep<span class="op">,</span> <span class="dt">int</span> v1<span class="op">,</span> <span class="dt">int</span> v2<span class="op">,</span> <span class="dt">int</span> v3<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>dep <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>v1 <span class="op">==</span> v2 <span class="op">&amp;&amp;</span> v1 <span class="op">==</span> v3<span class="op">)</span> ans <span class="op">+=</span> <span class="dv">1</span><span class="bu">ll</span> <span class="op">*</span> num<span class="op">[</span>v1<span class="op">]</span> <span class="op">*</span> <span class="op">(</span>num<span class="op">[</span>v1<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>num<span class="op">[</span>v1<span class="op">]</span> <span class="op">-</span> <span class="dv">2</span><span class="op">)</span> <span class="op">/</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>v1 <span class="op">==</span> v2<span class="op">)</span> ans <span class="op">+=</span> <span class="dv">1</span><span class="bu">ll</span> <span class="op">*</span> num<span class="op">[</span>v1<span class="op">]</span> <span class="op">*</span> <span class="op">(</span>num<span class="op">[</span>v1<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> num<span class="op">[</span>v3<span class="op">];</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> ans <span class="op">+=</span> <span class="dv">1</span><span class="bu">ll</span> <span class="op">*</span> num<span class="op">[</span>v1<span class="op">]</span> <span class="op">*</span> num<span class="op">[</span>v2<span class="op">]</span> <span class="op">*</span> num<span class="op">[</span>v3<span class="op">];</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> v1<span class="op">,</span> v2<span class="op">,</span> v3<span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>v1 <span class="op">==</span> v2 <span class="op">&amp;&amp;</span> v1 <span class="op">==</span> v3<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">v1_</span> <span class="op">=</span> v1 <span class="op">*</span> pr<span class="op">[</span>dep<span class="op">];</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span><span class="va">v1_</span> <span class="op">&lt;=</span> M<span class="op">)</span> dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> v1<span class="op">);</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>v1 <span class="op">==</span> v2<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">v1_</span> <span class="op">=</span> v1 <span class="op">*</span> pr<span class="op">[</span>dep<span class="op">],</span> <span class="va">v3_</span> <span class="op">=</span> v3 <span class="op">*</span> pr<span class="op">[</span>dep<span class="op">];</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span><span class="va">v1_</span> <span class="op">&lt;=</span> M<span class="op">)</span> dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> v3<span class="op">);</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span><span class="va">v1_</span> <span class="op">&lt;=</span> M <span class="op">&amp;&amp;</span> <span class="va">v3_</span> <span class="op">&lt;=</span> M<span class="op">)</span> dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> v1<span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> <span class="va">v3_</span><span class="op">);</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="va">v1_</span> <span class="op">=</span> v1 <span class="op">*</span> pr<span class="op">[</span>dep<span class="op">],</span> <span class="va">v2_</span> <span class="op">=</span> v2 <span class="op">*</span> pr<span class="op">[</span>dep<span class="op">],</span> <span class="va">v3_</span> <span class="op">=</span> v3 <span class="op">*</span> pr<span class="op">[</span>dep<span class="op">];</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="va">v1_</span> <span class="op">&lt;=</span> M <span class="op">&amp;&amp;</span> <span class="va">v2_</span> <span class="op">&lt;=</span> M<span class="op">)</span> dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> <span class="va">v2_</span><span class="op">,</span> v3<span class="op">);</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="va">v1_</span> <span class="op">&lt;=</span> M <span class="op">&amp;&amp;</span> <span class="va">v3_</span> <span class="op">&lt;=</span> M<span class="op">)</span> dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="va">v1_</span><span class="op">,</span> v2<span class="op">,</span> <span class="va">v3_</span><span class="op">);</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="va">v2_</span> <span class="op">&lt;=</span> M <span class="op">&amp;&amp;</span> <span class="va">v3_</span> <span class="op">&lt;=</span> M<span class="op">)</span> dfs<span class="op">(</span>dep <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> v1<span class="op">,</span> <span class="va">v2_</span><span class="op">,</span> <span class="va">v3_</span><span class="op">);</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> read<span class="op">();</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> M<span class="op">)</span> num<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x <span class="op">=</span> read<span class="op">();</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>maxfac<span class="op">[</span>x<span class="op">])</span> num<span class="op">[</span> <span class="fu">tr</span><span class="op">[</span>x<span class="op">]</span> <span class="op">]</span> <span class="op">++;</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> arr<span class="op">[</span> maxfac<span class="op">[</span>x<span class="op">]</span> <span class="op">].</span>push_back<span class="op">(</span><span class="fu">tr</span><span class="op">[</span>x<span class="op">]);</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqrt_M <span class="op">=</span> sqrt<span class="op">(</span>M<span class="op">),</span> lim <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>pr<span class="op">[</span>lim<span class="op">]</span> <span class="op">&lt;=</span> sqrt_M<span class="op">)</span> lim <span class="op">++;</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span>lim<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> lim <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> cnt<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> pr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>arr<span class="op">[</span>p<span class="op">].</span>size<span class="op">()</span> <span class="op">&lt;</span> sqrt_M<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>            rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>arr<span class="op">[</span>p<span class="op">].</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> rep<span class="op">(</span>j<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>                ans <span class="op">+=</span> num<span class="op">[</span> mul<span class="op">[</span> arr<span class="op">[</span>p<span class="op">][</span>i<span class="op">]</span> <span class="op">][</span> arr<span class="op">[</span>p<span class="op">][</span>j<span class="op">]</span> <span class="op">]</span> <span class="op">];</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">&#123;</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> Lim <span class="op">=</span> M <span class="op">/</span> pr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>            rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Lim<span class="op">)</span> tnum<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x <span class="op">:</span> arr<span class="op">[</span>p<span class="op">])</span> tnum<span class="op">[</span>x<span class="op">]</span> <span class="op">++;</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>            rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Lim<span class="op">)</span> <span class="cf">if</span><span class="op">(</span>tnum<span class="op">[</span>i<span class="op">])</span> rep<span class="op">(</span>j<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> i<span class="op">)</span> <span class="cf">if</span><span class="op">(</span>tnum<span class="op">[</span>j<span class="op">])</span> <span class="op">&#123;</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span> ans <span class="op">+=</span> <span class="dv">1</span><span class="bu">ll</span> <span class="op">*</span> tnum<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> <span class="op">(</span>tnum<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">*</span> num<span class="op">[</span> mul<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">];</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> ans <span class="op">+=</span> <span class="dv">1</span><span class="bu">ll</span> <span class="op">*</span> tnum<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> tnum<span class="op">[</span>j<span class="op">]</span> <span class="op">*</span> num<span class="op">[</span> mul<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">];</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>            <span class="op">&#125;</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>p<span class="op">].</span>clear<span class="op">();</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>    init<span class="op">();</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> T <span class="op">=</span> read<span class="op">();</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>T <span class="op">--)</span> solve<span class="op">();</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>number_theory</tag>
      </tags>
  </entry>
  <entry>
    <title>有的时候一言难尽</title>
    <url>/2022/03/training-1/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="a">A</h2>
<blockquote>
<p>求满足<span class="math inline">\(1 \leq a_{i, j} \leq K\)</span>，并且<span class="math inline">\(a_{i, j} \leq a_{i, j+1}\)</span>，<span class="math inline">\(a_{i, j} \leq a_{i+1,j}\)</span>，<span class="math inline">\(a_{R, C}=V\)</span>的<span class="math inline">\(N*M\)</span>的大小的矩阵的数量</p>
<p>其中<span class="math inline">\(1 \leq R \leq N, 1 \leq C \leq M\)</span></p>
</blockquote>
<p>注意到值为<span class="math inline">\(i-1\)</span>和值为<span class="math inline">\(i\)</span>的部分有一条分界线，一共有<span class="math inline">\(K\)</span>条，把这些分界线稍微作移动，他们就等价于不相交的路径，我们很容易通过这些分界线来还原出原来的取值</p>
<p>对于<span class="math inline">\(a_{R, C}=V\)</span>，就是<span class="math inline">\((R, C)\)</span>这个点上方有<span class="math inline">\(V-1\)</span>条分界线，在LGV引理中，我们可以把所有满足在<span class="math inline">\((R, C)\)</span>上方的分界线的权值记为<span class="math inline">\(x\)</span>然后算行列式，然后考虑<span class="math inline">\(V-1\)</span>次的系数即可</p>
<p>直接计算<span class="math inline">\(x\)</span>可能较为复杂，我们可以考虑对<span class="math inline">\(x\)</span>进行赋值之后进行插值</p>
<h2 id="d">D</h2>
<blockquote>
<p>给定<span class="math inline">\(\{A_n\}, \{B_n\}, \{C_n\}\)</span>，对<span class="math inline">\(k = 1, 2, ..., N\)</span>，求 <span class="math display">\[
Ans_k = \sum_{1 \leq i \leq N} (C_i \times \prod_{1 \leq j \leq k}(A_i + B_j))
\]</span></p>
</blockquote>
<p>看不懂题解，题解提到了一个Tellegen’s Principle，这个原则说linear straight-line program的转置和原问题有相同的复杂度，但是这个principle没有给出通用的构造，还是要对具体问题进行具体地设计，题解论文里提了这个题的转置转置后的做法，但感觉不够直观，我们就对这个题具体给出一个直观分析</p>
<p>设<span class="math inline">\(S_j = \sum_{i} C_i A_i^j\)</span>，<span class="math inline">\(f_k(x) = \prod_{1 \leq j \leq k} (x + B_j)\)</span></p>
<p>那么，我们有<span class="math inline">\(Ans_k = \sum_{i=0}^k f_k(x)[x^i] S_i\)</span>，其中<span class="math inline">\(\{S_n\}\)</span>不难通过FFT计算</p>
<p>接下来，我们考虑分治，具体的，对区间<span class="math inline">\([l,r]\)</span>分析</p>
<p>区间<span class="math inline">\([l, mid]\)</span>中的<span class="math inline">\(B\)</span>对于<span class="math inline">\([l, mid]\)</span>中<span class="math inline">\(Ans\)</span>的影响可以递归考虑，我们只需要考虑<span class="math inline">\([l, mid]\)</span>中的<span class="math inline">\(B\)</span>对<span class="math inline">\([mid+1, r]\)</span>的<span class="math inline">\(Ans\)</span>的影响，注意到我们只需要考虑<span class="math inline">\([mid+1, r]\)</span>中的<span class="math inline">\(Ans\)</span>中含且仅含<span class="math inline">\([l, mid]\)</span>中的<span class="math inline">\(B\)</span>的项，而这可以通过一个卷积来计算</p>
<p>总的复杂度就是<span class="math inline">\(O(n \log^2 n)\)</span></p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵分析 6</title>
    <url>/2021/08/matrix-analysis-6/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li>完备的赋范线性空间，称为Banach空间</li>
</ul>
<h3 id="矩阵序列的极限">矩阵序列的极限</h3>
<ul>
<li><p>定义：设有矩阵序列<span class="math inline">\(\{A_k\}\)</span>，其中<span class="math inline">\(A_k = (a_{ij}^{(k)})_{n*n}\)</span>，且当<span class="math inline">\(k \to \infty\)</span>时，<span class="math inline">\(a_{ij}^{(k)} \to a_{ij}\)</span>，则称<span class="math inline">\(\{A_k\}\)</span>收敛，并称<span class="math inline">\(A = (a_{ij})\)</span>为<span class="math inline">\(\{A_k\}\)</span>的极限，记做</p>
<p><span class="math display">\[\lim_{k \to \infty} A_k = A\]</span></p></li>
<li><p>不收敛的序列称为发散的</p></li>
</ul>
<p>这个定义研究起来并不是很方便，我们可以引出一个等价的定义</p>
<ul>
<li>在有限维巴拿赫空间中，矩阵序列<span class="math inline">\(\{A_k\}\)</span>收敛于<span class="math inline">\(A\)</span>等价于矩阵序列<span class="math inline">\(\{A_k\}\)</span>按范数收敛于<span class="math inline">\(A\)</span>
<ul>
<li>由于所有范数是等价的，我们不妨取矩阵的F-范数来研究，此时矩阵相等于<span class="math inline">\(n*m\)</span>维的一个向量，由向量范数的性质知道，对于F-范数而言，这个定理是成立的</li>
</ul></li>
</ul>
<p>同大多数极限一样，矩阵极限有相应的运算性质</p>
<ul>
<li><p>如果<span class="math inline">\(\lim_{k \to \infty} A_k = A\)</span>，那么序列<span class="math inline">\(\{||A_k||\}\)</span>有界</p></li>
<li><p>如果<span class="math inline">\(\lim_{k \to \infty} A_k = A, \lim_{k \to \infty} B_k = B\)</span>，那么</p>
<p><span class="math display">\[\lim_{k \to \infty} (aA_k + bB_k) = aA + bB\]</span></p></li>
<li><p>如果<span class="math inline">\(\lim_{k \to \infty} A_k = A. \lim_{k \to \infty} B_k = B\)</span>，那么</p>
<p><span class="math display">\[\lim_{k \to \infty} A_kB_k = AB\]</span></p>
<ul>
<li><span class="math inline">\(||A_kB_k - AB|| \leq ||(A_k- A)||*||B_k|| + ||(B_k-B)||*||A||\)</span></li>
</ul></li>
<li><p>如果<span class="math inline">\(\lim_{k \to \infty} A_k = A\)</span>，且<span class="math inline">\(A_k(k \in N^{+}), A\)</span>都可逆，那么</p>
<p><span class="math display">\[\lim_{k \to \infty} A_k^{=1} = A^{-1}\]</span></p>
<ul>
<li><p>注意到对于任意<span class="math inline">\(A_k\)</span>中的子式而言，它可以表示为<span class="math inline">\(A_k\)</span>中元素的连续函数，由连续性，<span class="math inline">\(A_k\)</span>的子式一定收敛于<span class="math inline">\(A\)</span>中对应的子式，特别的，<span class="math inline">\(|A_k| \to |A|\)</span></p>
<p>同样的，我们将有<span class="math inline">\(\text{adj} A_k \to \text{adj} A\)</span>，从而有<span class="math inline">\(A_k^{-1} \to A^{-1}\)</span></p></li>
</ul></li>
</ul>
<p>下面是一个基础的定理</p>
<ul>
<li><p><span class="math inline">\(\lim_{k \to \infty} A^k = 0\)</span>的充要条件是<span class="math inline">\(\rho(A) &lt; 1\)</span></p>
<ul>
<li><p>考虑矩阵<span class="math inline">\(A\)</span>的若尔当标准形<span class="math inline">\(J\)</span>，即<span class="math inline">\(A = TJT^{-1}\)</span>，那么<span class="math inline">\(A^k = T J^K T^{-1}\)</span></p>
<p>因此<span class="math inline">\(\lim_{k \to \infty} A^k = 0\)</span>，当且仅当<span class="math inline">\(\lim_{k \to \infty} J^k = 0\)</span></p>
<p>设<span class="math inline">\(J = diag\{J_1, ..., J_r\}\)</span>，那么<span class="math inline">\(J^k = diag\{J_1^k, ..., J_r^k\}\)</span></p>
<p>注意到<span class="math inline">\(J_i^k = \begin{pmatrix} \lambda_i^k &amp; \binom{k}{1} \lambda_i^{k-1} &amp; ... &amp; \binom{k}{n_i - 1} \lambda_i^{k - n_i + 1} \\ 0 &amp; \lambda_i^{k} &amp; ... &amp; \binom{k}{n_i-2} \lambda_{i}^{k-n_i+2} \\ ...&amp;... &amp; ... &amp;... \\ ... &amp; ... &amp; ... &amp; \lambda_i^k\end{pmatrix}\)</span>​</p>
<p>矩阵每个元素都形如<span class="math inline">\(f(k) * \lambda^k\)</span>，其中<span class="math inline">\(f(k)\)</span>是关于<span class="math inline">\(k\)</span>的多项式</p>
<p>因此，当<span class="math inline">\(|\lambda| &lt; \rho(A) &lt; 1\)</span>时，就有<span class="math inline">\(J_i^k \to O\)</span>，从而<span class="math inline">\(J^k \to O\)</span></p>
<p>反过来，当<span class="math inline">\(J^k \to O\)</span>时，<span class="math inline">\(J_i^k \to O\)</span>，因此<span class="math inline">\(\lambda_i^k \to 0\)</span>，从而<span class="math inline">\(|\lambda_i| &lt; 1\)</span>，<span class="math inline">\(\rho(A)&lt;1\)</span></p></li>
</ul></li>
</ul>
<h3 id="矩阵级数">矩阵级数</h3>
<ul>
<li><p>对矩阵序列<span class="math inline">\(\{A_k\}\)</span>，称<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>为矩阵级数，而<span class="math inline">\(A_k\)</span>称为矩阵级数的一般项</p></li>
<li><p>称<span class="math inline">\(S_k = \sum_{i=0}^k A_i\)</span>为部分和，如果<span class="math inline">\(\{S_k\}\)</span>收敛，那么称矩阵级数<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>收敛，否则称矩阵级数发散</p>
<ul>
<li>矩阵级数收敛的充要条件为<span class="math inline">\(n^2\)</span>个对应的数项级数收敛</li>
</ul></li>
<li><p><span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>收敛，那么<span class="math inline">\(\lim_{n \to \infty} A_n = O\)</span></p>
<p><span class="math inline">\(\sum_{i=0}^{\infty} A_i, \sum_{i=0}^{\infty} B_i\)</span>都收敛时，<span class="math inline">\(\sum_{i=0}^{\infty} (A_i + B_i) = \sum_{i=0}^{\infty} A_i + \sum_{i=0}^{\infty} B_i\)</span></p>
<p><span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>收敛时，<span class="math inline">\(\sum_{i=0}^{\infty} kA_i = k \sum_{i=0}^{\infty} A_i\)</span></p></li>
<li><p>如果<span class="math inline">\(n^2\)</span>个对应的数项级数都绝对收敛，那么称矩阵级数绝对收敛</p>
<ul>
<li><p>矩阵级数<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>绝对收敛的充要条件为<span class="math inline">\(\sum_{i=0}^{\infty} ||A_i||\)</span>收敛，其中<span class="math inline">\(||\cdot||\)</span>为任意一种矩阵级数</p>
<p>把矩阵想象成一个向量，利用<span class="math inline">\(F\)</span>-​范数不难证明</p></li>
</ul></li>
</ul>
<p>仿照数分中的结果，对于矩阵级数，我们有相似的结果</p>
<ul>
<li>如果<span class="math inline">\(\sum_{i=0}^{\infty} A_i, \sum_{i=0}^{\infty} B_i\)</span>绝对收敛于<span class="math inline">\(A, B\)</span>，那么<span class="math inline">\(\sum_{i=0}^{\infty} \sum_{j+k = i} A_jB_k\)</span>绝对收敛于<span class="math inline">\(AB\)</span></li>
<li>如果<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>绝对收敛，那么<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>收敛，并且<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>改变求和次序后，收敛结果不变</li>
</ul>
<p>也有一些和数分中有差异的结果</p>
<ul>
<li><p>如果<span class="math inline">\(\sum_{i=0}^{\infty} A_i\)</span>（绝对）收敛，那么对于非奇异矩阵<span class="math inline">\(P, Q\)</span>，有<span class="math inline">\(\sum_{i=0}^{\infty} PA_iQ\)</span>（绝对）收敛</p>
<ul>
<li><p>在绝对收敛的情况下，给出证明</p>
<p>注意到<span class="math inline">\(||PA_iQ|| \leq ||P||*||Q|| * ||A_i||\)</span>，而<span class="math inline">\(||P||*||Q||\)</span>为非零常数</p></li>
</ul></li>
</ul>
<p>接下来考虑矩阵幂级数</p>
<ul>
<li>形如<span class="math inline">\(\sum c_i A^i\)</span>的矩阵级数称为矩阵幂级数</li>
</ul>
<p>考虑到范数的相容性，我们有</p>
<ul>
<li><p>如果对于某一种矩阵范数，<span class="math inline">\(\sum c_i ||A||^i\)</span>收敛，那么对应的矩阵级数绝对收敛</p></li>
<li><p>如果对于某一种矩阵范数，<span class="math inline">\(||A||\)</span>落在<span class="math inline">\(\sum c_i z^i\)</span>的收敛圆中，那么对应的矩阵级数绝对收敛</p></li>
<li><p>如果<span class="math inline">\(A\)</span>​的谱半径<span class="math inline">\(\rho(A)\)</span>​落在纯量幂级数<span class="math inline">\(\sum c_ix^i\)</span>​的收敛圆中，那么对应的矩阵级数绝对收敛；如果<span class="math inline">\(A\)</span>​的特征值有一个落在<span class="math inline">\(\sum c_iz^i\)</span>​​的收敛圆外，那么对应的矩阵级数发散</p>
<ul>
<li>考虑若尔当标准形</li>
</ul></li>
</ul>
<h3 id="矩阵函数">矩阵函数</h3>
<ul>
<li><p>考虑以下三个矩阵级数</p>
<p><span class="math display">\[\exp(A) = \sum_{i=0}^{\infty} \frac{A^i}{i!}\]</span></p>
<p><span class="math display">\[\sin(A) = \sum_{i=0}^{\infty} (-1)^i \frac{A^{2i+1}}{(2i+1)!}\]</span></p>
<p><span class="math display">\[\cos(A) = \sum_{i=0}^{\infty} (-1)^i \frac{A^{2i}}{(2i)!}\]</span></p>
<p>它们都是绝对收敛的，具体而言，设<span class="math inline">\(z = ||A||\)</span>，那么，当<span class="math inline">\(i \geq 1\)</span>时，由<span class="math inline">\(||\frac{A^i}{i!}|| \leq z^i *(i!)^{-1}\)</span>，得到<span class="math inline">\(||\sum_{i=0}^{\infty} \frac{A^i}{i!}|| \leq ||I|| + \sum_{i=1}^{\infty} z^i * (i!)^{-1} = e^z - 1 + ||I||\)</span>，因此<span class="math inline">\(\exp(A)\)</span>绝对收敛</p>
<p><span class="math inline">\(\sin(A), \cos(A)\)</span>的绝对收敛性可以类似地证明</p></li>
</ul>
<p>即使是基础的矩阵函数，性质也和普通的函数有所不同</p>
<ul>
<li><p>如果<span class="math inline">\(A, B\)</span>可交换，即<span class="math inline">\(AB = BA\)</span>，则有<span class="math inline">\(e^A * e^B = e^B * e^A = e^{A+B}\)</span></p>
<p>证明：由于<span class="math inline">\(e^A, e^B\)</span>​绝对收敛，我们可以考虑两者的柯西乘积</p>
<p><span class="math display">\[\begin{align*}e^A * e^B &amp;= (I + A + \frac{1}{2!}A^2 + ...)(I + B + \frac{1}{2!}B^2 + ...) \\ &amp;= I + (A+B) + \frac{1}{2!}(A+B)^2 + ... \\ &amp;= e^{A+B}\end{align*}\]</span></p></li>
<li><p>如果<span class="math inline">\(A, B\)</span>可交换，那么<span class="math inline">\(\cos(A+B) = \cos A \cos B - \sin A \sin B\)</span></p>
<p>证明：对比两式同次数的项，显然奇次数项都为0，我们只需要证明</p>
<p><span class="math display">\[\begin{align*}RHS &amp;= \sum_{i+j = k} (-1)^{i+j} \frac{A^{2i}}{(2i)!} \frac{B^{2j}}{(2j)!} - \sum_{i+j = k-1} (-1)^{i+j} \frac{A^{2i+1}}{(2i+1)!} \frac{B^{2j+1}}{(2j+1)!}\\ &amp;= (-1)^k [\sum_{i+j = k}  \frac{A^{2i}}{(2i)!} \frac{B^{2j}}{(2j)!} + \sum_{i+j = k-1} \frac{A^{2i+1}}{(2i+1)!} \frac{B^{2j+1}}{(2j+1)!}] \\ &amp;= \frac{(-1)^k}{(2k)!} [\sum_{i} \binom{2k}{2i}A^{2i}B^{2k-2i} + \sum_i \binom{2k}{2i+1}A^{2i+1}B^{2k-2i-1}] \\ &amp;= \frac{(-1)^k}{(2k)!} \sum_i \binom{2k}{i} A^i B^{2k-i} \\ &amp;= \frac{(-1)^k}{(2k)!} (A+B)^{2k} \\ &amp;= LHS\end{align*}\]</span></p></li>
<li><p>如果<span class="math inline">\(A, B\)</span>可交换，那么<span class="math inline">\(\sin(A+B) = \sin A \cos B + \cos A \sin B\)</span>​</p></li>
</ul>
<p>当然，也有一些和普通函数相同的性质</p>
<ul>
<li><p><span class="math inline">\(\cos(-A) = \cos A, \sin (-A) = -\sin(A)\)</span>​</p></li>
<li><p>欧拉公式</p>
<p><span class="math display">\[\exp(iA) = \cos A + i \sin A\]</span></p></li>
</ul>
<p>下面给出一些特殊情况下的矩阵函数的求法</p>
<ul>
<li>如果矩阵<span class="math inline">\(A\)</span>具有谱分解<span class="math inline">\(\sum \lambda_i x_ix_i^T\)</span>，那么矩阵函数<span class="math inline">\(f(A) = \sum f(\lambda_i) x_ix_i^T\)</span></li>
</ul>
<p>首先有一个容易验证的引理：对于多项式<span class="math inline">\(f(x)\)</span>，如果<span class="math inline">\(x\)</span>是<span class="math inline">\(A\)</span>的属于<span class="math inline">\(\lambda\)</span>的一个特征向量，那么<span class="math inline">\(x\)</span>也是<span class="math inline">\(f(A)\)</span>的属于<span class="math inline">\(f(\lambda)\)</span>的一个特征向量</p>
<p>我们设出部分和<span class="math inline">\(f_N(A) = \sum_{i=0}^N c_iA_i\)</span>，那么根据上面的引理，有<span class="math inline">\(f_N(A) = \sum f_N(\lambda_i) x_ix_i^T\)</span></p>
<p>令<span class="math inline">\(N \to \infty\)</span>，我们就有<span class="math inline">\(f(A) = \sum f(\lambda_i) x_ix_i^T\)</span></p>
<h3 id="矩阵微积分">矩阵微积分</h3>
<h5 id="矩阵对标量的导数">矩阵对标量的导数</h5>
<p>对于矩阵<span class="math inline">\(A\)</span>，如果其元素<span class="math inline">\(a_{ij}\)</span>都是变量<span class="math inline">\(x\)</span>的函数<span class="math inline">\(a_{ij}(x)\)</span>，那么我们称矩阵<span class="math inline">\(A\)</span>为变量<span class="math inline">\(x\)</span>的函数矩阵</p>
<ul>
<li>函数矩阵的极限：当<span class="math inline">\(\forall i, j, \lim_{x \to x_0} a_{ij}(x) = a^{*}_{ij}\)</span>存在时，我们称<span class="math inline">\(A\)</span>有极限，且极限为<span class="math inline">\(A^* = \{a^{*}_{ij}\}\)</span></li>
<li>函数矩阵的连续性：当<span class="math inline">\(\forall i, j, \lim_{x \to x_0} a_{ij}(x) = a_{ij}(x_0)\)</span>时，我们称<span class="math inline">\(A\)</span>在<span class="math inline">\(x_0\)</span>这一点连续</li>
<li>函数矩阵的导数：当<span class="math inline">\(\forall i, j, \lim_{x \to x_0} \frac{a_{ij}(x) - a_{ij}(x_0)}{x-x_0} = a&#39;_{ij}(x_0)\)</span>存在时，我们称<span class="math inline">\(A\)</span>在<span class="math inline">\(x_0\)</span>这一点可导，且导数为<span class="math inline">\(A&#39;(x_0) = \{a&#39;_{ij}(x_0)\}\)</span></li>
</ul>
<p>由于可以看成是每个分量函数的一种组合，因此函数矩阵的导数自然地有</p>
<ul>
<li><p><span class="math inline">\((aA+bB)&#39;=aA&#39;+bB&#39;\)</span></p></li>
<li><p><span class="math inline">\((f(x)A(x))&#39; = f&#39;(x)A(x) + f(x)A&#39;(x)\)</span></p></li>
</ul>
<p>还有一些并不能自然得到的性质</p>
<ul>
<li><span class="math inline">\((A(x)B(x))&#39;=A&#39;(x)B(x)+A(x)B&#39;(x)\)</span></li>
<li><span class="math inline">\((A^{-1}(x))&#39;=-A^{-1}(x)A&#39;(x)A^{-1}(x)\)</span></li>
</ul>
<p>我们对这两个性质作出证明，首先是性质1</p>
<p><span class="math inline">\((A(x)B(x))_{ij}&#39; = (\sum_k a_{ik}b_{kj})&#39; = \sum_k a&#39;_{ik}b_{kj} + \sum_k a_{ik}b_{kj}&#39; = (A&#39;B+AB&#39;)_{ij}\)</span></p>
<p>性质2可以视为是对性质1的简单应用</p>
<p><span class="math inline">\((A(x)A^{-1}(x))&#39; = A&#39;(x)A^{-1}(x)+(A^{-1}(x))&#39;A(x)=O\)</span></p>
<p>即使是矩阵对标量的导数，一般也没有简单的形式，比如</p>
<p><span class="math display">\[\frac{\text{d} A^3}{\text{d} x} = A&#39;AA+AA&#39;A+AAA&#39;\]</span></p>
<p>不过一些初等函数保持了比较好的性质，对于任何常量矩阵<span class="math inline">\(A\)</span>，总有</p>
<ul>
<li><span class="math inline">\((e^{Ax})&#39; = A e^{Ax} = e^{Ax}A\)</span></li>
<li><span class="math inline">\((\cos Ax)&#39; = -A \sin Ax = - \sin Ax *A\)</span></li>
<li><span class="math inline">\((\sin Ax)&#39; = A \cos Ax = \cos Ax * A\)</span></li>
<li><span class="math inline">\((\tr A)&#39; = \tr A&#39;\)</span></li>
</ul>
<h5 id="数量函数对矩阵的导数">数量函数对矩阵的导数</h5>
<p>设<span class="math inline">\(f(A)\)</span>是一个将矩阵<span class="math inline">\(A\)</span>映射到标量上的函数，那么我们定义</p>
<p><span class="math display">\[\frac{\text{d} f(A)}{\text{d} A} = (\frac{\part f(A)}{\part a_{ij}})_{m \times n}\]</span></p>
<p>为<span class="math inline">\(f(A)\)</span>对矩阵<span class="math inline">\(A\)</span>的导数</p>
<p>向量时矩阵的一种特例，因此这里也定义出了向量的情况</p>
<p>一般导数的线性性和乘法法则仍是成立的，我们考察一些特殊的例子</p>
<ul>
<li>设<span class="math inline">\(f(x) = x^TAx\)</span>，求<span class="math inline">\(\frac{\text{d} f(x)}{\text{d} x}\)</span></li>
</ul>
<p><span class="math display">\[\begin{align}\frac{\part f(x)}{\part x_k} &amp;= \frac{\part}{\part x_k} x^TAx \\ &amp;=\frac{\part}{\part x_k} \sum_{i, j} a_{ij}x_ix_j \\ &amp;= \sum_i a_{ik}x_i + \sum_{j}a_{kj}x_j \\ &amp;= (Ax)_k + (A^Tx)_k\end{align}\]</span></p>
<p>因此，我们有</p>
<p><span class="math display">\[\frac{\text{d} f(x)}{\text{d} x} = (A+A^T)x\]</span></p>
<ul>
<li>设<span class="math inline">\(f(x) = ||Ax-b||_2^2\)</span>，求<span class="math inline">\(\frac{\text{d} f(x)}{\text{d} x}\)</span></li>
</ul>
<p><span class="math display">\[\begin{align}\frac{\part f(x)}{\part x_k} &amp;= \frac{\part}{\part x_k} 
||Ax-b||^2_2  \\ &amp;= \frac{\part}{\part x_k}  \sum_i (\sum a_{ij}x_j - b_i)^2 \\ &amp;= \sum_i 2a_{ik}(\sum a_{ij}x_j - b_i) \\ &amp;= 2\sum_{i, j} a_{ik}a_{ij}x_j - 2\sum_i a_{ik}b_i \\ &amp;=2 (A^TAx-A^Tb)_{k}\end{align}\]</span></p>
<p>因此，<span class="math inline">\(\frac{\text{d} f(x)}{\text{d} x} = 2(A^TAx-A^Tb)\)</span></p>
<p>一般来说，当一个函数取到极值时，其导数为0，而这个函数正是我们十分熟悉的最小二乘法的函数，我们令其导数为0，将得到<span class="math inline">\(x = (A^TA)^{-1} Ab\)</span></p>
<ul>
<li>设<span class="math inline">\(f(A) = |A|\)</span>，求<span class="math inline">\(\frac{\text{d} f(A)}{\text{d} A}\)</span>，这里<span class="math inline">\(|A|\)</span>是矩阵<span class="math inline">\(A\)</span>的行列式</li>
</ul>
<p>事实上，要求对<span class="math inline">\(ij\)</span>位置元素的偏导数，我们可以考虑按矩阵<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行展开</p>
<p><span class="math inline">\(A = \sum_j a_{ij} A_{ij}\)</span>，那么，不难直接看出，<span class="math inline">\(\frac{\part f(A)}{\part a_{ij}} = A_{ij}\)</span></p>
<p>因此，<span class="math inline">\(\frac{\text{d} f(A)}{\text{d} A} = (A^*)^T\)</span></p>
<p>当<span class="math inline">\(|A| \neq 0\)</span>时，我们可以用<span class="math inline">\(A^{-1}\)</span>来表示，即<span class="math inline">\(\frac{\text{d} f(A)}{\text{d} A} = (|A|A^{-1})^T = |A|(A^{-1})^T\)</span></p>
<h5 id="矩阵对矩阵的导数">矩阵对矩阵的导数</h5>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>matrix_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法（上）</title>
    <url>/2022/04/numerical-analysis/</url>
    <content><![CDATA[<span id="more"></span>
<p>这里的笔记是对于上课内容的一个浓缩</p>
<h2 id="part-1">Part 1</h2>
<h3 id="不动点迭代">不动点迭代</h3>
<ul>
<li>方法</li>
</ul>
<blockquote>
<p>如果<span class="math inline">\(g(r) = r\)</span>，那么称<span class="math inline">\(r\)</span>为<span class="math inline">\(g\)</span>的一个不动点</p>
</blockquote>
<p>我们称下面的方法为不动点迭代法：</p>
<blockquote>
<p>猜测一个解<span class="math inline">\(x_0\)</span>，之后不断的进行迭代：<span class="math inline">\(x_{i+1} = g(x_i)\)</span></p>
</blockquote>
<p>性质：对连续函数<span class="math inline">\(g\)</span>，如果<span class="math inline">\(\lim x_i\)</span>收敛，那么其一定收敛于不动点</p>
<p>注意到<span class="math inline">\(g(r) = g(\lim x_i) = \lim g(x_i) = \lim x_{i+1} = r\)</span></p>
<ul>
<li>迭代的速率</li>
</ul>
<p>对于这种迭代方法，记<span class="math inline">\(e_i\)</span>为第<span class="math inline">\(i\)</span>次迭代的误差，即<span class="math inline">\(e_i = |x_i - r|\)</span></p>
<p>如果<span class="math inline">\(S = \lim e_{i+1} / e_i &lt; 1\)</span>，那么说该不动点迭代线性收敛，<span class="math inline">\(S\)</span>为其收敛速度</p>
<blockquote>
<p>如果<span class="math inline">\(g\)</span>连续可导，<span class="math inline">\(r\)</span>为不动点，<span class="math inline">\(S = |g&#39;(r)| &lt; 1\)</span>，那么对于足够接近<span class="math inline">\(r\)</span>的猜测，不动点迭代法可以收敛到<span class="math inline">\(r\)</span>，收敛速度为<span class="math inline">\(S\)</span></p>
</blockquote>
<p>证明：<span class="math inline">\((x_{i+1} - r) = g&#39;(\xi_i) (x_i - r)\)</span>，当<span class="math inline">\(g&#39;(x) \leq c&lt; 1\)</span>时，<span class="math inline">\(x\)</span>离<span class="math inline">\(r\)</span>的距离一定在减小</p>
<ul>
<li>误差</li>
</ul>
<p>如果计算<span class="math inline">\(f\)</span>时有误差函数<span class="math inline">\(\epsilon g\)</span>，那么实际上我们在解方程<span class="math inline">\(f(r&#39;) + \epsilon g(r&#39;) = 0\)</span></p>
<p>求导并整理，可以得到<span class="math inline">\(\Delta r = r&#39;-r \approx - \epsilon \frac{g(r)}{f&#39;(r)}\)</span></p>
<h2 id="part-2">Part 2</h2>
<h3 id="lagrange-interpolation">Lagrange Interpolation</h3>
<ul>
<li>方法</li>
</ul>
<p>给定<span class="math inline">\(n\)</span>个点<span class="math inline">\((x_1,y_1),...,(x_n,y_n)\)</span>，求一个过这些点的多项式</p>
<p>根据代数基本定理，恰好过这<span class="math inline">\(n\)</span>个点的，次数低于<span class="math inline">\(n\)</span>的多项式至多有一个</p>
<p>我们可以给出其存在性：</p>
<p>定义<span class="math inline">\(L_k = A \prod_{i \neq k}(x - x_i)\)</span>，其中<span class="math inline">\(A = \prod_{i \neq k} (x_k - x_i)^{-1}\)</span></p>
<p>观察到<span class="math inline">\(L_k(x_k) = 1\)</span>，而对于其余的<span class="math inline">\(i \neq k\)</span>，有$ L_k(x_i) = 0$</p>
<p>令<span class="math inline">\(L(x) = \sum y_i L_i(x)\)</span>就得到了我们希望的多项式</p>
<ul>
<li>误差</li>
</ul>
<p>对于插值出来的多项式<span class="math inline">\(P\)</span>，及待插值的<span class="math inline">\(n\)</span>次可导函数<span class="math inline">\(f\)</span>，有</p>
<p><span class="math inline">\(f(x) - P(x) = \frac{1}{n!} \prod (x- x_i) f^{(n)} (c)\)</span></p>
<h3 id="bernstein-polynomial">Bernstein Polynomial</h3>
<ul>
<li>方法</li>
</ul>
<p>设<span class="math inline">\(B_{n, i} (x) = \binom{n}{i} x^i (1-x)^{n-i}\)</span>，并且<span class="math inline">\(B_n(x) = \sum_{i=0}^n f(\frac{i}{n}) B_{n, i}(x), 0 \leq x \leq 1\)</span></p>
<p>那么，随着<span class="math inline">\(n\)</span>增大，<span class="math inline">\(B_n(x)\)</span>一致地趋近于<span class="math inline">\(f(x)\)</span>，或者说<span class="math inline">\(\lim_{n \to \infty} ||B_n(x) - f(x)||_{\infty} = 0\)</span></p>
<ul>
<li>分析</li>
</ul>
<p>设<span class="math inline">\(K_n(x) \sim B(n, x)\)</span>，那么<span class="math inline">\(Pr(K_n = i) = B_{n,i}(x)\)</span></p>
<p>因此，<span class="math inline">\(E[f(K_n/n)] = \sum_{i} f(\frac{i}{n}) Pr(K_n = i) = \sum_i f(\frac{i}{n}) B_{n,i}(x) = B_n(x)\)</span></p>
<p>我们只需要尝试证明<span class="math inline">\(E[f(K_n / n)]\)</span>一致地趋近于<span class="math inline">\(f(x)\)</span>，这依赖于下面几个事实</p>
<ol type="1">
<li><span class="math inline">\(\lim_{n \to \infty} Pr(|K_n(x) / n - x| &gt; \delta) = 0\)</span> 一致成立（大数定理）</li>
<li><span class="math inline">\(\lim_{n \to \infty} Pr(|f(K_n(x) / n) - f(x)| &gt; \delta) = 0\)</span> 一致成立（由1及<span class="math inline">\(f\)</span>一致连续）</li>
<li><span class="math inline">\(\lim_{n \to \infty} E[|f(K_n(x) / n) - f(x)|] = 0\)</span>一致成立（由2）</li>
</ol>
<p>更仔细地分析有：</p>
<p><span class="math inline">\(|f(x) - E[f(K_n(x)/n)]| \leq ||f||_{\infty} / 2n \epsilon^2 + \sup_{|x-y| \leq \epsilon} |f(x) - f(y)|\)</span></p>
<ul>
<li>逼近定理</li>
</ul>
<blockquote>
<p><span class="math inline">\(Weierstrass\)</span>定理：对于连续函数<span class="math inline">\(f\)</span>，多项式可以任意地逼近</p>
</blockquote>
<p>使用Bernstein多项式即可证明，但注意Bernstein并不是最佳的一致逼近多项式</p>
<h3 id="chebyshev-polynomial">Chebyshev Polynomial</h3>
<ul>
<li>引入</li>
</ul>
<p>现在先不妨假设函数定义在<span class="math inline">\([-1,1]\)</span>上，我们希望选择<span class="math inline">\(x_1, ..., x_n\)</span>，使得 <span class="math display">\[
\max_{x \in [-1,1]} (x-x_1)(x-x_2)...(x-x_n)
\]</span> 最小</p>
<hr />
<p>这个问题已经被充分的解决了</p>
<p>答案是选择<span class="math inline">\(x_i = \cos (2i - 1) \pi / 2n\)</span>时，上面的问题得到最小值<span class="math inline">\(2^{-(n-1)}\)</span></p>
<ul>
<li>Chebyshev Polynomial</li>
</ul>
<p>对于上面这个问题，我们选择上述点之后，实际上得到了一个多项式，我们称之为Chebyshev多项式，定义为 <span class="math display">\[
T_n(x) = 2^{n-1}(x-x_1)(x-x_2)...(x-x_n), x_i = \cos (2i - 1) \pi / 2n
\]</span> 这个多项式有一个等价的定义，即<span class="math inline">\(T_n(x) = \cos (n \arccos x)\)</span>（考虑多项式的次数以及零点）</p>
<p>考虑这两个等价的定义（主要是考虑三角函数的定义），Chebyshev多项式将满足一系列的性质：</p>
<blockquote>
<ul>
<li><span class="math inline">\(|T_n(x)| \leq 1\)</span></li>
<li><span class="math inline">\(T_n(x)\)</span>的零点恰好为<span class="math inline">\(x_1, ..., x_n\)</span></li>
<li><span class="math inline">\(T_n(x)\)</span>是一个单增区间和单减区间交替的函数，并且交替<span class="math inline">\(n-1\)</span>次，在<span class="math inline">\(\cos i \pi / n\)</span>处进行交替，每次交替都会发生在<span class="math inline">\(\pm 1\)</span>上</li>
<li><span class="math inline">\(T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x)\)</span></li>
</ul>
</blockquote>
<hr />
<p>其中的性质3可以用于证明开头提到的问题的结论，也被称为Chebyshev TH</p>
<p>（不妨取<span class="math inline">\(g(x)\)</span>为使函数最小的多项式，为方便和<span class="math inline">\(T_n(x)\)</span>比较，设<span class="math inline">\(G(x) = 2^{n-1}g(x)\)</span>，那么<span class="math inline">\(|G(x)|&lt;1\)</span>恒成立， 在<span class="math inline">\(T_n(x)\)</span>的<span class="math inline">\(n+1\)</span>个极值点（取<span class="math inline">\(\pm 1\)</span>）上，<span class="math inline">\(T_n(x) - G(x)\)</span>和<span class="math inline">\(T_n(x)\)</span>有相同的正负，从而<span class="math inline">\(T_n(x) - G(x)\)</span>有<span class="math inline">\(n\)</span>个零点，这不可能）</p>
<p>Chebyshev 定理的另一种表述为：<span class="math inline">\(T_n(x)\)</span>是首一多项式中<span class="math inline">\(||T_n(x)||_{\infty}\)</span>最小的多项式</p>
<p>Chebyshev 多项式是多项式的一组正交基，在如下的内积下： <span class="math display">\[
\langle f, g\rangle = \int_{-1}^1 f(x)g(x) \frac{d x}{\sqrt{1-x^2}}
\]</span></p>
<h3 id="fourier-transform">Fourier Transform</h3>
<p>省略</p>
<h2 id="part-3">Part 3</h2>
<h3 id="least-square-method">Least Square Method</h3>
<p>一般的，我们希望解决找到一个点<span class="math inline">\(x^*\)</span>，<span class="math inline">\(x^* \in \arg \min_x ||Ax - b||_2^2\)</span></p>
<p>此时，对该函数求导，<span class="math inline">\(\nabla||Ax-b||_2^2 = 2A^T A x - 2 A^T b\)</span>，一般就可以求出<span class="math inline">\(x\)</span></p>
<h3 id="linear-system-of-equation">Linear system of equation</h3>
<p>一般的线性方程组<span class="math inline">\(Ax = b\)</span>，我们可以使用高斯消元法来计算，大约需要<span class="math inline">\(O(n^3)\)</span>运算</p>
<p>对于线性方程组<span class="math inline">\(Ax = b\)</span>，记<span class="math inline">\(e_b\)</span>为<span class="math inline">\(b\)</span>的相对误差，<span class="math inline">\(e_x\)</span>为<span class="math inline">\(x\)</span>的相对误差，我们称其条件数<span class="math inline">\(cond(A) = e_x / e_b\)</span></p>
<p>在矩阵<span class="math inline">\(A\)</span>可逆的情况下，<span class="math inline">\(e_x = A^{-1} e_b\)</span>，那么 <span class="math display">\[
cond(A) = \max_{e_b, b \neq 0} \frac{||A^{-1} e||/||A^{-1}b||}{||e||/||b||} = \max_{e \neq 0} \frac{||A^{-1} e||}{||e||} \max_{b \neq 0} \frac{||b||}{||A^{-1}b||} = ||A^{-1}|| * ||A|| \geq 1
\]</span> 其中<span class="math inline">\(||\cdot||\)</span>为任意的向量范数和其导出的矩阵范数</p>
<h3 id="norm">Norm</h3>
<p>一般的，称由向量范数<span class="math inline">\(||\cdot||\)</span>导出的矩阵范数<span class="math inline">\(||A|| := \max_{||x||=1} ||Ax||\)</span>为（<span class="math inline">\(||\cdot||\)</span>导出的）算子范数</p>
<p>算子范数有如下的性质：</p>
<p>相容性：<span class="math inline">\(||AB|| \leq ||A|| * ||B||\)</span></p>
<p>三角不等式：<span class="math inline">\(||A||-||B||\leq ||A + B|| \leq ||A|| + ||B||\)</span></p>
<hr />
<p>以下是几个常见的矩阵算子范数：</p>
<p><span class="math inline">\(||A||_1 = \max_{j} \sum_{i=1}^n |a_{i,j}|\)</span>，向量1-范数的导出范数，也称为列范数</p>
<p><span class="math inline">\(||A||_{\infty} = \max_{i} \sum_{j=1}^n |a_{i,j}|\)</span>，向量<span class="math inline">\(\infty-\)</span>范数的导出范数，也称为行范数</p>
<p><span class="math inline">\(||A||_2 = \max_{||x||_2 \leq 1} \sqrt{x^T A^T A x} = \sqrt{\lambda_{max}(A^TA)}\)</span>，向量2-范数的导出范数</p>
<hr />
<p>定义谱半径<span class="math inline">\(\rho(A):= \max\{ |\lambda_1|, ..., |\lambda_n|\}\)</span></p>
<blockquote>
<p><span class="math inline">\(\rho(A) &lt; 1\)</span>当且仅当<span class="math inline">\(\lim_{k \to \infty} A^k =0\)</span></p>
</blockquote>
<p>对于实对称矩阵而言，<span class="math inline">\(\rho(A) = ||A||_2\)</span></p>
<h3 id="jacobi-method-gauss-seide-method">Jacobi method &amp; Gauss-Seide method</h3>
<ul>
<li>Jacobi method</li>
</ul>
<p>对于线性方程组<span class="math inline">\(Ax = b\)</span></p>
<p>我们把<span class="math inline">\(A\)</span>写为<span class="math inline">\(L+D+U\)</span>的形式，其中<span class="math inline">\(L, D, U\)</span>分别为下三角，对角，上三角阵</p>
<p>此时有<span class="math inline">\(Dx = b - (L+U)x\)</span>，因此我们进行迭代：<span class="math inline">\(x_{k+1} = D^{-1}(b - (L+U)x_k)\)</span></p>
<ul>
<li>Gauss-Seidel method</li>
</ul>
<p>对于上式的<span class="math inline">\((L+D+U)x = b\)</span>，有<span class="math inline">\((L+D)x = b -Ux\)</span></p>
<p>我们进行迭代：<span class="math inline">\(x_{k+1} = D^{-1}(b - Ux_k - Lx_{k+1})\)</span></p>
<p>注意到<span class="math inline">\(L\)</span>是下三角阵，因此不会产生计算上的顺序问题</p>
<ul>
<li>分析</li>
</ul>
<p>我们有如下的定理</p>
<blockquote>
<p>如果<span class="math inline">\(A\)</span>是严格对角占优的，那么<span class="math inline">\(A\)</span>是可逆的，并且对于任何向量<span class="math inline">\(b\)</span>和初始猜测<span class="math inline">\(x_0\)</span>，线性方程组<span class="math inline">\(Ax = b\)</span>使用Jacobi迭代 / Gauss Seidel迭代会收敛到唯一解（即方程组的解）</p>
</blockquote>
<p>为了证明上述定理，我们考虑一般性的迭代<span class="math inline">\(x_{k+1} = Ax_k + b\)</span></p>
<p>设<span class="math inline">\(x^*\)</span>是该迭代的一个不动点，那么有<span class="math inline">\(x_{k+1}-x^* = A(x_k - x^*) = A^k(x_0 -x^*)\)</span></p>
<p>至少当<span class="math inline">\(A^k \to 0\)</span>时，不动点迭代是收敛的，而<span class="math inline">\(A^k \to 0\)</span>和<span class="math inline">\(\rho(A) &lt; 1\)</span>是等价的</p>
<p>因此，为了证明不动点迭代是收敛的，我们可以尝试证明<span class="math inline">\(\rho(A) &lt; 1\)</span></p>
<p>也就是说，我们希望证明<span class="math inline">\(\rho(D^{-1}(L+U)) &lt; 1\)</span>以及<span class="math inline">\(\rho((L+D)^{-1} U) &lt; 1\)</span></p>
<hr />
<p>对<span class="math inline">\(\rho(D^{-1}(L+U))\)</span>考虑，设<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(D^{-1}(L+U)\)</span>的任意一个特征值，<span class="math inline">\(v\)</span>为其特征向量</p>
<p>那么有<span class="math inline">\((L+U)v = \lambda Dv\)</span>，设<span class="math inline">\(||v||_{\infty} = 1\)</span>，且<span class="math inline">\(v_m\)</span>最大，那么根据<span class="math inline">\((L+U) v = \lambda Dv\)</span>，考虑两边的第<span class="math inline">\(m\)</span>个分量，得到<span class="math inline">\(|\lambda a_m| = \sum_{j \neq m} |a_{mj}| &lt; |a_m|\)</span>，从而<span class="math inline">\(|\lambda| &lt; 1\)</span>，进而有<span class="math inline">\(\rho(D^{-1}(L+U)) &lt; 1\)</span>，另一个分析是类似的</p>
<h3 id="moore-penrose-pseudoinverse">Moore-Penrose Pseudoinverse</h3>
<p>考虑方程<span class="math inline">\(Ax = b\)</span></p>
<p>当<span class="math inline">\(A \in \mathbb{R}^{n \times m}(n &gt; m)\)</span>时，并且保证<span class="math inline">\(A\)</span>满秩时，我们将方程<span class="math inline">\(Ax = b\)</span>改写为<span class="math inline">\(A^T A x = A^T b\)</span></p>
<p>此时，<span class="math inline">\(A^T A\)</span>仍然满秩</p>
<p>那么，我们可以写出<span class="math inline">\(x = (A^TA)^{-1} A^Tb\)</span>，这是一个pseudoinverse</p>
<h3 id="richardson-iteration">Richardson iteration</h3>
<ul>
<li>引入</li>
</ul>
<p>根据<span class="math inline">\(Cayley-Hamilton\)</span>定理，存在<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(p(A)\)</span>使得<span class="math inline">\(p(A)A = I\)</span></p>
<p>这启发我们从多项式角度来迭代地<strong>求出<span class="math inline">\(A^{-1}\)</span></strong></p>
<ul>
<li>方法</li>
</ul>
<p>对于线性方程组<span class="math inline">\(Ax = b\)</span></p>
<p>令<span class="math inline">\(x_0 = 0\)</span>，<span class="math inline">\(x_{k+1} = (I - \alpha A) x_k + \alpha b\)</span></p>
<ul>
<li>分析</li>
</ul>
<p>当<span class="math inline">\(\rho(I - \alpha A) &lt; 1\)</span>时收敛，由于<span class="math inline">\(I, \alpha A\)</span>可交换，因此实际上等价于<span class="math inline">\(|1 - \alpha \lambda_{max}| &lt; 1\)</span></p>
<p>下面我们来探讨为什么这等价于研究一个多项式</p>
<p>在线性方程组<span class="math inline">\(Ax = b\)</span>中，实际上我们在寻找<span class="math inline">\(x = A^{-1}b\)</span>，即<span class="math inline">\(x = p(A)b\)</span></p>
<p>寻找<span class="math inline">\(p(x)\)</span>，等价于寻找<span class="math inline">\(q(x) = 1-xp(x)\)</span></p>
<p>假设<span class="math inline">\(x_k = p_k(A)b\)</span>，那么<span class="math inline">\(x_{k+1} = ((I-\alpha A)p_k(A) + \alpha)b\)</span></p>
<p>相当于<span class="math inline">\(p_{k+1}(x) = p_k(x)(1-\alpha x) + \alpha\)</span>，即<span class="math inline">\(1-q_{k+1}(x) = (1-q_k(x))(1 - \alpha x) + \alpha x\)</span></p>
<p>得到<span class="math inline">\(q_{k+1}(x) = q_k(x)(1-\alpha x)\)</span></p>
<p>通过归纳，可以证明我们在考虑多项式<span class="math inline">\(p_k(x) = (1-(1 - \alpha x)^k)/x\)</span></p>
<h3 id="chebyshev-iteration">Chebyshev iteration</h3>
<ul>
<li>方法</li>
</ul>
<p><span class="math inline">\(x_{k+1} = (I - \alpha_kA) x_k + \alpha_k b\)</span></p>
<ul>
<li>分析</li>
</ul>
<p>定义<span class="math inline">\(e_k = x_k - x^*\)</span>，那么<span class="math inline">\(e_k = \prod(I-\alpha_i A) e_0\)</span></p>
<p>因此<span class="math inline">\(||e_k|| \leq ||\prod_i (I - \alpha_i A)|| *||e_0||\)</span></p>
<p>我们希望关于<span class="math inline">\(A\)</span>的那一项系数尽可能小，此时运用Chebyshev多项式就有不错的效果</p>
<h3 id="conjugate-gradients">Conjugate gradients</h3>
<ul>
<li>Krylov 子空间</li>
</ul>
<p>记Krylov子空间为：<span class="math inline">\(K_0 = \{0\}, K_i = span\{b, Ab, ..., A^{i-1} b\}\)</span></p>
<p>设<span class="math inline">\(x_i = \arg \min_{x \in K_i} ||x - x_*||_A^2\)</span>，其中<span class="math inline">\(x_*\)</span>满足<span class="math inline">\(Ax_* = b\)</span>，而<span class="math inline">\(||x||_A = \langle x, x \rangle_A = x Ax^T\)</span>，是由正定矩阵<span class="math inline">\(A\)</span>定义出的内积导出的范数</p>
<ul>
<li>引理</li>
</ul>
<p>如果<span class="math inline">\(\langle x, y \rangle_A = 0\)</span>，那么我们称<span class="math inline">\(x, y\)</span>关于<span class="math inline">\(A\)</span>共轭</p>
<blockquote>
<p>设<span class="math inline">\(v_i = x_i - x_{i-1}\)</span>，那么<span class="math inline">\(v_1, ..., v_n\)</span>两两共轭</p>
</blockquote>
<p>注意到对<span class="math inline">\(i &lt; j\)</span>，<span class="math inline">\(\nabla ||x_j - x_*||_A^2 = 2 (Ax_j - b)\)</span>与<span class="math inline">\(K_j\)</span>正交（<span class="math inline">\(x_j\)</span>最小），从而与<span class="math inline">\(K_i\)</span>正交</p>
<p>类似的<span class="math inline">\(A x_{j-1} - b\)</span>与<span class="math inline">\(K_i\)</span>也正交，因此<span class="math inline">\(Av_j = (Ax_j - b) - (Ax_{j-1} - b)\)</span>也与<span class="math inline">\(K_i\)</span>正交，从而得到了我们希望的结论</p>
<blockquote>
<p><span class="math inline">\(K_k = span\{v_1, ..., v_k\}\)</span></p>
</blockquote>
<p>由上面的结论就可以得出</p>
<blockquote>
<p>设<span class="math inline">\(r_i = b - Ax_i\)</span>，<span class="math inline">\(K_k = span\{v_1,...,v_{k-1}, r_{k-1}\}\)</span></p>
</blockquote>
<p>注意到<span class="math inline">\(r_{i-1} \in K_i\)</span>，但是<span class="math inline">\(r_{i-1}\)</span>与<span class="math inline">\(K_{i-1}\)</span>正交（根据<span class="math inline">\(x_{i-1}\)</span>的定义以及梯度为0），因此<span class="math inline">\(K_k = span\{v_1,...,v_{k-1}, r_{k-1}\}\)</span></p>
<blockquote>
<p>设<span class="math inline">\(v_i = x_i - x_{i-1}\)</span>，那么<span class="math inline">\(v_i\)</span>是关于<span class="math inline">\(v_{i-1}, r_{i-1}\)</span>的函数</p>
</blockquote>
<p>由于<span class="math inline">\(v_i \in K_i\)</span>，因此<span class="math inline">\(v_i\)</span>可以用<span class="math inline">\(v_1, ..., v_{i-1}, r_{i-1}\)</span>线性表出</p>
<p>不妨设<span class="math inline">\(v_i = c_0 r_{i-1} + \sum_{i=1}^{i-1} c_i v_{i-1}\)</span>，注意到<span class="math inline">\(r_{i-1}\)</span>与<span class="math inline">\(v_1,...,v_{i-1}\)</span>正交，<span class="math inline">\(v_i\)</span>之间共轭</p>
<p>再注意到<span class="math inline">\(Av_j \in K_{i-1}, \forall j \leq i-2\)</span>，因此<span class="math inline">\(r_{i-1}^TAv_j = 0\)</span>。即<span class="math inline">\(r_{i-1}\)</span>与<span class="math inline">\(v_1,...,v_{i-2}\)</span>共轭</p>
<p>考虑<span class="math inline">\(v_i^T r_{i-1} = c_0 ||r_{i-1}||_2^2\)</span>，得到<span class="math inline">\(c_0 = v_i^T r_{i-1} / ||r_{i-1}||_2^2\)</span></p>
<p>再考虑<span class="math inline">\(v_i^T A v_j = 0\)</span>，我们就能相应地解出<span class="math inline">\(c_1, ..., c_{i-1}\)</span></p>
<ul>
<li>误差分析</li>
</ul>
<p>略</p>
<h3 id="power-method">Power method</h3>
<ul>
<li>介绍</li>
</ul>
<p>让我们考虑怎么迭代地求出特征值以及特征向量</p>
<p>注意到，对于可对角矩阵<span class="math inline">\(A\)</span>，其存在<span class="math inline">\(n\)</span>个线性无关的特征向量，设为<span class="math inline">\(v_1, ..., v_n\)</span>，对应的特征值为<span class="math inline">\(\lambda_1, ...\)</span>，并且<span class="math inline">\(|\lambda_1| \geq |\lambda_2| \geq ...\)</span></p>
<p>那么，如果<span class="math inline">\(x = \sum \alpha_i v_i\)</span>，则<span class="math inline">\(A^k x = \sum \lambda_i^k \alpha_i v_i = \lambda_1^k (\alpha_1 v_1 + \frac{\lambda_2^k}{\lambda_1^k} \alpha_2 v_2 + ...)\)</span></p>
<p>因此，当<span class="math inline">\(k\)</span>足够大时，我们就会得到一个右边是一个<span class="math inline">\(\lambda_1\)</span>的近似特征向量<span class="math inline">\(v_1&#39;\)</span></p>
<p>通过最小二乘法，最小化<span class="math inline">\(||Av_1&#39; - \lambda_1&#39; v_1&#39;||_2\)</span>来得到<span class="math inline">\(\lambda_1&#39;\)</span>，不难得到<span class="math inline">\(\lambda_1&#39; = v_1&#39;^TAv_1&#39; / v_1&#39;^Tv_1&#39;\)</span></p>
<ul>
<li>分析</li>
</ul>
<p>我们对近似得到的特征值进行分析</p>
<blockquote>
<p>对实对称矩阵<span class="math inline">\(A\)</span>，假设近似特征向量<span class="math inline">\(x\)</span>有<span class="math inline">\(||x||_2 = 1\)</span>，并且<span class="math inline">\(\lambda\)</span>满足<span class="math inline">\(||Ax - \lambda x||_2 &lt; \epsilon\)</span>，那么<span class="math inline">\(\min |\lambda_i - \lambda| &lt; \epsilon\)</span></p>
</blockquote>
<p><span class="math inline">\(||Ax - \lambda x||_2^2 = \sum_{i} |\alpha_i|^2 |\lambda_i - \lambda|^2 \geq \min |\lambda_i - \lambda|^2\)</span></p>
<p>这个定理告诉我们，我们得到的特征值是在所给特征向量下的比较好的近似</p>
<h3 id="inverse-power-method">Inverse Power method</h3>
<ul>
<li>介绍</li>
</ul>
<p>注意到<span class="math inline">\((A-qI)^{-1}\)</span>的特征值为<span class="math inline">\(\{\frac{1}{\lambda_i - q}\}\)</span></p>
<p>如果我们选择适合的参数<span class="math inline">\(q\)</span>，那么我们就能够得到相应的最大的<span class="math inline">\(\frac{1}{\lambda_i- q}\)</span>，进而得到<span class="math inline">\(\lambda_i\)</span></p>
<h3 id="qr-decompesition">QR decompesition</h3>
<ul>
<li>介绍</li>
</ul>
<p><span class="math inline">\(Q_0 = I\)</span>，而<span class="math inline">\(Q_i\)</span>满足<span class="math inline">\(AQ_{i-1} = Q_i R_i(i \geq 1)\)</span>，其中<span class="math inline">\(Q_iR_i\)</span>是<span class="math inline">\(AQ_{i-1}\)</span>的<span class="math inline">\(QR\)</span>分解</p>
<p>这样可以进行特征值的同时迭代</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>numerical_analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第二场</title>
    <url>/2021/07/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
    <content><![CDATA[<span id="more"></span>
<p>把一些没时间写的和没时间想的还有不会做的补一下...</p>
<h4 id="g">G</h4>
<h5 id="题意">题意</h5>
<p>给定<span class="math inline">\(n\)</span>个区间，将这些区间分为<span class="math inline">\(k\)</span>组，要求每组之间有交，使得每一组区间的交的和最大</p>
<h5 id="题解">题解</h5>
<p>对于一个确定的区间组而言，我们往其中添加一个区间，答案显然是不增的</p>
<p>特别的，如果这个区间组中存在着被其完全包含的区间，那么我们就可以无视这个区间</p>
<p>因此，对于包含其余区间的区间而言，要么我们选择无视它，要么选择将其单独归为一组</p>
<p>我们考虑去除这些区间后，剩下的区间，它们互相之间没有包含关系，也就是说，它们的右端点随左端点递增而递增</p>
<p>此时，将左端点相邻的区间分在一组是较为优秀的</p>
<p>设<span class="math inline">\(f_{i, j}\)</span>表示对于前<span class="math inline">\(i\)</span>个区间，分出了<span class="math inline">\(j\)</span>组的方案数，转移考虑最后一段区间即可，注意到合法的转移点是一段左端点不降的区间，可以用单调队列优化</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define rep</span><span class="op">(</span>io<span class="op">,</span><span class="pp"> </span>st<span class="op">,</span><span class="pp"> </span>ed<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">=</span><span class="pp"> </span>st<span class="op">;</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">&lt;=</span><span class="pp"> </span>ed<span class="op">;</span><span class="pp"> </span>io<span class="pp"> </span><span class="op">++)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> sid <span class="op">=</span> <span class="fl">5e3</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> K<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> segment <span class="op">&#123;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span> r<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    segment<span class="op">()</span> <span class="op">&#123;&#125;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    segment<span class="op">(</span><span class="dt">int</span> <span class="va">l_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">r_</span><span class="op">)</span> <span class="op">:</span> l<span class="op">(</span><span class="va">l_</span><span class="op">),</span> r<span class="op">(</span><span class="va">r_</span><span class="op">)</span> <span class="op">&#123;&#125;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span> <span class="op">&lt;</span> <span class="op">(</span>segment a<span class="op">,</span> segment b<span class="op">)</span> <span class="op">&#123;</span> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>a<span class="op">.</span>l <span class="op">!=</span> b<span class="op">.</span>l<span class="op">)</span> <span class="cf">return</span> a<span class="op">.</span>l <span class="op">&lt;</span> b<span class="op">.</span>l<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">.</span>r <span class="op">&lt;</span> b<span class="op">.</span>r<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span> p<span class="op">[</span>sid<span class="op">],</span> t<span class="op">[</span>sid<span class="op">];</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tn<span class="op">,</span> vn<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">[</span>sid<span class="op">][</span>sid<span class="op">],</span> v<span class="op">[</span>sid<span class="op">],</span> q<span class="op">[</span>sid<span class="op">];</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">&#123;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> n <span class="op">&gt;&gt;</span> K<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i <span class="op">++)</span> cin <span class="op">&gt;&gt;</span> p<span class="op">[</span>i<span class="op">].</span>l <span class="op">&gt;&gt;</span> p<span class="op">[</span>i<span class="op">].</span>r<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    p<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>l <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>p <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> p <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">=</span> i<span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i <span class="op">=</span> j<span class="op">)</span> <span class="op">&#123;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>p<span class="op">[</span>j<span class="op">].</span>l <span class="op">==</span> p<span class="op">[</span>i<span class="op">].</span>l<span class="op">)</span> j <span class="op">++;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        p<span class="op">[++</span> tn<span class="op">]</span> <span class="op">=</span> p<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k <span class="op">++)</span> v<span class="op">[++</span> vn<span class="op">]</span> <span class="op">=</span> p<span class="op">[</span>k<span class="op">].</span>r <span class="op">-</span> p<span class="op">[</span>k<span class="op">].</span>l<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> tn<span class="op">;</span> i <span class="op">++)</span> <span class="op">&#123;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> flag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> tn<span class="op">;</span> j <span class="op">++)</span> </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i <span class="op">!=</span> j <span class="op">&amp;&amp;</span> p<span class="op">[</span>i<span class="op">].</span>l <span class="op">&lt;=</span> p<span class="op">[</span>j<span class="op">].</span>l <span class="op">&amp;&amp;</span> p<span class="op">[</span>j<span class="op">].</span>r <span class="op">&lt;=</span> p<span class="op">[</span>i<span class="op">].</span>r<span class="op">)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>                flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>flag<span class="op">)</span> t<span class="op">[++</span> tmp<span class="op">]</span> <span class="op">=</span> p<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> v<span class="op">[++</span> vn<span class="op">]</span> <span class="op">=</span> p<span class="op">[</span>i<span class="op">].</span>r <span class="op">-</span> p<span class="op">[</span>i<span class="op">].</span>l<span class="op">;</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    tn <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>v <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> v <span class="op">+</span> vn <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    rep<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">)</span> rep<span class="op">(</span>k<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> K<span class="op">)</span> f<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>i <span class="op">||</span> k<span class="op">)</span> <span class="op">?</span> <span class="op">-</span><span class="fl">1e9</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;=</span> K<span class="op">;</span> k <span class="op">++)</span> <span class="op">&#123;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> fr <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> to <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        q<span class="op">[++</span> to<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> tn<span class="op">;</span> i <span class="op">++)</span> <span class="op">&#123;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>fr <span class="op">&lt;=</span> to <span class="op">&amp;&amp;</span> t<span class="op">[</span>q<span class="op">[</span>fr<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>r <span class="op">&lt;=</span> t<span class="op">[</span>i<span class="op">].</span>l<span class="op">)</span> fr <span class="op">++;</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#define pre </span>q<span class="op">[</span>fr<span class="op">]</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>fr <span class="op">&lt;=</span> to<span class="op">)</span> f<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> f<span class="op">[</span>pre<span class="op">][</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> t<span class="op">[</span>pre <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>r <span class="op">-</span> t<span class="op">[</span>i<span class="op">].</span>l<span class="op">;</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>fr <span class="op">&lt;=</span> to <span class="op">&amp;&amp;</span> f<span class="op">[</span>i<span class="op">][</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> t<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>r <span class="op">&gt;=</span> f<span class="op">[</span>q<span class="op">[</span>to<span class="op">]][</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> t<span class="op">[</span>q<span class="op">[</span>to<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>r<span class="op">)</span> to <span class="op">--;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>            q<span class="op">[++</span> to<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> suf <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> K<span class="op">,</span> lst <span class="op">=</span> vn<span class="op">;</span> k <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">(~</span>lst<span class="op">);</span> k <span class="op">--,</span> lst <span class="op">--)</span> <span class="op">&#123;</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>f<span class="op">[</span>tn<span class="op">][</span>k<span class="op">])</span> ans <span class="op">=</span> max<span class="op">(</span>ans<span class="op">,</span> f<span class="op">[</span>tn<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> suf<span class="op">);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        suf <span class="op">+=</span> v<span class="op">[</span>lst<span class="op">];</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div>
<h4 id="j">J</h4>
<h5 id="题解-1">题解</h5>
<p>sb卡常出题人</p>
<h4 id="l">L</h4>
<h5 id="题意-1">题意</h5>
<p>给定<span class="math inline">\(n\)</span>个点，<span class="math inline">\(m\)</span>条边，每次操作为增加一个点的点权</p>
<p>对于每个点，询问有多少次操作后，这个点的点权比其所有相邻点多大</p>
<h5 id="题解-2">题解</h5>
<p>分块，设<span class="math inline">\(B = \sqrt m\)</span>，称<span class="math inline">\(\leq B\)</span>的点为小点，而<span class="math inline">\(&gt; B\)</span>的点为大点</p>
<p>对于小点而言，其邻点只有<span class="math inline">\(B\)</span>个，随意暴力</p>
<p>对于大点而言，其大点的邻居可以不用考虑</p>
<p>取大点为研究对象，考虑其小点邻居，我们直接分权值，存下其邻居中的小点冠军，当权值增加时，我们把相应的小点冠军给取消</p>
<p>这个题中可以利用权值比较小的条件，权值较大时离散化一下即可...</p>
<h4 id="a">A</h4>
<h5 id="题意-2">题意</h5>
<p>给定序列<span class="math inline">\(a_i\)</span>，求满足排序后是等差数列的子区间的数量</p>
<p><span class="math inline">\(1 \leq n \leq 10^5\)</span></p>
<h5 id="题解-3">题解</h5>
<p>这里有一个引理？</p>
<ul>
<li>对于序列<span class="math inline">\(b_i\)</span>，如果排序后为等差数列，那么公差<span class="math inline">\(d = gcd(b_2 - b_1, ..., b_n-b_{n-1})\)</span></li>
</ul>
<p>要证明这个引理，我们只需要考虑证明交换相邻两个数的位置不改变这个式子的值</p>
<p>Case1：我们交换了<span class="math inline">\(1, 2\)</span>，那么只需证明<span class="math inline">\(gcd(b_2-b_1, b_3-b_2) = gcd(b_2-b_1, b_3-b_1)\)</span>，由<span class="math inline">\(gcd(x, y) = gcd(x, x + y)\)</span>，这个是正确的，交换<span class="math inline">\(n, (n-1)\)</span>时同理</p>
<p>Case2：不妨假设我们交换了<span class="math inline">\(i, i + 1(i \neq 1, i+1 \neq n)\)</span>，那么我们只要证明<span class="math inline">\(gcd(b_{i+2}-b_{i+1}, b_{i+1}-b_i, b_i-b_{i-1}) = gcd(b_{i+2}-b_{i}, b_{i}-b_{i+1}, b_{i+1}-b_{i-1})\)</span>，这一点则由<span class="math inline">\(gcd(x, y, z) = gcd(x+y, y, z+y)\)</span>得出</p>
<p>我们只需要计数满足<span class="math inline">\(max - min = d*(r-l)\)</span>的区间个数即可</p>
<p>对<span class="math inline">\(r\)</span>进行扫描线，<span class="math inline">\(max\)</span>和<span class="math inline">\(min\)</span>的变化都只有<span class="math inline">\(O(n)\)</span>段，而每个<span class="math inline">\(l\)</span>而言，<span class="math inline">\(gcd(b_{l+1}-b_l, ..., b_r - b_{r-1})\)</span>至多改变<span class="math inline">\(\log\)</span>次，因此可以每次对<span class="math inline">\(l\)</span>进行逐个单点修改</p>
<p>注意到排序后满足<span class="math inline">\(gcd\)</span>为<span class="math inline">\(d\)</span>的<span class="math inline">\(max - min\)</span>极小的序列就是等差数列，因此我们有<span class="math inline">\(max - min \geq d * (r - l)\)</span>，即<span class="math inline">\(max - min + d * l \geq d * r\)</span>，而<span class="math inline">\(gcd\)</span>对同一个<span class="math inline">\(r\)</span>至多<span class="math inline">\(log\)</span>段，对于每一段维护最小值及个数即可</p>
<h4 id="e">E</h4>
<h5 id="题意-3">题意</h5>
<p>给定一棵树，经过边<span class="math inline">\(e\)</span>将花费<span class="math inline">\(w_e\)</span>升油，而到达<span class="math inline">\(i\)</span>号点将得到<span class="math inline">\(x_i\)</span>升油</p>
<p><span class="math inline">\(q\)</span>次询问，每次询问给定<span class="math inline">\(x, d, p\)</span>，表示从<span class="math inline">\(x\)</span>号点，初始有<span class="math inline">\(d\)</span>升油，不能经过<span class="math inline">\(p\)</span>号的情况下，有多少点是可达的</p>
<h5 id="吐槽">吐槽</h5>
<p>虽然思路很平凡，但是没人翻译，估计也没啥人愿意写...</p>
<h5 id="题解-4">题解</h5>
<p>点分治，之后我们可以强制<span class="math inline">\(x\)</span>走到根节点，往下走到其他点</p>
<p>对于每个点预处理出根节点走到它最少需要多少油，计算贡献时，去除<span class="math inline">\(p\)</span>及自己所在的子树，在<span class="math inline">\(dfn\)</span>序上将对应连续的三段，差分之后，扫描线维护树状数组即可</p>
<h4 id="b">B</h4>
<h5 id="题意-4">题意</h5>
<p>给定一个<span class="math inline">\(2\)</span>行的棋盘，第一行有<span class="math inline">\(a\)</span>个炮，第二行有<span class="math inline">\(b\)</span>个炮，对<span class="math inline">\(k = 0, 1, ..., a + b - 4\)</span>求发生<span class="math inline">\(k\)</span>个炮吃炮事件的方案数</p>
<p>特别的，你还需要输出第一行吃炮事件完全优先于第二行吃炮事件发生的方案数</p>
<h5 id="吐槽-1">吐槽</h5>
<p>感觉也就这样...</p>
<h5 id="题解-5">题解</h5>
<p>显而易见，一个含有<span class="math inline">\(x\)</span>枚棋子的行吃炮的方案数为<span class="math inline">\(2(x - 2)\)</span>，一个含有<span class="math inline">\(x\)</span>枚棋子的行吃<span class="math inline">\(m\)</span>个炮的方案数为<span class="math inline">\(2^m(x-2)(x-3)(x-m+1)=2^m (x-2)_{m}\)</span></p>
<p>一般的，输出$2^k _{i+j = k} (a-2)_i (b-2)_j  $；</p>
<p>对于特别的情况，输出<span class="math inline">\(2^k \sum_{i+j=k} (a-2)_i (b-2)_j\)</span></p>
<p>而<span class="math inline">\(2^k \sum_{i+j = k} (a-2)_i (b-2)_j C^i_k = 2^k k! \sum_{i+j = k} C^{a-2}_i C^{b-2}_j = 2^k k! C^{a+b-4}_k\)</span></p>
<p>且<span class="math inline">\(2^k \sum_{i+j=k} (a-2)_i (b-2)_j = 2^k \frac{(a-2)!(b-2)!}{(a+b-4-k)!}\sum_{i+j=k} C^{a+b-4-k}_{a-2-i}\)</span></p>
<p>后面是一个组合数列和，可以求</p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第五场</title>
    <url>/2021/08/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA/</url>
    <content><![CDATA[<span id="more"></span>
<p>Gromah的题...</p>
<p>有些科技还是太为难老年人了...</p>
<h4 id="c">C</h4>
<h5 id="题意">题意</h5>
<p>给定一个长为<span class="math inline">\(n\)</span>的串，表示两个人打乒乓球，连续打<span class="math inline">\(n\)</span>个球的结果</p>
<p>对于<span class="math inline">\(i\)</span>，我们定义<span class="math inline">\(i\)</span>赛制表示，双方中有一方得分超过<span class="math inline">\(i\)</span>分，并且分差大于等于<span class="math inline">\(2\)</span>时结果比赛的赛制</p>
<p>现在询问，对<span class="math inline">\(i = 1, 2, ..., n\)</span>，在<span class="math inline">\(i\)</span>赛制的情况下，Gromah赢了多少场</p>
<h5 id="题解">题解</h5>
<p>还挺有意思的</p>
<p>一个显然的性质是，在<span class="math inline">\(i\)</span>赛制下，比赛最多只有<span class="math inline">\(\lfloor \frac{n}{i} \rfloor\)</span>场</p>
<p>.....然后考场上就短路了...</p>
<p>我们可以预处理出<span class="math inline">\(A\)</span>赢了<span class="math inline">\(i\)</span>个球的位置和<span class="math inline">\(B\)</span>赢了<span class="math inline">\(i\)</span>个球的位置，依次，我们可以判断他们是否进入了平局的阶段，如果进入了平局的阶段，说明之后的比赛应该是两者一赢一输，这个段也可以预处理出来</p>
<p>然后就完事了</p>
<h4 id="e">E</h4>
<h5 id="吐槽">吐槽</h5>
<p>考场上写的脑子有点懵</p>
<p>C++的右移是坑爹的逻辑右移，对一个负数不断右移会得到一堆<span class="math inline">\(1\)</span>，在利用<span class="math inline">\(\sim\)</span>时被卡了记下...</p>
<h4 id="g">G</h4>
<h5 id="吐槽-1">吐槽</h5>
<p>奇奇怪怪题</p>
<h5 id="题意-1">题意</h5>
<p>给定<span class="math inline">\(a, b, \{p_i\}, \{q_i\}\)</span>，定义<span class="math inline">\(c = \prod p_i^{q_i}\)</span>，尝试找到<span class="math inline">\(x, y\)</span>，使得<span class="math inline">\(x + y\)</span>最小，并且<span class="math inline">\(lcm(a+x, b+y) = c\)</span></p>
<h5 id="题解-1">题解</h5>
<p>队友的做法我没听...好像是极限数据<span class="math inline">\(2^{27}\)</span>，但能卡卡的做法...（然后就WA了）</p>
<p>一个简单的想法是，枚举<span class="math inline">\(c\)</span>的约数<span class="math inline">\(d_1\)</span>，假设<span class="math inline">\(a + x = d_1\)</span>，<span class="math inline">\(d_1\)</span>也许会在若干质数上的次数没有卡到<span class="math inline">\(q_i\)</span>，这就需要<span class="math inline">\(b+y\)</span>去调整，也就是说相当于对于某个数<span class="math inline">\(M\)</span>，<span class="math inline">\(b+y\)</span>需要是<span class="math inline">\(M\)</span>的倍数，而系数则应该是剩下卡到<span class="math inline">\(q_i\)</span>的位置上质数次幂乘积的一个因子，难点在于如何寻找这个因子</p>
<p>利用折半搜索优化一下复杂度就能过了...</p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法（下）</title>
    <url>/2022/06/numertical-analysis-2/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="part-4">Part 4</h2>
<h3 id="graph-spectrum">Graph spectrum</h3>
<ul>
<li>定义</li>
</ul>
<p>称<span class="math inline">\(A(G)\)</span>为<span class="math inline">\(G\)</span>的邻接矩阵，<span class="math inline">\(D(G)\)</span>为<span class="math inline">\(G\)</span>的度数矩阵，<span class="math inline">\(L = D-A\)</span>为<span class="math inline">\(G\)</span>的拉普拉斯矩阵</p>
<ul>
<li>二分图</li>
</ul>
<blockquote>
<p>对于二分图<span class="math inline">\(G\)</span>，如果<span class="math inline">\(\lambda\)</span>是<span class="math inline">\(A(G)\)</span>的一个特征值，且重数为<span class="math inline">\(k\)</span>，那么<span class="math inline">\(-\lambda\)</span>也是<span class="math inline">\(A(G)\)</span>的重数为<span class="math inline">\(k\)</span>的特征值</p>
</blockquote>
<p>注意到<span class="math inline">\(A(G)\)</span>是实对称矩阵，不需要区分代数重数和几何重数</p>
<p>考虑把<span class="math inline">\(A\)</span>分块为<span class="math inline">\(\begin{bmatrix} O&amp;B \\ B^T&amp;O\end{bmatrix}\)</span>，那么不难验证<span class="math inline">\(\binom{x}{y}\)</span>和<span class="math inline">\(\binom{x}{-y}\)</span>分别是<span class="math inline">\(\pm \lambda\)</span>的特征向量，并且根据这个性质，如果<span class="math inline">\(\lambda\)</span>有<span class="math inline">\(k\)</span>个线性无关的向量，那么<span class="math inline">\(-\lambda\)</span>也有</p>
<blockquote>
<p>设<span class="math inline">\(A(G)\)</span>的特征值为<span class="math inline">\(\lambda_1 \geq \lambda_2 \geq ... \geq \lambda_n\)</span>，并且<span class="math inline">\(\lambda_i = -\lambda_{n-i+1}\)</span>，那么<span class="math inline">\(G\)</span>为二分图</p>
</blockquote>
<p>注意到对奇数<span class="math inline">\(k\)</span>，<span class="math inline">\(tr(A^k) = \sum \lambda^k = 0\)</span>，而<span class="math inline">\(tr(A^k)\)</span>表示所有点经过<span class="math inline">\(k\)</span>条边后回到自身的方案数的和</p>
<ul>
<li>一般图</li>
</ul>
<blockquote>
<p><span class="math inline">\(\deg_{avg}(G) \leq \lambda_{max}(A(G)) \leq \deg_{max}(G) = \Delta(G)\)</span></p>
</blockquote>
<p>设<span class="math inline">\(x\)</span>为对应的特征向量，并且<span class="math inline">\(i = \arg \max x_j\)</span>那么<span class="math inline">\(\lambda x_i = (Ax)_i = \sum_{j} A_{ij} x_j \leq (\sum_{j} A_{ij}) x_i = deg_i(G) x_i \leq \Delta(G) x_i\)</span></p>
<ul>
<li>拉普拉斯矩阵</li>
</ul>
<p>不难注意到：<span class="math inline">\(1\)</span>是<span class="math inline">\(L(G)\)</span>的特征向量，对应的特征值为<span class="math inline">\(0\)</span></p>
<p>根据<span class="math inline">\(x^TLx = \sum_{ij \in E} (x_i - x_j)^2\)</span>，我们有<span class="math inline">\(L(G) \geq 0\)</span></p>
<blockquote>
<p>设<span class="math inline">\(L(G)\)</span>的特征值为<span class="math inline">\(\lambda_1 \leq \lambda_2 ... \leq \lambda_n\)</span>，那么<span class="math inline">\(G\)</span>连通当且仅当<span class="math inline">\(\lambda_2 &gt; 0\)</span></p>
<p>进一步，<span class="math inline">\(0\)</span>作为特征值的重数实际上揭示了<span class="math inline">\(G\)</span>的连通分量的数量</p>
</blockquote>
<p>首先对连通情况作证明：如果不连通，那么至少<span class="math inline">\(L(G) = diag\{L_1(G), L_2(G)\}\)</span>，从而0至少有2个线性无关的特征向量</p>
<p>反之，如果连通，如果<span class="math inline">\(Lx = 0\)</span>，那么<span class="math inline">\(x^T L x = \sum_{ij} (x_i - x_j)^2 = 0\)</span>，由于连通，因此<span class="math inline">\(x\)</span>的任意分量相同，故<span class="math inline">\(x = c 1\)</span></p>
<p>如果<span class="math inline">\(G\)</span>有<span class="math inline">\(k\)</span>个连通分量，那么<span class="math inline">\(L(G) = diag\{L_1(G), L_2(G), ..., L_k(G)\}\)</span>，其中<span class="math inline">\(L_1(G), ..., L_k(G)\)</span>是<span class="math inline">\(k\)</span>个连通分量对应的子图，根据连通的结论，<span class="math inline">\(L(G)\)</span>中<span class="math inline">\(0\)</span>的代数重数恰好为<span class="math inline">\(k\)</span>，如果代数重数为<span class="math inline">\(k\)</span>，那么<span class="math inline">\(G\)</span>也只能有<span class="math inline">\(k\)</span>个连通分量</p>
<h3 id="perron-frobenius-theorem">Perron-Frobenius Theorem</h3>
<blockquote>
<p>设<span class="math inline">\(A\)</span>为非负，不可约且非周期的矩阵，那么</p>
<ul>
<li><span class="math inline">\(A\)</span>的最大特征值的重数为1</li>
<li>对应的特征向量中，每个维度都是非零且同号的</li>
<li><span class="math inline">\(|\lambda_i| &lt; \lambda_1\)</span></li>
</ul>
</blockquote>
<h3 id="random-walk">Random Walk</h3>
<p>考虑随机游走，记<span class="math inline">\(X_t\)</span>为时间<span class="math inline">\(t\)</span>随机游走所处状态的概率，那么，存在一个转移矩阵使得<span class="math inline">\(X_{t+1} = X_t P\)</span></p>
<ul>
<li>定义</li>
</ul>
<p>对于有限的马尔可夫链，如果其对应的有向图是强连通的，那么称其为不可约的</p>
<p>对于马尔可夫链，定义状态<span class="math inline">\(i\)</span>的周期为<span class="math inline">\(period(i) := \gcd\{t:P_{i,i}^t &gt; 0\}\)</span>，如果状态<span class="math inline">\(i\)</span>的周期为<span class="math inline">\(1\)</span>，那么称其为非周期的，如果所有的状态都是非周期的，那么称该马尔可夫链是非周期的</p>
<ul>
<li>马尔可夫链基本定理</li>
</ul>
<blockquote>
<p>对于有限，不可约，非周期的马尔可夫链</p>
<ul>
<li>存在且仅存在一个稳态分布<span class="math inline">\(\pi\)</span></li>
<li>无论<span class="math inline">\(p_0\)</span>如何，一定有<span class="math inline">\(\lim_{t \to \infty} p_t \to \pi\)</span></li>
<li><span class="math inline">\(\pi(i) = 1/ h_i\)</span>，其中<span class="math inline">\(h_i = \mathbb{E}[H_i]\)</span>，而<span class="math inline">\(H_i := \min\{t \geq 1 | X_t = i, X_0 = i\}\)</span></li>
</ul>
</blockquote>
<ul>
<li>无向图的讨论</li>
</ul>
<p>在无向图里面，转移矩阵一般认为是<span class="math inline">\(AD^{-1}\)</span>（也即均匀从邻居中选出一个）</p>
<p>那么，<span class="math inline">\(p_{t+1} = (AD^{-1})p_t\)</span>，因此<span class="math inline">\(p_t = (AD^{-1})^t p_0\)</span></p>
<p>不难验证，<span class="math inline">\(\pi = \frac{1}{2m}(deg(1), ..., deg(n))\)</span>是<span class="math inline">\(AD^{-1}\)</span>的一个特征向量，从而是一个稳态分布</p>
<p>在无向图内，不可约即连通图，非周期即非二分图，因此我们有</p>
<ul>
<li>对于有限连通非二分图，都有<span class="math inline">\(p_t \to \pi\)</span></li>
</ul>
<p>对于二分图，我们则可以考虑每个点以<span class="math inline">\(1/2\)</span>的概率停留，以<span class="math inline">\(1/2\)</span>的概率进行随机游走（相当于每个点加一个自环）</p>
<p>转移矩阵写为<span class="math inline">\(p_{t+1} = (\frac{1}{2}I + \frac{1}{2}AD^{-1})p_t\)</span></p>
<ul>
<li>对<span class="math inline">\(d-\)</span>正则图的分析</li>
</ul>
<p>在<span class="math inline">\(d-\)</span>正则图中，<span class="math inline">\(\lambda_2(AD^{-1}) &lt; 1\)</span>描述了图的连通性，<span class="math inline">\(\lambda_{n(AD^{-1})} &gt; -1\)</span>描述了图的非周期性</p>
<p>根据这个思路，我们定义<span class="math inline">\(\lambda = \min\{1 - \lambda_2, 1 - |\lambda_n|\}\)</span>为谱间隔</p>
<blockquote>
<p>随机游走的<span class="math inline">\(\epsilon-\)</span>混合时间最多为<span class="math inline">\(\frac{1}{\lambda} \log (n / \epsilon)\)</span></p>
<p>其中<span class="math inline">\(\epsilon-\)</span>混合时间定义为最小的整数<span class="math inline">\(t\)</span>，使得<span class="math inline">\(||p_t - \pi||_1 \leq \epsilon, \forall p_0\)</span></p>
</blockquote>
<p>直观上来说，混合时间就是说，过了这个时间之后，我们不再能区分是从哪个点出发</p>
<p>证明：取一组标准正交特征向量<span class="math inline">\(v_1,v_2,...,v_n\)</span>，其中<span class="math inline">\(v_1 = \pi\)</span>，对应的特征值为<span class="math inline">\(1 = \alpha_1 \geq \alpha_2 ... \alpha_n \geq -1\)</span>（这个假设是不失一般性的，留作习题）</p>
<p><span class="math inline">\(||p_t - \pi||_2^2 = c_2^2 \alpha_2^{2t} + ... + c_n^2 \alpha_n^{2t} \leq (c_2^2 + ... + c_n^2) (1 - \lambda)^{2t} \leq ||p_0||_1 (1-\lambda)^{2t} = (1-\lambda)^{2t}\)</span></p>
<p>其中用到了<span class="math inline">\(||p_0||_2^2 \leq ||p_0||_1\)</span></p>
<h3 id="resistance-network">Resistance network</h3>
<ul>
<li>定义</li>
</ul>
<p>在一张无向图<span class="math inline">\(G\)</span>上，每条边上有一个电阻<span class="math inline">\(r_e\)</span>，之后每条边需要流过方向电流<span class="math inline">\(i_e(i_{uv} =-i_{vu})\)</span></p>
<p>对于每条边，我们也称其具有电导率<span class="math inline">\(w_e = 1/r_e\)</span></p>
<p>对于每个顶点，则有电势<span class="math inline">\(\phi_v\)</span>和一个对于每个节点，统计总流入电流的量<span class="math inline">\(b_v\)</span></p>
<ul>
<li>假设</li>
</ul>
<p>一般的，我们要求如下定律满足：</p>
<p>基尔霍夫定律：<span class="math inline">\(\sum_{vu \in E} i_{vu} = b_v, \forall v \in V\)</span></p>
<p>欧姆定律：<span class="math inline">\(\phi(u) - \phi(v) = i_{uv}r_{uv}\)</span>，加权形式下为<span class="math inline">\(w_{uv}(\phi(u) - \phi(v)) = i_{uv}\)</span></p>
<p>合并上两式，我们得到<span class="math inline">\(b_v = \deg(v) \phi(v) - \sum_{vu \in E} w_{uv} \phi(u)\)</span>，其中<span class="math inline">\(\deg(v)\)</span>是<span class="math inline">\(w\)</span>的加权的和</p>
<p>此时有，<span class="math inline">\(b = L \phi\)</span>，当然<span class="math inline">\(L\)</span>是加权的拉普拉斯矩阵</p>
<ul>
<li>推导</li>
</ul>
<p>（假设网络是连通的）</p>
<p>设<span class="math inline">\(L = \sum \lambda_i v_i v_i^T\)</span>，其中<span class="math inline">\(\lambda_1 \leq \lambda_2 \leq ...\)</span>并且<span class="math inline">\(v_1, v_2, ..., v_n\)</span>为正交标准基</p>
<blockquote>
<p>存在向量<span class="math inline">\(\phi\)</span>使得<span class="math inline">\(L \phi = b\)</span>的充要条件为<span class="math inline">\(b \perp 1\)</span></p>
</blockquote>
<p>首先，我们证明<span class="math inline">\(L \phi \perp 1\)</span>，由于<span class="math inline">\(1\)</span>在<span class="math inline">\(L\)</span>的零空间中，这个事实不难证明</p>
<p>反之，令<span class="math inline">\(\phi = L^{\ddagger} b\)</span>，其中<span class="math inline">\(L^{\ddagger} = \sum_{i \geq 2} \lambda_i^{-1} v_iv_i^{T}\)</span></p>
<hr />
<p>根据上述知识，<span class="math inline">\(L \phi = b\)</span>的全体解集形如<span class="math inline">\(\{L^{\ddagger b} + c\mathbb{1}: c\in R\}\)</span></p>
<p>在固定某个点的电势后，将有唯一的解</p>
<ul>
<li>等效电阻</li>
</ul>
<p>定义<span class="math inline">\(s,t\)</span>之间的等效电阻<span class="math inline">\(R_{eff}(s, t) := \phi(s) - \phi(t)\)</span>，其中<span class="math inline">\(\phi\)</span>满足<span class="math inline">\(L \phi = b_{st}\)</span>，<span class="math inline">\(b_{st}\)</span>是只在<span class="math inline">\(s\)</span>上分量为1，在<span class="math inline">\(t\)</span>上分量为-1的向量（相当于从s流入1的电流，从t流出1的电流的电阻）</p>
<p>注意到<span class="math inline">\(\phi = L^{\ddagger} b_{st}\)</span>，又<span class="math inline">\(b_{st}^T \phi = \phi(s) - \phi(t)\)</span>，因此<span class="math inline">\(R_{eff}(s, t) = b_{st}^T L^{\ddagger} b_{st}\)</span></p>
<ul>
<li>电势能</li>
</ul>
<p>定义电势能为：<span class="math inline">\(\mathscr{E}(i) := \sum_e i_e^2 r_e = \sum_e w_e[\phi(u) - \phi(v)]^2 = \phi^T L \phi\)</span></p>
<p>根据上面的式子，不难看出<span class="math inline">\(\mathscr{E}(i) = \phi^T b = b^T \phi = b^T L^{\ddagger} b = R_{eff}(s, t)\)</span>（其中<span class="math inline">\(i\)</span>为<span class="math inline">\(s\)</span>到<span class="math inline">\(t\)</span>的单位电流）</p>
<blockquote>
<p><span class="math inline">\(\mathscr{E}(i) = R_{eff}(s, t) \leq \mathscr{E}(f)\)</span>，其中<span class="math inline">\(f\)</span>是任意的<span class="math inline">\(s-t\)</span>流</p>
</blockquote>
<p>对于任意流优化<span class="math inline">\(\mathscr{E}(f)\)</span>，这是一个凸问题，电势能满足极值条件</p>
<blockquote>
<p>如果<span class="math inline">\(r \geq r&#39;\)</span>，那么<span class="math inline">\(R_{eff, r}(s, t) \geq R_{eff, r&#39;}(s, t)\)</span></p>
</blockquote>
<p>不难想象，证明则利用电势能作为桥梁</p>
<blockquote>
<p><span class="math inline">\(R_{eff}(a, b) + R_{eff}(b, c) \geq R_{eff}(a, c)\)</span></p>
</blockquote>
<p>将<span class="math inline">\(a\)</span>到<span class="math inline">\(b\)</span>的单位电流和<span class="math inline">\(b,c\)</span>的单位电流组合以下，就得到了一个<span class="math inline">\(a\)</span>到<span class="math inline">\(c\)</span>的流，根据上面的不等式即可证明</p>
<ul>
<li>电阻网络与随机游走</li>
</ul>
<p>碰撞时间：定义随机变量<span class="math inline">\(H_{uv} := \min\{t \geq 1 | X_1 = u, X_t = v\}\)</span>，之后定义碰撞事件<span class="math inline">\(h_{uv} := \mathbb{E}[H_{u, v}]\)</span></p>
<p>返程时间：<span class="math inline">\(C_{u, v} := h_{u, v} + h_{v, u}\)</span></p>
<blockquote>
<p>我们把无向图看作是所有边<span class="math inline">\(r_e = 1\)</span>的电阻网络，那么<span class="math inline">\(C_{s,t} = 2m R_{eff}(s, t)\)</span></p>
</blockquote>
<p>不难想象，考虑<span class="math inline">\(h_{*, t} = (h_{1, t}, ..., h_{t, t})\)</span>，这些碰撞时间存在一些关系，用矩阵写出来为<span class="math inline">\(d_v = (L h_{*, t})_v, \forall v \neq t\)</span></p>
<p>对于第<span class="math inline">\(t\)</span>行，我们需要特殊考虑，注意到<span class="math inline">\(L \phi = b\)</span>有解当且仅当<span class="math inline">\(b \perp 1\)</span>，因此我们希望构造一个<span class="math inline">\(d&#39;\)</span>，使得<span class="math inline">\(d&#39; \perp 1\)</span></p>
<p>取<span class="math inline">\(d&#39; = -\sum_{i \neq t} d_i = d_t - 2m\)</span>即可，这个时候可以保证方程组有解</p>
<p>这个时候，观察到<span class="math inline">\(L(h_{*, t} - h_{*, s}) = 2m b_{st}\)</span>，而<span class="math inline">\(R_{eff}(s, t)\)</span>则对应的是<span class="math inline">\(L \phi = b_{st}\)</span></p>
<p>稍作说明，就可以得到所需的结论</p>
<h2 id="part-5">Part 5</h2>
<h3 id="linear-programming">Linear Programming</h3>
<p>一般的，形如 <span class="math display">\[
\begin{aligned}
&amp; \max c^T x
\\ &amp;s.t.\; Ax \leq b
\end{aligned}
\]</span> 形式的优化问题称为线性规划</p>
<p>其中，<span class="math inline">\(Ax \leq b\)</span>称为约束条件，<span class="math inline">\(c^T x\)</span>为目标函数</p>
<hr />
<p>可以证明，上面的形式和下面的形式是可以互相转化的 <span class="math display">\[
\begin{aligned}
&amp; \max c^T x
\\&amp; s.t. Ax \leq b, x \geq 0
\end{aligned}
\]</span></p>
<ul>
<li>顶点</li>
</ul>
<p><span class="math inline">\(Ax \geq b\)</span>实际上是一堆半空间的交，此时，可行解的空间构成一个polytope</p>
<p>对于polytope <span class="math inline">\(P = \{x:Ax \leq b\}\)</span>，我们可以定义顶点，下面关于顶点的3种定义互相等价</p>
<ol type="1">
<li>边角点：<span class="math inline">\(x\)</span>为边角点，当且仅当不存在<span class="math inline">\(y \neq 0\)</span>使<span class="math inline">\(x+y \in P\)</span>并且<span class="math inline">\(x - y \in P\)</span></li>
<li>极值点：<span class="math inline">\(x\)</span>为极值点，当且仅当存在<span class="math inline">\(c\)</span>使得，<span class="math inline">\(c^Tx &gt; c^T x&#39;, \forall x&#39; \neq x \in P\)</span></li>
<li>基本解：记<span class="math inline">\(x\)</span>在约束条件<span class="math inline">\(Ax \leq b\)</span>取到等于的对应行的矩阵为<span class="math inline">\(A^{=}x = b^=\)</span>，如果<span class="math inline">\(\rank(A^=)\)</span>满秩，则称<span class="math inline">\(x\)</span>是一个基本解</li>
</ol>
<p>一般情况下，顶点可能是指数级别的</p>
<h3 id="weak-duality">Weak Duality</h3>
<ul>
<li>对偶问题</li>
</ul>
<p>对于一个特定的线性规划：</p>
<p>记<span class="math inline">\(A = (A_1, A_2, ..., A_m)^T = (A_1&#39;, A_2&#39;,...,A_n&#39;)\)</span></p>
<p>即<span class="math inline">\(A_1, ..., A_m\)</span>为行向量，<span class="math inline">\(A_1&#39;, ..., A_n&#39;\)</span>为列向量 <span class="math display">\[
\begin{aligned}
&amp; \max c_1x_1 + c_2x_2 + ... +c_nx_n
\\s.t. &amp;\;A_1^T x\leq b_1, A_2^T x \leq b_2, ..., A_m^T x \leq b_m
\\ &amp;\;x_1, x_2,...,x_n \geq 0
\end{aligned}
\]</span> 我们定义其对偶问题为 <span class="math display">\[
\begin{aligned}
&amp;\min b_1y_1 + b_2y_2 + ... + b_my_m
\\s.t. &amp;\; (A_1&#39;)^Ty_1 \geq c_1, ..., (A_n&#39;)^Ty_n \geq c_n
\\&amp;\;y_1, ..., y_m \geq 0
\end{aligned}
\]</span> 用矩阵形式给出，也就是 <span class="math display">\[
\begin{aligned}
&amp;\max c^T x &amp;&amp; \min b^Ty
\\s.t.&amp;\;Ax \leq b &amp;s.t.&amp;\;A^Ty \geq c
\\ &amp;\;x \geq 0 &amp;&amp;\;y \geq 0
\end{aligned}
\]</span></p>
<ul>
<li>弱对偶性定理</li>
</ul>
<p>对于任何最大化LP中的可行解<span class="math inline">\(x\)</span>，与对偶的最小化LP中的可行解<span class="math inline">\(y\)</span>，都有<span class="math inline">\(c^T x \leq b^T y\)</span></p>
<p>证明：<span class="math inline">\(c^T x \leq (y^T A) x = y^T(Ax) \leq y^T b = b^T y\)</span></p>
<hr />
<p>上述定理告诉我们，如果<span class="math inline">\(c^T x^* = b^T y^*\)</span>，那么<span class="math inline">\(x^*, y^*\)</span>为最优解</p>
<ul>
<li>强对偶性定理</li>
</ul>
<p>如果最大化LP中存在最优解<span class="math inline">\(x^*\)</span>，那么最小化LP中存在最优解<span class="math inline">\(y^*\)</span>，并且<span class="math inline">\(c^T x^* = b^T y^*\)</span></p>
<ul>
<li>互补松弛条件</li>
</ul>
<p>考查弱对偶性中的取等条件：<span class="math inline">\(c^T x \leq (y^T A) x = y^T(Ax) \leq y^T b = b^T y\)</span></p>
<p><span class="math inline">\(c^T x \leq (y^T A) x\)</span>取到等号，当且仅当要么<span class="math inline">\(x_i = 0\)</span>，要么<span class="math inline">\((y^T A)_i = c_i\)</span></p>
<p><span class="math inline">\(y^T(Ax) \leq y^T b\)</span>取到等号，当且仅当要么<span class="math inline">\(y_j = 0\)</span>，要么<span class="math inline">\((Ax)_j = b_j\)</span></p>
<h3 id="minimax-theorem">Minimax Theorem</h3>
<blockquote>
<p><span class="math inline">\(\max_x \min_y x^T Ay = \min_x \max_y x^T Ay\)</span></p>
<p>其中，<span class="math inline">\(\sum x_i = \sum y_i = 1, x_i, y_i \geq 0\)</span></p>
</blockquote>
<p><span class="math inline">\(\max_x \min_y x^T A y = \max_x \min_j (x^T A)_j\)</span>，而后者可以写为一个线性规划： <span class="math display">\[
\begin{aligned}
&amp; \max_x t
\\ s.t. &amp;\; x^T A \geq t \bf{1}
\\ &amp;\; \sum x_i = 1
\\ &amp;\; x \geq 0
\end{aligned}
\]</span> 这个线性规划的对偶问题为（下面的<span class="math inline">\(\min t\)</span>实际上对应了原问题中的<span class="math inline">\(\sum x_i = 1\)</span>） <span class="math display">\[
\begin{aligned}
&amp;\min_y t
\\ s.t. &amp;\; Ax \leq t \bf{1}
\\ &amp;\; \sum y_i = 1
\\ &amp;\; y \geq 0
\end{aligned}
\]</span> 而这个问题的最优解恰好就是<span class="math inline">\(\min_y \max_x x^T Ay\)</span></p>
<p>弱对偶性定理实际上告诉我们<span class="math inline">\(\max_x \min_y x^T A y \leq \min_y \max_x x^T A y\)</span></p>
<p>根据强对偶性定理，两者可以取到等号</p>
<h3 id="multiplicative-weight-update">Multiplicative weight update</h3>
<ul>
<li>背景</li>
</ul>
<p>考虑这么一个问题，有<span class="math inline">\(n\)</span>个人在工作，其中第<span class="math inline">\(i\)</span>个人在第<span class="math inline">\(T\)</span>天会产生<span class="math inline">\(l_i^{(t)}\)</span>的价值（价值不一定是非负数），我们希望找到工作的最好的一个人，也即使得<span class="math inline">\(\sum l_i^{(t)}\)</span>最大的<span class="math inline">\(i\)</span></p>
<p>不过，我们加上下面的限制：你需要在每一天选择一个人工作，但是你只能知道在<span class="math inline">\(1, 2, ..., T-1\)</span>天所有人的工作价值</p>
<p>注意：这里的人是抽象的人，并不一定要满足某种特殊的规律，<span class="math inline">\(l_i^{(t)}\)</span>可以是符合经验的，可以是随机的，甚至可以是对抗你的算法的</p>
<ul>
<li>MWU算法</li>
</ul>
<p>我们考虑给每个人一个权重，如果一个人某一天生产的价值为正数，那么他的权重相应程度增加，也即</p>
<blockquote>
<p>固定参数<span class="math inline">\(\eta \leq 1/2\)</span>，对于每个人定义一个初始权重<span class="math inline">\(w_i^{(1)} = 1, \forall 1 \leq i \leq n\)</span></p>
<p>之后，对于每天进行如下的决策</p>
<ol type="1">
<li>以<span class="math inline">\(p_i^{(t)} = w_i^{(t)} / (\sum_{i=1}^n) w_i^{(t)}\)</span>选择第<span class="math inline">\(i\)</span>个人</li>
<li>之后得到人们第<span class="math inline">\(T\)</span>天的表现</li>
<li>更新权重，<span class="math inline">\(w_i^{(T+1)} = w_i^{(T)} * (1 - \eta l_i^{(T)})\)</span></li>
</ol>
</blockquote>
<ul>
<li>MWU定理</li>
</ul>
<blockquote>
<p>假设<span class="math inline">\(l_i^{(t)} \in [-1, +1], \forall i, t\)</span>，并且<span class="math inline">\(l_*\)</span>是表现最好的人，那么MWU算法的期望价值满足</p>
<p><span class="math inline">\(\sum_{t=1}^T \langle l^{(t)}, p^{(t)} \rangle \leq \sum_{t=1}^ T l_*^{(t)} + \eta \sum_{t=1}^T |l_*^{(t)}| + \ln n / \eta\)</span></p>
</blockquote>
<p>证明：证明：我们来考虑<span class="math inline">\(\Phi^{(t)} = \sum_{t=1}^n w_i^{(t)}\)</span>进行上下界的估计</p>
<p>上界：<span class="math inline">\(\Phi^{(t+1)} = \sum_{i=1}^n w_i^{(t)} - \eta \langle l^{(t)}, w^{(t)} \rangle = \Phi^{(t)} (1-\eta \langle l^{(t)}, p^{(t)}\rangle) \leq \Phi^{(t)} e^{-\eta \langle l^{(t)}, p^{(t)}\rangle}\)</span></p>
<p>下界：<span class="math inline">\(\Phi^{(t)} = \sum_{i=1}^n w_i^{(t)} \geq w_*^{(t)} = \prod_{i=1}^T (1-\eta l_*^{(i)}) \geq (1-\eta)^{\sum_{\geq 0} l_*^{(t)}} (1+\eta)^{-\sum_{&lt;0} l_*^{(t)}}\)</span></p>
<p>这里用到了<span class="math inline">\(1 - \eta x \geq (1-\eta)^x, x\in [0,1]\)</span>以及<span class="math inline">\(1-\eta x \geq (1+\eta)^x, x \in [-1,0]\)</span></p>
<p>结合上下界进行整理就可以得到结论</p>
<hr />
<p>因此，我们的价值离最优解最多相差<span class="math inline">\(\eta T + \ln n / \eta\)</span>，取<span class="math inline">\(\eta = \sqrt{\ln n / T}\)</span>，这个量级差不多是<span class="math inline">\(O(\sqrt{T \ln n})\)</span>的</p>
<p>此时，平均每天的遗憾为<span class="math inline">\(\sqrt{\ln n / T}\)</span>，当<span class="math inline">\(T\)</span>足够大时，遗憾将趋于0</p>
<ul>
<li>使用MWU定理证明Minimax Theorem</li>
</ul>
<p>略</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>numerical_analysis</tag>
      </tags>
  </entry>
</search>
